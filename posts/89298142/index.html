<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Python源码阅读-内存管理机制 | Shawn&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Python,源码," />
  

  <meta name="description" content="终于来到了最后一部分: 内存管理.">
<meta name="keywords" content="Python,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Python源码阅读-内存管理机制">
<meta property="og:url" content="http://shawnz.me/posts/89298142/index.html">
<meta property="og:site_name" content="Shawn&#39;s Blog">
<meta property="og:description" content="终于来到了最后一部分: 内存管理.">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-1.jpg">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-2.png">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-3.png">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-4.png">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-6.png">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-7.png">
<meta property="og:updated_time" content="2018-03-10T06:20:54.150Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python源码阅读-内存管理机制">
<meta name="twitter:description" content="终于来到了最后一部分: 内存管理.">
<meta name="twitter:image" content="http://shawnz.me/images/pymemobject-1.jpg">

  

  
    <link rel="icon" href="/favicon.png">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/custom.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存架构"><span class="toc-text">内存架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第1层低级内存分配器"><span class="toc-text">第1层低级内存分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#block"><span class="toc-text">block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pool"><span class="toc-text">pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arena"><span class="toc-text">arena</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第2层对象分配器"><span class="toc-text">第2层对象分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usedpools"><span class="toc-text">usedpools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyObject-Malloc"><span class="toc-text">_PyObject_Malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyObject-Free"><span class="toc-text">_PyObject_Free</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第3层特殊对象缓冲机制"><span class="toc-text">第3层特殊对象缓冲机制</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Python源码阅读-内存管理机制" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Python源码阅读-内存管理机制</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.01.11</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Shawn Zhong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>终于来到了最后一部分: 内存管理.</p>
<a id="more"></a>
<h2 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h2><p>在Python中, 当要分配内存时, 不单纯要用<code>malloc/free</code>, 而是在其基础上堆放三个独立的分层, 有效地进行分配.</p>
<div style="width: 70%"><img src="/images/pymemobject-1.jpg" alt=""></div>

<p>第<code>0</code>层往下是<code>OS</code>的功能, 我们要讲的内存管理不涉及这一部分.</p>
<p>第<code>0</code>层是操作系统的内存管理接口, 比如<code>C</code>运行时提供的<code>mallocl</code>和<code>free</code>接口, Python并不干涉这一层的行为.</p>
<p>第<code>1</code>层是基于第<code>0</code>层操作系统的内存管接口包装而成的, 这一层主要是为Python提供统一的<code>raw memory</code>管理接口, 处理平台相关的内存分配. 在Python中, 第<code>1</code>的实现是一组<code>PyMem_</code>为前缀的函数族.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c]</span><br><span class="line"><span class="comment">/* 函数接口 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * </span><br><span class="line">_PyMem_RawMalloc(<span class="keyword">void</span> *ctx, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_PyMem_RawRealloc(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">realloc</span>(ptr, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_PyMem_RawFree(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *ptr) &#123; <span class="built_in">free</span>(ptr); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 */</span></span><br><span class="line">[pymem.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_MALLOC(n)         PyMem_Malloc(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_REALLOC(p, n)     PyMem_Realloc(p, n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_FREE(p)           PyMem_Free(p)</span></span><br></pre></td></tr></table></figure>
<p>可以看到Python只是对C中<code>malloc/realloc/free</code>等进行了一次包装. 不过由于不同操作系统针对<code>malloc(0)</code>表现不同, 有的会返回<code>NULL</code>, 有的会返回一个没有指向内存的空指针, 所以Python不允许申请大小为<code>0</code>的内存空间, 将会强制转换成申请大小为<code>1</code>字节的内存空间.</p>
<p>Python同时提供了函数和宏两套接口, 使用宏可以提高运行效率, 不过在编写<code>C</code>扩展模块的时候, 建议使用函数接口.</p>
<p>其实在第<code>1</code>层, Python还提供了面向Python中类型的内存分配接口:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_New(type, n) \</span></span><br><span class="line">  ( ((<span class="keyword">size_t</span>)(n) &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(type)) ? <span class="literal">NULL</span> :	\</span><br><span class="line">	( (type *) PyMem_Malloc((n) * <span class="keyword">sizeof</span>(type)) ) )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_NEW(type, n) \</span></span><br><span class="line">  ( ((<span class="keyword">size_t</span>)(n) &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(type)) ? <span class="literal">NULL</span> :	\</span><br><span class="line">	( (type *) PyMem_MALLOC((n) * <span class="keyword">sizeof</span>(type)) ) )</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_Resize(p, type, n) \</span></span><br><span class="line">  ( (p) = ((<span class="keyword">size_t</span>)(n) &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(type)) ? <span class="literal">NULL</span> :	\</span><br><span class="line">	(type *) PyMem_Realloc((p), (n) * <span class="keyword">sizeof</span>(type)) )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyMem_RESIZE(p, type, n) \</span></span><br><span class="line">  ( (p) = ((<span class="keyword">size_t</span>)(n) &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(type)) ? <span class="literal">NULL</span> :	\</span><br><span class="line">	(type *) PyMem_REALLOC((p), (n) * <span class="keyword">sizeof</span>(type)) )</span><br></pre></td></tr></table></figure>
<p>第<code>1</code>层只是进行内存分配的工作, 然而对于内存分配还有许多额外工作, 例如: 计数引用和<code>GC</code>, 都将在第<code>2</code>层内存管理机制中. 这一层, 是一组以<code>PyObject_</code>为前缀的函数族, 主要作为Python的对象分配器, 这些函数族又被唤作<code>Pymalloc</code>机制.</p>
<p>而第<code>3</code>层, 则是对于Python中的常用对象, 例如: 整数对象, 字符串对象等, 提供了更高层次的内存管理策略, 主要就是缓冲池技术, 这一部分的具体分析我们在Python的内置对象时有讲过.</p>
<h2 id="第1层低级内存分配器"><a href="#第1层低级内存分配器" class="headerlink" title="第1层低级内存分配器"></a>第1层低级内存分配器</h2><p>先看一个简单的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">	print(x)</span><br></pre></td></tr></table></figure>
<p>在上述脚本中, Python会把从0-99的整数对象转换成字符串对象输出, 这一过程会使用大量的一次性字符串.</p>
<p>所以为了避免频繁的调用<code>malloc/free</code>, Python引入了一个”内存池机制”, 用于管理小块内存的申请和释放.</p>
<p>第<code>1</code>层锁管理的内存空间结构可以分为3个层次: <code>arean -&gt; pool -&gt; block</code>, 最小单位是<code>block</code>, 返回给用户的也是<code>block</code>.</p>
<p><img src="/images/pymemobject-2.png" alt=""></p>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>在底层, <code>block</code>是一个确定大小的内存块, Python中, 不同种类的<code>block</code>都有不同的大小, 这个内存大小称为<code>size class</code>. 所有的<code>block</code>块都是8字节对齐的.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT               8               <span class="comment">/* block对齐, must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT_SHIFT         3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALL_REQUEST_THRESHOLD 512  <span class="comment">/* block上限 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br></pre></td></tr></table></figure>
<p>同时, Python为<code>block</code>的大小设定了一个上限, 当申请的内存小于这个上限时, Python就可以使用不同的<code>block</code>满足对内存的要求; 当申请超过这个上限的时候, Python将内存申请的请求转交给第<code>1</code>层的内存分配机制, 即<code>PyMem_</code>函数族.</p>
<p>根据<code>SMALL_REQUEST_THRESHOLD</code>和<code>ALIGNMENT</code>, 可以得到不同种类的<code>block</code>的<code>size class</code>分别为: 8, 16, 32, …, 512. 每个<code>size class</code>对应一个<code>size class index</code>, 这个<code>index</code>从0开始. 所以对于小于<code>512</code>字节的内存分配, 我们可以得到如下结论:</p>
<table>
<thead>
<tr>
<th>Request in bytes</th>
<th>Size of allocated block</th>
<th>Size class idx</th>
</tr>
</thead>
<tbody>
<tr>
<td>1~8</td>
<td>8</td>
<td>0</td>
</tr>
<tr>
<td>9~16</td>
<td>16</td>
<td>1</td>
</tr>
<tr>
<td>17~24</td>
<td>24</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>505~512</td>
<td>512</td>
<td>63</td>
</tr>
</tbody>
</table>
<p>也就是说, 当我们申请内存大小为28字节的内存时, 实际上<code>PyObject_Malloc</code>会从内存池中划分一个32字节的<code>block</code>, 这个<code>block</code>将从<code>size class index</code>为3的<code>pool</code>中划出. 下面是<code>size class</code>和<code>size class index</code>之间的相互转换公式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从size class index 转换成 size class */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDEX2SIZE(I) (((uint)(I) + 1) &lt;&lt; ALIGNMENT_SHIFT)</span></span><br><span class="line"><span class="comment">/* 从size class 转换成 size class index*/</span></span><br><span class="line">size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br></pre></td></tr></table></figure>
<p>不过这里我们说的<code>block</code>并不是一个实际存在的对象, 它只是一个概念, 在Python中, 有一个实体来管理<code>block</code>, 那就是<code>pool</code>.</p>
<h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><p>一组<code>block</code>的集合称为<code>pool</code>, 换句话说, 一个<code>pool</code>管理着一堆固定大小的<code>block</code>.</p>
<p>在Python中, <code>pool</code>的大小通常是一个系统内存页, 一个<code>pool</code>的大小定义为4KB.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PAGE_SIZE        (4 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE               SYSTEM_PAGE_SIZE        <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK</span></span><br></pre></td></tr></table></figure>
<p>另外, <code>pool</code>有对应的实体存在:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span> block;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123; block *_padding;</span><br><span class="line">            uint count; &#125; ref;          <span class="comment">/* 分配到pool里的block的数量 */</span></span><br><span class="line">    block *freeblock;                   <span class="comment">/* block空闲链表的开头 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       <span class="comment">/* 指向下一个pool(双链表) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       <span class="comment">/* 指向上一个pool(双链表)　*/</span></span><br><span class="line">    uint arenaindex;                    <span class="comment">/* 自己所属的arena的索引 */</span></span><br><span class="line">    uint szidx;                         <span class="comment">/* 分配的block大小 */</span></span><br><span class="line">    uint nextoffset;                    <span class="comment">/* 到下一个block的偏移量 */</span></span><br><span class="line">    uint maxnextoffset;                 <span class="comment">/* 到能分配下一个block之前偏移 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br></pre></td></tr></table></figure>
<p>一个<code>pool</code>内分配的<code>block</code>大小是固定的, 通过<code>szidx</code>可以找到对应的<code>pool</code>.</p>
<p>假设现在有一个4KB的内存, 来看看Python是怎么将它改造成一个管理32字节<code>block</code>的<code>pool</code>, 并返回一个第一个<code>block</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c convert <span class="number">4</span>k raw memory to pool]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_OVERHEAD   _Py_SIZE_ROUND_UP(sizeof(struct pool_header), ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line">block *bp;</span><br><span class="line">poolp pool;</span><br><span class="line">...... <span class="comment">/* pool 指向一块4KB内存 */</span></span><br><span class="line">pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">pool-&gt;szidx = size;  <span class="comment">/* 设置pool的size class index */</span></span><br><span class="line">size = INDEX2SIZE(size); <span class="comment">/* 转换成size class, 比如3转化为32字节 */</span></span><br><span class="line">bp = (block *)pool + POOL_OVERHEAD; <span class="comment">/* 跳过用于pool_head的内存， 并进行地址对齐 */</span></span><br><span class="line"><span class="comment">/* 实际就是pool-&gt;nextoffset = POOL_OVERHEAD + size + size */</span></span><br><span class="line">pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>); <span class="comment">/* 到下一个block的偏移 */</span></span><br><span class="line">pool-&gt;maxnextoffset = POOL_SIZE - size; <span class="comment">/* 到能分配下一个block之前的偏移 */</span></span><br><span class="line">pool-&gt;freeblock = bp + size;  <span class="comment">/* block的空闲链表开头 */</span></span><br><span class="line">*(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>; <span class="comment">/* *freeblock为NULL */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br></pre></td></tr></table></figure>
<p>最后返回的<code>bp</code>就是从<code>pool</code>取出的第一块<code>block</code>的地址, 也就是说第一个<code>block</code>已经被分配了. 所以当前已分配的<code>block</code>数量为<code>1</code>, <code>freeblock=bp+size</code>, 下一个空闲<code>block</code>的偏移为<code>POOL_OVERHEAD + size + size</code>, 空闲链表的指向<code>bp+size</code>.</p>
<p>对于应用程序来说, 尽管<code>bp</code>后面还有将近4k的内存可用, 但是可以肯定的是申请内存的函数只会使用<code>[bp, bp+size]</code>这个区间的内存. 被改造后的4KB内存情况如下:</p>
<p><img src="/images/pymemobject-3.png" alt=""></p>
<p>现在假设, 我们需要再申请5块28字节的内存, 由于28字节对应的<code>size class index</code>为<code>3</code>, 所以实际会在刚创建的<code>pool</code>上申请5块32字节的内存.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[onmalloc.c _PyObject_Alloc]</span><br><span class="line"> <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">    ++pool-&gt;ref.count;</span><br><span class="line">    bp = pool-&gt;freeblock; <span class="comment">/* 下一个空闲block */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123; <span class="comment">/* 下一次分配还有足够的空间 */</span></span><br><span class="line">        pool-&gt;freeblock = (block*)pool + pool-&gt;nextoffset;</span><br><span class="line">        pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">        *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* pool已满, 从used_pool中移除 */</span></span><br><span class="line">    next = pool-&gt;nextpool;</span><br><span class="line">    pool = pool-&gt;prevpool;</span><br><span class="line">    next-&gt;prevpool = pool;</span><br><span class="line">    pool-&gt;nextpool = next;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到, <code>_PyObject_Alloc</code>申请<code>block</code>的过程是依赖于三个变量: </p>
<ul>
<li><code>freeblock</code>: 指向下一个空闲的<code>block</code>地址;</li>
<li><code>nextoffset</code>和<code>maxnextoffset</code>: 控制着迭代申请<code>block</code>块后, 可用<code>block</code>的偏移量. 当<code>nextoffset &gt; maxnextoffset</code>时, <code>pool</code>在分配完这一次<code>block</code>结束后就已经满了, 需要从<code>used_pools</code>中移除.</li>
</ul>
<p>继续假设, 如果我们需要返回第2个<code>block</code>的内存, 来看看Python是怎么释放<code>block</code>的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_PyObject_Free(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p); <span class="comment">/* pool_head */</span></span><br><span class="line">    <span class="keyword">if</span> (address_in_range(p, pool)) &#123; <span class="comment">/* 检查p指向的block是否属于pool  */</span></span><br><span class="line">        *(block **)p = lastfree = pool-&gt;freeblock; <span class="comment">/* [1] */</span></span><br><span class="line">        pool-&gt;freeblock = (block *)p;  <span class="comment">/* [2] */</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在释放第2块<code>block</code>的时候, 为了更充分的利用<code>pool</code>的内存空间, Python通过设置<code>freeblock</code>指针构造了一个空闲<code>block</code>的离散链表:</p>
<ul>
<li>在上面申请<code>block</code>的过程中, 我们知道申请<code>block</code>后, <code>*freeblock</code>为<code>NULL</code>;</li>
<li>经过[1]后, 先是将指针<code>freeblock</code>的指向的地址, 保存在我们要释放掉的那个<code>block</code>里;</li>
<li>经过[2]后, 更新当前<code>freeblock</code>指针, 指向我们释放掉的<code>block</code>地址.</li>
</ul>
<p>经过这两步, 这时<code>pool</code>的内存使用情况应该如下:</p>
<p><img src="/images/pymemobject-4.png" alt=""></p>
<p>既然构造了空闲<code>block</code>的离散链表, 那么在申请<code>block</code>块的时候, 应该优先尝试使用这条离散链表, 当<code>*freeblock==NULL</code>的时候, 可以知道已经不存在这条离散链表了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c _PyObject_Alloc]</span><br><span class="line"><span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">    ++pool-&gt;ref.count;</span><br><span class="line">    bp = pool-&gt;freeblock;</span><br><span class="line">    <span class="keyword">if</span> ((pool-&gt;freeblock = *(block **)bp) != <span class="literal">NULL</span>) &#123; <span class="comment">/* 优先尝试空闲block链表 */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>多个<code>pool</code>的聚合就是<code>arena</code>. <code>pool</code>的默认大小为<code>4KB</code>, 而<code>arena</code>的默认大小为<code>256KB</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_SIZE              (256 &lt;&lt; 10)     <span class="comment">/* 256KB */</span></span></span><br></pre></td></tr></table></figure>
<p>我们来看看<code>arena</code>的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> address; <span class="comment">/* malloc后的arena地址 */</span></span><br><span class="line">    block* pool_address; <span class="comment">/* 将arena的地址用于给pool使用而对齐的地址 */</span></span><br><span class="line">    uint nfreepools; <span class="comment">/* 空闲pool数量 */</span></span><br><span class="line">    uint ntotalpools; <span class="comment">/* pool总数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span>* <span class="title">freepools</span>;</span>  <span class="comment">/* 连接空闲pool的单链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nextarena</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">prevarena</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>arena_object</code>结构体中有个域<code>pool_address</code>, 它指向了<code>arena</code>内的开头<code>pool</code>地址. 这里我们说<code>arena</code>的地址和<code>arena</code>内开头的<code>pool</code>地址不同, 是因为<code>pool</code>的开头地址需要按照<code>4K</code>对齐.</p>
<p>另外还有两个域<code>nextarena</code>和<code>prevarena</code>, 这里需要注意的是, <code>arena_object</code>是被一个<code>arenas</code>数组管理的, 这就是Python通用的内存池.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenas</span> = <span class="title">NULL</span>;</span>     <span class="comment">/* arenes管理着 arena_object的集合 */</span></span><br><span class="line"><span class="keyword">static</span> uint maxarenas = <span class="number">0</span>;  <span class="comment">/* arenas中的元素数量 */</span></span><br></pre></td></tr></table></figure>
<p>既然不是链表, 那么<code>nextarena</code>和<code>prevarena</code>是做什么用的呢?</p>
<p>这得从<code>arena</code>的内存布局来讲, 我们知道<code>pool</code>在创建的时候, 意味着<code>pool</code>里的<code>block</code>也跟着分配了内存, 然而<code>arena</code>不是这样的, 当<code>arena</code>被创建时, 其内管理的<code>pool</code>可能还没有被创建.</p>
<p>所以我们将<code>arena</code>分为两种状态: “未使用”状态和”可用”状态. 当一个<code>arena_object</code>没有和<code>pool</code>集合建立联系的时候, 我们称它为”未使用”; 一旦建立联系, <code>arena</code>就变为了”可用”状态.</p>
<p>对于两种状态, 分别有两个链表管理着: <code>unused_arena_objects</code>和<code>usable_arenas</code>, 这些<code>arena_object</code>之间正是通过上面那两个指针连接.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">unused_arena_objects</span> = <span class="title">NULL</span>;</span> <span class="comment">/* 单链表 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">usable_arenas</span> = <span class="title">NULL</span>;</span> <span class="comment">/* 双链表 */</span></span><br></pre></td></tr></table></figure>
<p>下图展示了某一时刻多个<code>arena</code>可能的状态:</p>
<p><img src="/images/pymemobject-6.png" alt=""></p>
<p>接下来, 是<code>arena</code>的创建过程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>*</span></span><br><span class="line"><span class="class"><span class="title">new_arena</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span></span><br><span class="line">    uint excess;        <span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line">    <span class="keyword">void</span> *address;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> debug_stats = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123; <span class="comment">/* 判断是否需要扩充unused_arena_objects链表 */</span></span><br><span class="line">        uint i;</span><br><span class="line">        uint numarenas;</span><br><span class="line">        <span class="keyword">size_t</span> nbytes;</span><br><span class="line">        <span class="comment">/* 确定本次需要申请的arena_objects 数量, 并申请内存*/</span></span><br><span class="line">        numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line">        <span class="keyword">if</span> (numarenas &lt;= maxarenas)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;                <span class="comment">/* overflow */</span></span><br><span class="line"></span><br><span class="line">        nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">        arenaobj = (struct arena_object *)PyMem_RawRealloc(arenas, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        arenas = arenaobj;</span><br><span class="line">        <span class="comment">/* 初始化新申请的arena_object, 并放入unused_arena_objects链表和arenas数组 */</span></span><br><span class="line">        <span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;  <span class="comment">/* 注意从maxarenas开始, 不动正在使用的arenas */</span></span><br><span class="line">            arenas[i].address = <span class="number">0</span>;              <span class="comment">/* mark as unassociated */</span></span><br><span class="line">            arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ?</span><br><span class="line">                                   &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">        maxarenas = numarenas;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 从unused_arena_objects中取出一个未使用的arena_object*/</span>*/</span><br><span class="line">    arenaobj = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = arenaobj-&gt;nextarena;</span><br><span class="line">    <span class="comment">/* 申请arena_object所管理的内存 */</span></span><br><span class="line">    address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        arenaobj-&gt;nextarena = unused_arena_objects;</span><br><span class="line">        unused_arena_objects = arenaobj;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;address = (<span class="keyword">uintptr_t</span>)address;</span><br><span class="line"></span><br><span class="line">    ++narenas_currently_allocated;</span><br><span class="line">    ++ntimes_arena_allocated;</span><br><span class="line">    <span class="keyword">if</span> (narenas_currently_allocated &gt; narenas_highwater)</span><br><span class="line">        narenas_highwater = narenas_currently_allocated;</span><br><span class="line">    <span class="comment">/* 把arena内部分割成pool  */</span></span><br><span class="line">    arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line">    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">    arenaobj-&gt;nfreepools = ARENA_SIZE / POOL_SIZE;</span><br><span class="line">    <span class="comment">/* pool地址对齐 */</span></span><br><span class="line">    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line">    <span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">        --arenaobj-&gt;nfreepools;</span><br><span class="line">        arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">    &#125;</span><br><span class="line">    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arenaobj; <span class="comment">/* 返回新的arena_object */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建新的<code>arena</code>期间, Python首先会检查<code>unused_arena_objects</code>链表中是否还有”未使用”状态的<code>arena</code>.</p>
<ul>
<li>如果<code>unused_arena_objects</code>中存在未使用的<code>arena</code>, 那么直接从中取出一个<code>arena</code>, 调整<code>unused_arena_objects</code>指针, 断绝和抽取的<code>arena</code>的联系;</li>
<li>如果<code>unused_arena_objects</code>为<code>NULL</code>, 那么Python会申请单独用于存放<code>numarenas</code>个<code>arena</code>的内存空间, 这个值在第一次的时候为<code>16</code>, 以后会翻倍. 申请内存后, 每个<code>arena</code>设置地址<code>address</code>都为<code>0</code>, 并通过指针<code>nextarena</code>将它们连接起来.</li>
</ul>
<p>无论哪种情况, 在从<code>unused_arena_objects</code>中获取到一个<code>arena</code>后, 会为它所管理的<code>pool</code>集合申请一块内存, <code>address</code>域就是申请的内存地址, 而<code>pool_address</code>是对开头的<code>pool</code>经过系统页对齐的地址. 到现在为止, <code>arena</code>和<code>pool</code>建立了联系, 就等着<code>usable_arenas</code>接收了.</p>
<h2 id="第2层对象分配器"><a href="#第2层对象分配器" class="headerlink" title="第2层对象分配器"></a>第2层对象分配器</h2><p>尽管我们花了大量篇幅介绍<code>arena</code>, 然而Python申请内存时, 直接打交道的确实<code>pool</code>. 这也无可厚非, 毕竟只有通过<code>pool</code>才能找到保存固定大小的<code>block</code>块的内存.</p>
<h3 id="usedpools"><a href="#usedpools" class="headerlink" title="usedpools"></a>usedpools</h3><p>在Python中为实现高速搜索<code>pool</code>, 使用了一个全局变量<code>usedpools</code>来保持<code>pool</code>数组. 一个 <code>pool</code>在Python运行期间, 必然处于以下三种状态中的一种:</p>
<ul>
<li><code>used</code>状态: <code>pool</code>中至少有一个<code>block</code>已经被使用, 并且至少一个<code>block</code>还未被使用, 这种状态受控于<code>usedpools</code>数组;</li>
<li><code>full</code>状态: <code>pool</code>中的所有<code>block</code>都已经被使用, 这种状态的<code>pool</code>位于<code>arena</code>中, 但不在<code>arena</code>的<code>freepools</code>链表中;</li>
<li><code>empty</code>状态: 这种状态的<code>pool</code>中的所有<code>block</code>都未使用, 处于这种状态的<code>pool</code>集合, 通过<code>pool_header</code>的<code>nextpool</code>构成的链表正好形成<code>arena</code>的<code>freepools</code>;</li>
</ul>
<p>下面给出了一个<code>arena</code>中包含三种状态的<code>pool</code>集合的一个可能状态:</p>
<p><img src="/images/pymemobject-7.png" alt=""></p>
<p>注意, 处于<code>full</code>状态的<code>pool</code>是独立的, 没有和其他<code>pool</code>那样会链接成链表. 所有处于<code>used</code>状态的<code>pool</code>都被受控于<code>usedpools</code>数组. <code>usedpools</code> 与<code>size class index</code>有着密切的联系, 来看一看<code>usedpools</code>的结构:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTA(x)  ((poolp )((uint8_t *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT(x)   PTA(x), PTA(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> poolp usedpools[<span class="number">2</span> * ((NB_SMALL_SIZE_CLASSES + <span class="number">7</span>) / <span class="number">8</span>) * <span class="number">8</span>] = &#123;</span><br><span class="line">    PT(<span class="number">0</span>), PT(<span class="number">1</span>), PT(<span class="number">2</span>), PT(<span class="number">3</span>), PT(<span class="number">4</span>), PT(<span class="number">5</span>), PT(<span class="number">6</span>), PT(<span class="number">7</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">8</span></span><br><span class="line">    , PT(<span class="number">8</span>), PT(<span class="number">9</span>), PT(<span class="number">10</span>), PT(<span class="number">11</span>), PT(<span class="number">12</span>), PT(<span class="number">13</span>), PT(<span class="number">14</span>), PT(<span class="number">15</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">16</span></span><br><span class="line">    , PT(<span class="number">16</span>), PT(<span class="number">17</span>), PT(<span class="number">18</span>), PT(<span class="number">19</span>), PT(<span class="number">20</span>), PT(<span class="number">21</span>), PT(<span class="number">22</span>), PT(<span class="number">23</span>)</span><br><span class="line">......</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">56</span></span><br><span class="line">    , PT(<span class="number">56</span>), PT(<span class="number">57</span>), PT(<span class="number">58</span>), PT(<span class="number">59</span>), PT(<span class="number">60</span>), PT(<span class="number">61</span>), PT(<span class="number">62</span>), PT(<span class="number">63</span>)</span><br><span class="line">......</span><br><span class="line">#endif <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt;  8 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>usedpools</code>是一个<code>pool_header</code>的指针型数组, 将它精简过后的形式是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> poolp usedpools[<span class="number">128</span>] = &#123;</span><br><span class="line">    PT(<span class="number">0</span>), PT(<span class="number">1</span>), PT(<span class="number">2</span>), PT(<span class="number">3</span>), PT(<span class="number">4</span>), PT(<span class="number">5</span>), PT(<span class="number">6</span>), PT(<span class="number">7</span>)</span><br><span class="line">    , PT(<span class="number">8</span>), PT(<span class="number">9</span>), PT(<span class="number">10</span>), PT(<span class="number">11</span>), PT(<span class="number">12</span>), PT(<span class="number">13</span>), PT(<span class="number">14</span>), PT(<span class="number">15</span>)</span><br><span class="line">    , PT(<span class="number">16</span>), PT(<span class="number">17</span>), PT(<span class="number">18</span>), PT(<span class="number">19</span>), PT(<span class="number">20</span>), PT(<span class="number">21</span>), PT(<span class="number">22</span>), PT(<span class="number">23</span>)</span><br><span class="line">	......</span><br><span class="line">    , PT(<span class="number">56</span>), PT(<span class="number">57</span>), PT(<span class="number">58</span>), PT(<span class="number">59</span>), PT(<span class="number">60</span>), PT(<span class="number">61</span>), PT(<span class="number">62</span>), PT(<span class="number">63</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看来<code>usedpools</code>的元素数量是<code>128</code>, 但是我们申请大小的种类类型却只有<code>64</code>种. 呈倍数关系是因为采用了双向链表连接<code>pool</code>, <code>usedpools</code>的元素被两两分为一组.</p>
<p>而宏定义<code>PT(x)</code>定义了一个指针: 这个指针指向的位置是从一组的开头再往前”两个block指针型的大小”.</p>
<p>懵逼…还是不太明白, 为什么非要把问题弄这么复杂, 直接将<code>usedpools</code>作为<code>pool_header</code>数组不行吗?</p>
<p>关于这点在注释中有解释:</p>
<blockquote>
<p>It’s unclear why the usedpools setup is so convoluted. <br><br>/<em> usedpools的设置不知为何变得如此复杂 </em>/ <br><br>It could be to<br>minimize the amount of cache required to hold this heavily-referenced table<br>(which only <em>needs</em> the two interpool pointer members of a pool_header).<br><br>/<em> 这可能是最大限度地减少持有这个严重引用的表所需的缓存量（它只需要</em> pool_header的两个池间指针成员）*/</p>
</blockquote>
<p>有点懵圈, 讲了一大堆云里雾里的, 关于<code>arena</code>, <code>pool</code>和<code>block</code>也有了一个模糊的概念, 下面就具体针对两个函数<code>_PyObject_Malloc</code>和<code>_PyObject_Free</code>, 分析Python的内存分配和内存释放过程.</p>
<h3 id="PyObject-Malloc"><a href="#PyObject-Malloc" class="headerlink" title="_PyObject_Malloc"></a>_PyObject_Malloc</h3><p>Python中的对大部分对象的内存分配都是通过这个函数<code>_PyObject_Malloc</code>完成的.</p>
<p>这个函数有三个作用: “分配block”, “分配pool”和”分配arena”.</p>
<p>函数的整体流程如下(为了更好的理解, 对源码进行了整理):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_PyObject_Alloc(<span class="keyword">int</span> use_calloc, <span class="keyword">void</span> *ctx, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> elsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nbytes;</span><br><span class="line">    block *bp;</span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    _Py_AllocatedBlocks++;</span><br><span class="line"></span><br><span class="line">    nbytes = nelem * elsize;  <span class="comment">/* 计算需要申请的字节数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nelem == <span class="number">0</span> || elsize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> redirect;</span><br><span class="line">    <span class="comment">/* 申请的字节数是否小于等于512字节? */</span></span><br><span class="line">    <span class="keyword">if</span> ((nbytes - <span class="number">1</span>) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line">        LOCK(); <span class="comment">/* 线程锁 */</span></span><br><span class="line">        size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT; <span class="comment">/* 转换成索引 */</span></span><br><span class="line">        pool = usedpools[size + size]; <span class="comment">/* 从usedpools中取出pool */</span></span><br><span class="line">        <span class="comment">/* 检查pool是否连接到了指定索引的usedpool是的元素</span></span><br><span class="line"><span class="comment">        如果连接到了那么pool和pool-&gt;nextpool地址应该不同 */</span></span><br><span class="line">        <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123; <span class="comment">/* 返回pool内的block */</span></span><br><span class="line">            ++pool-&gt;ref.count; <span class="comment">/* pool内分配的block数量加一 */</span></span><br><span class="line">            bp = pool-&gt;freeblock; </span><br><span class="line">            <span class="comment">/* 尝试通过离散链表获取block(使用完毕的block) */</span></span><br><span class="line">            <span class="keyword">if</span> ((pool-&gt;freeblock = *(block **)bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                UNLOCK(); <span class="comment">/* 解锁线程 */</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)bp; <span class="comment">/* 返回block */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 通过偏移量取出block(未使用的block) */</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">                <span class="comment">/* There is room for another block. */</span></span><br><span class="line">                pool-&gt;freeblock = (block*)pool +</span><br><span class="line">                                  pool-&gt;nextoffset;</span><br><span class="line">                <span class="comment">/* 设定下一个空block的偏移量 */</span></span><br><span class="line">                pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">                *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)bp; <span class="comment">/* 返回block*/</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 该pool已满, 无法再使用, 从usedpools中移除 */</span></span><br><span class="line">            next = pool-&gt;nextpool;</span><br><span class="line">            pool = pool-&gt;prevpool;</span><br><span class="line">            next-&gt;prevpool = pool;</span><br><span class="line">            pool-&gt;nextpool = next;</span><br><span class="line">            UNLOCK();</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *)bp; <span class="comment">/* 返回block */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 没有可用的arena, 调用new_arena创建新的arenas */</span></span><br><span class="line">        <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (narenas_currently_allocated &gt;= MAX_ARENAS) &#123;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">goto</span> redirect;</span><br><span class="line">            &#125;</span><br><span class="line">            usable_arenas = new_arena(); <span class="comment">/* 分配新的一批arena_objects */</span></span><br><span class="line">            <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">goto</span> redirect;</span><br><span class="line">            &#125;</span><br><span class="line">            usable_arenas-&gt;nextarena =</span><br><span class="line">                usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从arean中取出空闲的pool */</span></span><br><span class="line">        pool = usable_arenas-&gt;freepools;</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123; <span class="comment">/* 检查是否存在空闲的pool */</span></span><br><span class="line">            usable_arenas-&gt;freepools = pool-&gt;nextpool; <span class="comment">/* 把空闲的pool从链表中取出 */</span></span><br><span class="line"></span><br><span class="line">            --usable_arenas-&gt;nfreepools; <span class="comment">/* usable_arenas可用pool数减一 */</span></span><br><span class="line">            <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;  <span class="comment">/* arena中已经没有空闲pool, 将它移除 */</span></span><br><span class="line">               </span><br><span class="line">                usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">                <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        init_pool: <span class="comment">/* 初始化并返回pool */</span></span><br><span class="line">        	<span class="comment">/* 连接usedpools的开头 */</span></span><br><span class="line">            next = usedpools[size + size]; <span class="comment">/* == prev */</span></span><br><span class="line">            pool-&gt;nextpool = next;</span><br><span class="line">            pool-&gt;prevpool = next;</span><br><span class="line">            next-&gt;nextpool = pool;</span><br><span class="line">            next-&gt;prevpool = pool;</span><br><span class="line">            pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;szidx == size) &#123;</span><br><span class="line">            	<span class="comment">/* 比较申请的大小和pool中block的固定大小*/</span></span><br><span class="line">            	<span class="comment">/* 如果相同(曾经使用过, 而且size相同), 那么就不用进行初始化也无所谓 */</span></span><br><span class="line">                bp = pool-&gt;freeblock;</span><br><span class="line">                pool-&gt;freeblock = *(block **)bp; <span class="comment">/* 设定下一个block地址 */</span></span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)bp; <span class="comment">/* 返回block */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 初始化pool */</span></span><br><span class="line">            pool-&gt;szidx = size;</span><br><span class="line">            size = INDEX2SIZE(size);</span><br><span class="line">            bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">            pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">            pool-&gt;freeblock = bp + size;</span><br><span class="line">            *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">            UNLOCK();</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *)bp; <span class="comment">/* 返回block */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 初始化空的pool */</span></span><br><span class="line">        pool = (poolp)usable_arenas-&gt;pool_address;</span><br><span class="line">        pool-&gt;arenaindex = (uint)(usable_arenas - arenas);</span><br><span class="line">        pool-&gt;szidx = DUMMY_SIZE_IDX;</span><br><span class="line">        usable_arenas-&gt;pool_address += POOL_SIZE;</span><br><span class="line">        --usable_arenas-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123; <span class="comment">/* 如果没有可用的pool了, 那么就设定下一个arena */</span></span><br><span class="line">            usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">            <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> init_pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redirect: <span class="comment">/* 调用原生的malloc分配内存 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> *result;</span><br><span class="line">        result = PyMem_RawMalloc(nbytes);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_PyObject_Malloc(<span class="keyword">size_t</span> nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 是否小于等于512字节? */</span></span><br><span class="line">    <span class="keyword">if</span> ((nbytes - <span class="number">1</span>) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line">    	<span class="comment">/* (A)从usedpools中取出pool */</span></span><br><span class="line">        <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">           <span class="comment">/* (B)返回pool内的block */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 是否存在可以使用的arena? */</span></span><br><span class="line">        <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* (C)调用new_arena */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 从arena中取出使用空闲的pool */</span></span><br><span class="line">        pool = usable_arenas-&gt;freepools;</span><br><span class="line">        <span class="comment">/* 是否存在空闲的pool */</span></span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        	<span class="comment">/* (D)初始化空闲的pool */</span>    </span><br><span class="line"></span><br><span class="line">        	<span class="comment">/* (E)初始化pool并返回block */</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  redirect:</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">/* 当大于256字节时, 使用原生的malloc申请内存 */</span></span><br><span class="line">        <span class="keyword">void</span> *result;</span><br><span class="line">        result = PyMem_RawMalloc(nbytes);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PyObject-Free"><a href="#PyObject-Free" class="headerlink" title="_PyObject_Free"></a>_PyObject_Free</h3><p>和分配内存对应, <code>_PyObject_Free</code>释放用<code>_PyObject_Malloc</code>分配的内存. 这个函数主要三个作用: “释放block”, “释放pool”和”释放arena”.</p>
<p>下面是整理过的源码和注释:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_PyObject_Free(<span class="keyword">void</span> *ctx, <span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    poolp pool;</span><br><span class="line">    block *lastfree;</span><br><span class="line">    poolp next, prev;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)      <span class="comment">/* 为NULL时, 不执行任何动作 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    _Py_AllocatedBlocks--;</span><br><span class="line"></span><br><span class="line">    pool = POOL_ADDR(p); <span class="comment">/* 从作为释放对象的地址取出所属的pool */</span></span><br><span class="line">    <span class="keyword">if</span> (address_in_range(p, pool)) &#123; <span class="comment">/* 检查获得的pool是否正确 */</span></span><br><span class="line">        LOCK(); <span class="comment">/* 线程锁 */</span></span><br><span class="line">      </span><br><span class="line">        *(block **)p = lastfree = pool-&gt;freeblock; <span class="comment">/* 构建使用完毕的block的离散链表 */</span></span><br><span class="line">        pool-&gt;freeblock = (block *)p;  <span class="comment">/* 将block设置为freeblock头 */</span></span><br><span class="line">        <span class="keyword">if</span> (lastfree) &#123; <span class="comment">/* 这个pool的最后free的block是否为NULL */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">ao</span>;</span></span><br><span class="line">            uint nf;  <span class="comment">/* ao-&gt;nfreepools */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--pool-&gt;ref.count != <span class="number">0</span>) &#123; <span class="comment">/* pool正在使用used, 不执行任何操作 */</span></span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	</span><br><span class="line">            <span class="comment">/* pool变成empty状态, 从usedpools中移除 */</span></span><br><span class="line">            <span class="comment">/* prev &lt;-&gt; pool &lt;-&gt; next */</span></span><br><span class="line">            <span class="comment">/* prev &lt;-&gt; next */</span></span><br><span class="line">            next = pool-&gt;nextpool;</span><br><span class="line">            prev = pool-&gt;prevpool;</span><br><span class="line">            next-&gt;prevpool = prev;</span><br><span class="line">            prev-&gt;nextpool = next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将pool返回到arena的freepools */</span></span><br><span class="line">            ao = &amp;arenas[pool-&gt;arenaindex];</span><br><span class="line">            pool-&gt;nextpool = ao-&gt;freepools;</span><br><span class="line">            ao-&gt;freepools = pool;</span><br><span class="line">            nf = ++ao-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* 释放arena */</span></span><br><span class="line">            <span class="keyword">if</span> (nf == ao-&gt;ntotalpools) &#123; <span class="comment">/* 当arena内全是空的pool, 就将其释放掉 */</span></span><br><span class="line">            	<span class="comment">/* 从usable_arenas中移除 */</span></span><br><span class="line">                <span class="keyword">if</span> (ao-&gt;prevarena == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    usable_arenas = ao-&gt;nextarena;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ao-&gt;prevarena-&gt;nextarena =</span><br><span class="line">                        ao-&gt;nextarena;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ao-&gt;nextarena != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    ao-&gt;nextarena-&gt;prevarena =</span><br><span class="line">                        ao-&gt;prevarena;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 为了再次利用arena, 将其连接到unused_arena_objects */</span></span><br><span class="line">                ao-&gt;nextarena = unused_arena_objects;</span><br><span class="line">                unused_arena_objects = ao;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 释放掉arena维护的那块内存 */</span></span><br><span class="line">                _PyObject_Arena.<span class="built_in">free</span>(_PyObject_Arena.ctx,</span><br><span class="line">                                     (<span class="keyword">void</span> *)ao-&gt;address, ARENA_SIZE);</span><br><span class="line">                ao-&gt;address = <span class="number">0</span>;                        <span class="comment">/* mark unassociated */</span></span><br><span class="line">                --narenas_currently_allocated;</span><br><span class="line"></span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nf == <span class="number">1</span>) &#123; <span class="comment">/* arena中只有一个空的pool */</span></span><br><span class="line">            	<span class="comment">/* 这里只有一个空的pool, 意味着在这次释放pool之前, 所有pool都在使用 */</span></span><br><span class="line">                <span class="comment">/* 本来没有连接到usable_arenas中, 现在需要连接到usable_arenas头 */</span></span><br><span class="line">                ao-&gt;nextarena = usable_arenas;</span><br><span class="line">                ao-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (usable_arenas)</span><br><span class="line">                    usable_arenas-&gt;prevarena = ao;</span><br><span class="line">                usable_arenas = ao;</span><br><span class="line"></span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ao-&gt;nextarena == <span class="literal">NULL</span> || nf &lt;= ao-&gt;nextarena-&gt;nfreepools) &#123;</span><br><span class="line">                <span class="comment">/* 如果arena是最后一个arena, 或者这个arena_object中空闲的pool数量小于下一个 */</span></span><br><span class="line">                <span class="comment">/* 那么不执行任何操作 */</span></span><br><span class="line">                UNLOCK();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         	<span class="comment">/* 如果不是上面两种情况, 则需要对arena按从小到大排序 */</span></span><br><span class="line">         	<span class="comment">/* 首先我们将这个arena从usable_arenas中拿出来 */</span></span><br><span class="line">            <span class="keyword">if</span> (ao-&gt;prevarena != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ao-&gt;prevarena-&gt;nextarena = ao-&gt;nextarena;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                usable_arenas = ao-&gt;nextarena;</span><br><span class="line">            &#125;</span><br><span class="line">            ao-&gt;nextarena-&gt;prevarena = ao-&gt;prevarena;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 然后从usable_arenas中找到合适位置插入arena_object */</span></span><br><span class="line">            <span class="keyword">while</span> (ao-&gt;nextarena != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                            nf &gt; ao-&gt;nextarena-&gt;nfreepools) &#123;</span><br><span class="line">                ao-&gt;prevarena = ao-&gt;nextarena;</span><br><span class="line">                ao-&gt;nextarena = ao-&gt;nextarena-&gt;nextarena;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ao-&gt;prevarena-&gt;nextarena = ao;</span><br><span class="line">            <span class="keyword">if</span> (ao-&gt;nextarena != <span class="literal">NULL</span>)</span><br><span class="line">                ao-&gt;nextarena-&gt;prevarena = ao;</span><br><span class="line"></span><br><span class="line">            UNLOCK();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* lastfree为NULL意味着这个pool内的所有block都已经分配完毕 */</span></span><br><span class="line">        <span class="comment">/* 需要从usedpools中取出这个大小类型的pool, 并将这个pool连接到usedpools开头 */</span></span><br><span class="line">        --pool-&gt;ref.count;</span><br><span class="line">        size = pool-&gt;szidx;</span><br><span class="line">        next = usedpools[size + size];</span><br><span class="line">        prev = next-&gt;prevpool;</span><br><span class="line">        pool-&gt;nextpool = next;</span><br><span class="line">        pool-&gt;prevpool = prev;</span><br><span class="line">        next-&gt;prevpool = pool;</span><br><span class="line">        prev-&gt;nextpool = pool;</span><br><span class="line">        UNLOCK();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">redirect:</span><br><span class="line">    <span class="comment">/* 释放其他空间 */</span></span><br><span class="line">    PyMem_RawFree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第3层特殊对象缓冲机制"><a href="#第3层特殊对象缓冲机制" class="headerlink" title="第3层特殊对象缓冲机制"></a>第3层特殊对象缓冲机制</h2><p>这一部分, 我们在前面的Python内置对象讲过, 针对一些常用的类型, Python提供了一系列的缓冲池技术.</p>
<!-- 当申请一个32字节的`pool`时, 需要将这个`pool`放入`usedpools`. 先得到它的`size class index`, 也就是3. 然后进行`usedpools[3+3]->nextpool = pool`即可.  -->
<!-- 

`PyObject_Malloc`中利用了这个技巧来判断某个`class size index`对应的`pool`是否存在于`usedpools`中.


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_PyObject_Alloc(<span class="keyword">int</span> use_calloc, <span class="keyword">void</span> *ctx, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> elsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nbytes;</span><br><span class="line">    block *bp;</span><br><span class="line">    poolp pool;</span><br><span class="line">    poolp next;</span><br><span class="line">    uint size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((nbytes - <span class="number">1</span>) &lt; SMALL_REQUEST_THRESHOLD) &#123;</span><br><span class="line">        LOCK();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获得size class index */</span></span><br><span class="line">        size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">        pool = usedpools[size + size];</span><br><span class="line">        <span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123; <span class="comment">/* usedpools是否有可用的pool */</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">  	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建pool"><a href="#创建pool" class="headerlink" title="创建pool"></a>创建pool</h3><p>当Python启动的时候, <code>usedpools</code>这个内存池中并没有可用内存, 当我们开始申请小块内存的时候, Python才开始建立这个内存池. 假设我们申请<code>32</code>字节的内存, Python首先得到对应的<code>class size index=3</code>,  在<code>usedpools</code>对应的位置查找, 发现没有任何可用的<code>pool</code>, Python才会从<code>useable_arenas</code>链表中第一个可用的<code>arena</code>获得一个可用的<code>pool</code>. 考虑到, 这个<code>pool</code>将是用于分配<code>32</code>字节<code>block</code>的, 因此在此它需要被重新划分.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[obmalloc.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * _PyObject_Alloc(<span class="keyword">int</span> use_calloc, <span class="keyword">void</span> *ctx, <span class="keyword">size_t</span> nelem, <span class="keyword">size_t</span> elsize)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">  init_pool:  <span class="comment">/* 初始化pool */</span></span><br><span class="line">    <span class="comment">// 将pool放入usedpools中</span></span><br><span class="line">    next = usedpools[size + size];</span><br><span class="line">    pool-&gt;nextpool = next;</span><br><span class="line">    pool-&gt;prevpool = next;</span><br><span class="line">    next-&gt;nextpool = pool;</span><br><span class="line">    next-&gt;prevpool = pool;</span><br><span class="line">    pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// pool在之前就具有正确的size结构, 直接返回pool中的一个block</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;szidx == size) &#123;</span><br><span class="line">        bp = pool-&gt;freeblock;</span><br><span class="line">        assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">        pool-&gt;freeblock = *(block **)bp;</span><br><span class="line">        UNLOCK();</span><br><span class="line">        <span class="keyword">if</span> (use_calloc)</span><br><span class="line">            <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化pool_header, 将freeblock指向第二个block, 返回第一个block</span></span><br><span class="line">    pool-&gt;szidx = size;</span><br><span class="line">    size = INDEX2SIZE(size);</span><br><span class="line">    bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">    pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">    pool-&gt;freeblock = bp + size;</span><br><span class="line">    *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">    UNLOCK();</span><br><span class="line">    <span class="keyword">if</span> (use_calloc)</span><br><span class="line">        <span class="built_in">memset</span>(bp, <span class="number">0</span>, nbytes);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python将得到的pool放入了usedpools中. 那么在什么情况下pool从empty转为used状态呢? 假设申请的内存为size class index 为 i. 字儿usedpools[i + i] 处没有处于used状态的pool. 同时全局变量freepools中海油处于empty的pool, 那么位于freepool维护的链表中头部pool将被取出来, 放入usedpools中, 这时, 这个pool也就从empry状态转为used状态.</p>
<p><code>`</code>c<br>[obmalloc.c _PyObject_Alloc]<br>pool = usable_arenas-&gt;freepools;<br>if (pool != NULL) {<br>    usable_arenas-&gt;freepools = pool-&gt;nextpool;<br>    …// 调整usable_arenas-&gt;nfreepools和usable_arenas自身</p>
<p>init_pool:<br>    …<br>}<br><code>`</code> –&gt;</p>
-->
    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持作者</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/posts/8c8f8f97/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/posts/73bb8543/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

  <div id="gitment-comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    (function () {
      var gitment = new Gitment({
        owner: 'zhongshangwu',
        repo: 'https://github.com/zhongshangwu/zhongshangwu.github.io',
        oauth: {
          client_id: 'ecb8413d71a24ae7e38a',
          client_secret: '6aacbb72400e02734e754fce4b6204ae07ec9dc2'
        },
        
        
        
        
        
        
        
        
      })
      gitment.render('gitment-comments')
    })()
  </script>



    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
