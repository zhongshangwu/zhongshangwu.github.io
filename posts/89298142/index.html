<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Python源码阅读-内存管理机制 | Shawn&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Python,源码," />
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/atom-one-light.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>

  <meta name="description" content="终于来到了最后一部分: 内存管理.">
<meta name="keywords" content="Python,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Python源码阅读-内存管理机制">
<meta property="og:url" content="http://shawnz.me/posts/89298142/index.html">
<meta property="og:site_name" content="Shawn&#39;s Blog">
<meta property="og:description" content="终于来到了最后一部分: 内存管理.">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-1.jpg">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-2.png">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-3.png">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-4.png">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-6.png">
<meta property="og:image" content="http://shawnz.me/images/pymemobject-7.png">
<meta property="og:updated_time" content="2018-03-10T06:20:54.150Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python源码阅读-内存管理机制">
<meta name="twitter:description" content="终于来到了最后一部分: 内存管理.">
<meta name="twitter:image" content="http://shawnz.me/images/pymemobject-1.jpg">

  

  
    <link rel="icon" href="/favicon.png">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/custom.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存架构"><span class="toc-text">内存架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第1层低级内存分配器"><span class="toc-text">第1层低级内存分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#block"><span class="toc-text">block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pool"><span class="toc-text">pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arena"><span class="toc-text">arena</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第2层对象分配器"><span class="toc-text">第2层对象分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usedpools"><span class="toc-text">usedpools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyObject-Malloc"><span class="toc-text">_PyObject_Malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PyObject-Free"><span class="toc-text">_PyObject_Free</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第3层特殊对象缓冲机制"><span class="toc-text">第3层特殊对象缓冲机制</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Python源码阅读-内存管理机制" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Python源码阅读-内存管理机制</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.01.11</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Shawn Zhong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>终于来到了最后一部分: 内存管理.</p>
<a id="more"></a>
<h2 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h2><p>在Python中, 当要分配内存时, 不单纯要用<code>malloc/free</code>, 而是在其基础上堆放三个独立的分层, 有效地进行分配.</p>
<div style="width: 70%"><img src="/images/pymemobject-1.jpg" alt=""></div>

<p>第<code>0</code>层往下是<code>OS</code>的功能, 我们要讲的内存管理不涉及这一部分.</p>
<p>第<code>0</code>层是操作系统的内存管理接口, 比如<code>C</code>运行时提供的<code>mallocl</code>和<code>free</code>接口, Python并不干涉这一层的行为.</p>
<p>第<code>1</code>层是基于第<code>0</code>层操作系统的内存管接口包装而成的, 这一层主要是为Python提供统一的<code>raw memory</code>管理接口, 处理平台相关的内存分配. 在Python中, 第<code>1</code>的实现是一组<code>PyMem_</code>为前缀的函数族.</p>
<pre><code class="c">[obmalloc.c]
/* 函数接口 */
static void * 
_PyMem_RawMalloc(void *ctx, size_t size)
{
    if (size == 0)
        size = 1;
    return malloc(size);
}
......
static void *
_PyMem_RawRealloc(void *ctx, void *ptr, size_t size)
{
    if (size == 0)
        size = 1;
    return realloc(ptr, size);
}
static void
_PyMem_RawFree(void *ctx, void *ptr) { free(ptr); }

/* 宏定义 */
[pymem.h]
#define PyMem_MALLOC(n)         PyMem_Malloc(n)
#define PyMem_REALLOC(p, n)     PyMem_Realloc(p, n)
#define PyMem_FREE(p)           PyMem_Free(p)
</code></pre>
<p>可以看到Python只是对C中<code>malloc/realloc/free</code>等进行了一次包装. 不过由于不同操作系统针对<code>malloc(0)</code>表现不同, 有的会返回<code>NULL</code>, 有的会返回一个没有指向内存的空指针, 所以Python不允许申请大小为<code>0</code>的内存空间, 将会强制转换成申请大小为<code>1</code>字节的内存空间.</p>
<p>Python同时提供了函数和宏两套接口, 使用宏可以提高运行效率, 不过在编写<code>C</code>扩展模块的时候, 建议使用函数接口.</p>
<p>其实在第<code>1</code>层, Python还提供了面向Python中类型的内存分配接口:</p>
<pre><code class="c">#define PyMem_New(type, n) \
  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :    \
    ( (type *) PyMem_Malloc((n) * sizeof(type)) ) )
#define PyMem_NEW(type, n) \
  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :    \
    ( (type *) PyMem_MALLOC((n) * sizeof(type)) ) )

#define PyMem_Resize(p, type, n) \
  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :    \
    (type *) PyMem_Realloc((p), (n) * sizeof(type)) )
#define PyMem_RESIZE(p, type, n) \
  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :    \
    (type *) PyMem_REALLOC((p), (n) * sizeof(type)) )
</code></pre>
<p>第<code>1</code>层只是进行内存分配的工作, 然而对于内存分配还有许多额外工作, 例如: 计数引用和<code>GC</code>, 都将在第<code>2</code>层内存管理机制中. 这一层, 是一组以<code>PyObject_</code>为前缀的函数族, 主要作为Python的对象分配器, 这些函数族又被唤作<code>Pymalloc</code>机制.</p>
<p>而第<code>3</code>层, 则是对于Python中的常用对象, 例如: 整数对象, 字符串对象等, 提供了更高层次的内存管理策略, 主要就是缓冲池技术, 这一部分的具体分析我们在Python的内置对象时有讲过.</p>
<h2 id="第1层低级内存分配器"><a href="#第1层低级内存分配器" class="headerlink" title="第1层低级内存分配器"></a>第1层低级内存分配器</h2><p>先看一个简单的例子:</p>
<pre><code class="python">for x in range(100):
    print(x)
</code></pre>
<p>在上述脚本中, Python会把从0-99的整数对象转换成字符串对象输出, 这一过程会使用大量的一次性字符串.</p>
<p>所以为了避免频繁的调用<code>malloc/free</code>, Python引入了一个”内存池机制”, 用于管理小块内存的申请和释放.</p>
<p>第<code>1</code>层锁管理的内存空间结构可以分为3个层次: <code>arean -&gt; pool -&gt; block</code>, 最小单位是<code>block</code>, 返回给用户的也是<code>block</code>.</p>
<p><img src="/images/pymemobject-2.png" alt=""></p>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>在底层, <code>block</code>是一个确定大小的内存块, Python中, 不同种类的<code>block</code>都有不同的大小, 这个内存大小称为<code>size class</code>. 所有的<code>block</code>块都是8字节对齐的.</p>
<pre><code class="c">#define ALIGNMENT               8               /* block对齐, must be 2^N */
#define ALIGNMENT_SHIFT         3

#define SMALL_REQUEST_THRESHOLD 512  /* block上限 */
#define NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)
</code></pre>
<p>同时, Python为<code>block</code>的大小设定了一个上限, 当申请的内存小于这个上限时, Python就可以使用不同的<code>block</code>满足对内存的要求; 当申请超过这个上限的时候, Python将内存申请的请求转交给第<code>1</code>层的内存分配机制, 即<code>PyMem_</code>函数族.</p>
<p>根据<code>SMALL_REQUEST_THRESHOLD</code>和<code>ALIGNMENT</code>, 可以得到不同种类的<code>block</code>的<code>size class</code>分别为: 8, 16, 32, …, 512. 每个<code>size class</code>对应一个<code>size class index</code>, 这个<code>index</code>从0开始. 所以对于小于<code>512</code>字节的内存分配, 我们可以得到如下结论:</p>
<table>
<thead>
<tr>
<th>Request in bytes</th>
<th>Size of allocated block</th>
<th>Size class idx</th>
</tr>
</thead>
<tbody>
<tr>
<td>1~8</td>
<td>8</td>
<td>0</td>
</tr>
<tr>
<td>9~16</td>
<td>16</td>
<td>1</td>
</tr>
<tr>
<td>17~24</td>
<td>24</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>505~512</td>
<td>512</td>
<td>63</td>
</tr>
</tbody>
</table>
<p>也就是说, 当我们申请内存大小为28字节的内存时, 实际上<code>PyObject_Malloc</code>会从内存池中划分一个32字节的<code>block</code>, 这个<code>block</code>将从<code>size class index</code>为3的<code>pool</code>中划出. 下面是<code>size class</code>和<code>size class index</code>之间的相互转换公式:</p>
<pre><code class="c">/* 从size class index 转换成 size class */
#define INDEX2SIZE(I) (((uint)(I) + 1) &lt;&lt; ALIGNMENT_SHIFT)
/* 从size class 转换成 size class index*/
size = (uint)(nbytes - 1) &gt;&gt; ALIGNMENT_SHIFT;
</code></pre>
<p>不过这里我们说的<code>block</code>并不是一个实际存在的对象, 它只是一个概念, 在Python中, 有一个实体来管理<code>block</code>, 那就是<code>pool</code>.</p>
<h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><p>一组<code>block</code>的集合称为<code>pool</code>, 换句话说, 一个<code>pool</code>管理着一堆固定大小的<code>block</code>.</p>
<p>在Python中, <code>pool</code>的大小通常是一个系统内存页, 一个<code>pool</code>的大小定义为4KB.</p>
<pre><code class="c">#define SYSTEM_PAGE_SIZE        (4 * 1024)
#define SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)

#define POOL_SIZE               SYSTEM_PAGE_SIZE        /* must be 2^N */
#define POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK
</code></pre>
<p>另外, <code>pool</code>有对应的实体存在:</p>
<pre><code class="c">typedef uint8_t block;

/* Pool for small blocks. */
struct pool_header {
    union { block *_padding;
            uint count; } ref;          /* 分配到pool里的block的数量 */
    block *freeblock;                   /* block空闲链表的开头 */
    struct pool_header *nextpool;       /* 指向下一个pool(双链表) */
    struct pool_header *prevpool;       /* 指向上一个pool(双链表)　*/
    uint arenaindex;                    /* 自己所属的arena的索引 */
    uint szidx;                         /* 分配的block大小 */
    uint nextoffset;                    /* 到下一个block的偏移量 */
    uint maxnextoffset;                 /* 到能分配下一个block之前偏移 */
};

typedef struct pool_header *poolp;
</code></pre>
<p>一个<code>pool</code>内分配的<code>block</code>大小是固定的, 通过<code>szidx</code>可以找到对应的<code>pool</code>.</p>
<p>假设现在有一个4KB的内存, 来看看Python是怎么将它改造成一个管理32字节<code>block</code>的<code>pool</code>, 并返回一个第一个<code>block</code>:</p>
<pre><code class="c">[obmalloc.c convert 4k raw memory to pool]
typedef struct pool_header *poolp;
#define POOL_OVERHEAD   _Py_SIZE_ROUND_UP(sizeof(struct pool_header), ALIGNMENT)

block *bp;
poolp pool;
...... /* pool 指向一块4KB内存 */
pool-&gt;ref.count = 1;
pool-&gt;szidx = size;  /* 设置pool的size class index */
size = INDEX2SIZE(size); /* 转换成size class, 比如3转化为32字节 */
bp = (block *)pool + POOL_OVERHEAD; /* 跳过用于pool_head的内存， 并进行地址对齐 */
/* 实际就是pool-&gt;nextoffset = POOL_OVERHEAD + size + size */
pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; 1); /* 到下一个block的偏移 */
pool-&gt;maxnextoffset = POOL_SIZE - size; /* 到能分配下一个block之前的偏移 */
pool-&gt;freeblock = bp + size;  /* block的空闲链表开头 */
*(block **)(pool-&gt;freeblock) = NULL; /* *freeblock为NULL */
return (void *)bp;
</code></pre>
<p>最后返回的<code>bp</code>就是从<code>pool</code>取出的第一块<code>block</code>的地址, 也就是说第一个<code>block</code>已经被分配了. 所以当前已分配的<code>block</code>数量为<code>1</code>, <code>freeblock=bp+size</code>, 下一个空闲<code>block</code>的偏移为<code>POOL_OVERHEAD + size + size</code>, 空闲链表的指向<code>bp+size</code>.</p>
<p>对于应用程序来说, 尽管<code>bp</code>后面还有将近4k的内存可用, 但是可以肯定的是申请内存的函数只会使用<code>[bp, bp+size]</code>这个区间的内存. 被改造后的4KB内存情况如下:</p>
<p><img src="/images/pymemobject-3.png" alt=""></p>
<p>现在假设, 我们需要再申请5块28字节的内存, 由于28字节对应的<code>size class index</code>为<code>3</code>, 所以实际会在刚创建的<code>pool</code>上申请5块32字节的内存.</p>
<pre><code class="c">[onmalloc.c _PyObject_Alloc]
 if (pool != pool-&gt;nextpool) {
    ++pool-&gt;ref.count;
    bp = pool-&gt;freeblock; /* 下一个空闲block */
    ......
    if (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) { /* 下一次分配还有足够的空间 */
        pool-&gt;freeblock = (block*)pool + pool-&gt;nextoffset;
        pool-&gt;nextoffset += INDEX2SIZE(size);
        *(block **)(pool-&gt;freeblock) = NULL;
        return (void *)bp;
    }
    /* pool已满, 从used_pool中移除 */
    next = pool-&gt;nextpool;
    pool = pool-&gt;prevpool;
    next-&gt;prevpool = pool;
    pool-&gt;nextpool = next;
    return (void *)bp;
}
</code></pre>
<p>可以看到, <code>_PyObject_Alloc</code>申请<code>block</code>的过程是依赖于三个变量: </p>
<ul>
<li><code>freeblock</code>: 指向下一个空闲的<code>block</code>地址;</li>
<li><code>nextoffset</code>和<code>maxnextoffset</code>: 控制着迭代申请<code>block</code>块后, 可用<code>block</code>的偏移量. 当<code>nextoffset &gt; maxnextoffset</code>时, <code>pool</code>在分配完这一次<code>block</code>结束后就已经满了, 需要从<code>used_pools</code>中移除.</li>
</ul>
<p>继续假设, 如果我们需要返回第2个<code>block</code>的内存, 来看看Python是怎么释放<code>block</code>的:</p>
<pre><code class="c">static void
_PyObject_Free(void *ctx, void *p)
{
    poolp pool;
    block *lastfree;
    poolp next, prev;
    uint size;

    pool = POOL_ADDR(p); /* pool_head */
    if (address_in_range(p, pool)) { /* 检查p指向的block是否属于pool  */
        *(block **)p = lastfree = pool-&gt;freeblock; /* [1] */
        pool-&gt;freeblock = (block *)p;  /* [2] */
        ......
    }
}
</code></pre>
<p>在释放第2块<code>block</code>的时候, 为了更充分的利用<code>pool</code>的内存空间, Python通过设置<code>freeblock</code>指针构造了一个空闲<code>block</code>的离散链表:</p>
<ul>
<li>在上面申请<code>block</code>的过程中, 我们知道申请<code>block</code>后, <code>*freeblock</code>为<code>NULL</code>;</li>
<li>经过[1]后, 先是将指针<code>freeblock</code>的指向的地址, 保存在我们要释放掉的那个<code>block</code>里;</li>
<li>经过[2]后, 更新当前<code>freeblock</code>指针, 指向我们释放掉的<code>block</code>地址.</li>
</ul>
<p>经过这两步, 这时<code>pool</code>的内存使用情况应该如下:</p>
<p><img src="/images/pymemobject-4.png" alt=""></p>
<p>既然构造了空闲<code>block</code>的离散链表, 那么在申请<code>block</code>块的时候, 应该优先尝试使用这条离散链表, 当<code>*freeblock==NULL</code>的时候, 可以知道已经不存在这条离散链表了:</p>
<pre><code class="c">[obmalloc.c _PyObject_Alloc]
if (pool != pool-&gt;nextpool) {
    ++pool-&gt;ref.count;
    bp = pool-&gt;freeblock;
    if ((pool-&gt;freeblock = *(block **)bp) != NULL) { /* 优先尝试空闲block链表 */
        return (void *)bp;
    }
    if (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) {
        ......
    }
}    
</code></pre>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>多个<code>pool</code>的聚合就是<code>arena</code>. <code>pool</code>的默认大小为<code>4KB</code>, 而<code>arena</code>的默认大小为<code>256KB</code>:</p>
<pre><code class="c">[obmalloc.c]
#define ARENA_SIZE              (256 &lt;&lt; 10)     /* 256KB */
</code></pre>
<p>我们来看看<code>arena</code>的定义:</p>
<pre><code class="c">[obmalloc.c]
struct arena_object {
    uintptr_t address; /* malloc后的arena地址 */
    block* pool_address; /* 将arena的地址用于给pool使用而对齐的地址 */
    uint nfreepools; /* 空闲pool数量 */
    uint ntotalpools; /* pool总数 */

    struct pool_header* freepools;  /* 连接空闲pool的单链表 */
    struct arena_object* nextarena; 
    struct arena_object* prevarena;
};
</code></pre>
<p><code>arena_object</code>结构体中有个域<code>pool_address</code>, 它指向了<code>arena</code>内的开头<code>pool</code>地址. 这里我们说<code>arena</code>的地址和<code>arena</code>内开头的<code>pool</code>地址不同, 是因为<code>pool</code>的开头地址需要按照<code>4K</code>对齐.</p>
<p>另外还有两个域<code>nextarena</code>和<code>prevarena</code>, 这里需要注意的是, <code>arena_object</code>是被一个<code>arenas</code>数组管理的, 这就是Python通用的内存池.</p>
<pre><code class="c">[obmalloc.c]
static struct arena_object* arenas = NULL;     /* arenes管理着 arena_object的集合 */
static uint maxarenas = 0;  /* arenas中的元素数量 */
</code></pre>
<p>既然不是链表, 那么<code>nextarena</code>和<code>prevarena</code>是做什么用的呢?</p>
<p>这得从<code>arena</code>的内存布局来讲, 我们知道<code>pool</code>在创建的时候, 意味着<code>pool</code>里的<code>block</code>也跟着分配了内存, 然而<code>arena</code>不是这样的, 当<code>arena</code>被创建时, 其内管理的<code>pool</code>可能还没有被创建.</p>
<p>所以我们将<code>arena</code>分为两种状态: “未使用”状态和”可用”状态. 当一个<code>arena_object</code>没有和<code>pool</code>集合建立联系的时候, 我们称它为”未使用”; 一旦建立联系, <code>arena</code>就变为了”可用”状态.</p>
<p>对于两种状态, 分别有两个链表管理着: <code>unused_arena_objects</code>和<code>usable_arenas</code>, 这些<code>arena_object</code>之间正是通过上面那两个指针连接.</p>
<pre><code class="c">static struct arena_object* unused_arena_objects = NULL; /* 单链表 */
static struct arena_object* usable_arenas = NULL; /* 双链表 */
</code></pre>
<p>下图展示了某一时刻多个<code>arena</code>可能的状态:</p>
<p><img src="/images/pymemobject-6.png" alt=""></p>
<p>接下来, 是<code>arena</code>的创建过程:</p>
<pre><code class="c">static struct arena_object*
new_arena(void)
{
    struct arena_object* arenaobj;
    uint excess;        /* number of bytes above pool alignment */
    void *address;
    static int debug_stats = -1;

    if (unused_arena_objects == NULL) { /* 判断是否需要扩充unused_arena_objects链表 */
        uint i;
        uint numarenas;
        size_t nbytes;
        /* 确定本次需要申请的arena_objects 数量, 并申请内存*/
        numarenas = maxarenas ? maxarenas &lt;&lt; 1 : INITIAL_ARENA_OBJECTS;
        if (numarenas &lt;= maxarenas)
            return NULL;                /* overflow */

        nbytes = numarenas * sizeof(*arenas);
        arenaobj = (struct arena_object *)PyMem_RawRealloc(arenas, nbytes);
        if (arenaobj == NULL)
            return NULL;
        arenas = arenaobj;
        /* 初始化新申请的arena_object, 并放入unused_arena_objects链表和arenas数组 */
        for (i = maxarenas; i &lt; numarenas; ++i) {  /* 注意从maxarenas开始, 不动正在使用的arenas */
            arenas[i].address = 0;              /* mark as unassociated */
            arenas[i].nextarena = i &lt; numarenas - 1 ?
                                   &amp;arenas[i+1] : NULL;
        }

        unused_arena_objects = &amp;arenas[maxarenas];
        maxarenas = numarenas;
    }
    /* 从unused_arena_objects中取出一个未使用的arena_object*/*/
    arenaobj = unused_arena_objects;
    unused_arena_objects = arenaobj-&gt;nextarena;
    /* 申请arena_object所管理的内存 */
    address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);
    if (address == NULL) {
        arenaobj-&gt;nextarena = unused_arena_objects;
        unused_arena_objects = arenaobj;
        return NULL;
    }
    arenaobj-&gt;address = (uintptr_t)address;

    ++narenas_currently_allocated;
    ++ntimes_arena_allocated;
    if (narenas_currently_allocated &gt; narenas_highwater)
        narenas_highwater = narenas_currently_allocated;
    /* 把arena内部分割成pool  */
    arenaobj-&gt;freepools = NULL;
    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;
    arenaobj-&gt;nfreepools = ARENA_SIZE / POOL_SIZE;
    /* pool地址对齐 */
    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);
    if (excess != 0) {
        --arenaobj-&gt;nfreepools;
        arenaobj-&gt;pool_address += POOL_SIZE - excess;
    }
    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;

    return arenaobj; /* 返回新的arena_object */
}
</code></pre>
<p>在创建新的<code>arena</code>期间, Python首先会检查<code>unused_arena_objects</code>链表中是否还有”未使用”状态的<code>arena</code>.</p>
<ul>
<li>如果<code>unused_arena_objects</code>中存在未使用的<code>arena</code>, 那么直接从中取出一个<code>arena</code>, 调整<code>unused_arena_objects</code>指针, 断绝和抽取的<code>arena</code>的联系;</li>
<li>如果<code>unused_arena_objects</code>为<code>NULL</code>, 那么Python会申请单独用于存放<code>numarenas</code>个<code>arena</code>的内存空间, 这个值在第一次的时候为<code>16</code>, 以后会翻倍. 申请内存后, 每个<code>arena</code>设置地址<code>address</code>都为<code>0</code>, 并通过指针<code>nextarena</code>将它们连接起来.</li>
</ul>
<p>无论哪种情况, 在从<code>unused_arena_objects</code>中获取到一个<code>arena</code>后, 会为它所管理的<code>pool</code>集合申请一块内存, <code>address</code>域就是申请的内存地址, 而<code>pool_address</code>是对开头的<code>pool</code>经过系统页对齐的地址. 到现在为止, <code>arena</code>和<code>pool</code>建立了联系, 就等着<code>usable_arenas</code>接收了.</p>
<h2 id="第2层对象分配器"><a href="#第2层对象分配器" class="headerlink" title="第2层对象分配器"></a>第2层对象分配器</h2><p>尽管我们花了大量篇幅介绍<code>arena</code>, 然而Python申请内存时, 直接打交道的确实<code>pool</code>. 这也无可厚非, 毕竟只有通过<code>pool</code>才能找到保存固定大小的<code>block</code>块的内存.</p>
<h3 id="usedpools"><a href="#usedpools" class="headerlink" title="usedpools"></a>usedpools</h3><p>在Python中为实现高速搜索<code>pool</code>, 使用了一个全局变量<code>usedpools</code>来保持<code>pool</code>数组. 一个 <code>pool</code>在Python运行期间, 必然处于以下三种状态中的一种:</p>
<ul>
<li><code>used</code>状态: <code>pool</code>中至少有一个<code>block</code>已经被使用, 并且至少一个<code>block</code>还未被使用, 这种状态受控于<code>usedpools</code>数组;</li>
<li><code>full</code>状态: <code>pool</code>中的所有<code>block</code>都已经被使用, 这种状态的<code>pool</code>位于<code>arena</code>中, 但不在<code>arena</code>的<code>freepools</code>链表中;</li>
<li><code>empty</code>状态: 这种状态的<code>pool</code>中的所有<code>block</code>都未使用, 处于这种状态的<code>pool</code>集合, 通过<code>pool_header</code>的<code>nextpool</code>构成的链表正好形成<code>arena</code>的<code>freepools</code>;</li>
</ul>
<p>下面给出了一个<code>arena</code>中包含三种状态的<code>pool</code>集合的一个可能状态:</p>
<p><img src="/images/pymemobject-7.png" alt=""></p>
<p>注意, 处于<code>full</code>状态的<code>pool</code>是独立的, 没有和其他<code>pool</code>那样会链接成链表. 所有处于<code>used</code>状态的<code>pool</code>都被受控于<code>usedpools</code>数组. <code>usedpools</code> 与<code>size class index</code>有着密切的联系, 来看一看<code>usedpools</code>的结构:</p>
<pre><code class="c">[obmalloc.c]
typedef struct pool_header *poolp;
#define PTA(x)  ((poolp )((uint8_t *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))
#define PT(x)   PTA(x), PTA(x)

static poolp usedpools[2 * ((NB_SMALL_SIZE_CLASSES + 7) / 8) * 8] = {
    PT(0), PT(1), PT(2), PT(3), PT(4), PT(5), PT(6), PT(7)
#if NB_SMALL_SIZE_CLASSES &gt; 8
    , PT(8), PT(9), PT(10), PT(11), PT(12), PT(13), PT(14), PT(15)
#if NB_SMALL_SIZE_CLASSES &gt; 16
    , PT(16), PT(17), PT(18), PT(19), PT(20), PT(21), PT(22), PT(23)
......
#if NB_SMALL_SIZE_CLASSES &gt; 56
    , PT(56), PT(57), PT(58), PT(59), PT(60), PT(61), PT(62), PT(63)
......
#endif /* NB_SMALL_SIZE_CLASSES &gt;  8 */
};
</code></pre>
<p>可以看到<code>usedpools</code>是一个<code>pool_header</code>的指针型数组, 将它精简过后的形式是:</p>
<pre><code class="c">static poolp usedpools[128] = {
    PT(0), PT(1), PT(2), PT(3), PT(4), PT(5), PT(6), PT(7)
    , PT(8), PT(9), PT(10), PT(11), PT(12), PT(13), PT(14), PT(15)
    , PT(16), PT(17), PT(18), PT(19), PT(20), PT(21), PT(22), PT(23)
    ......
    , PT(56), PT(57), PT(58), PT(59), PT(60), PT(61), PT(62), PT(63)
};
</code></pre>
<p>看来<code>usedpools</code>的元素数量是<code>128</code>, 但是我们申请大小的种类类型却只有<code>64</code>种. 呈倍数关系是因为采用了双向链表连接<code>pool</code>, <code>usedpools</code>的元素被两两分为一组.</p>
<p>而宏定义<code>PT(x)</code>定义了一个指针: 这个指针指向的位置是从一组的开头再往前”两个block指针型的大小”.</p>
<p>懵逼…还是不太明白, 为什么非要把问题弄这么复杂, 直接将<code>usedpools</code>作为<code>pool_header</code>数组不行吗?</p>
<p>关于这点在注释中有解释:</p>
<blockquote>
<p>It’s unclear why the usedpools setup is so convoluted. <br><br>/<em> usedpools的设置不知为何变得如此复杂 </em>/ <br><br>It could be to<br>minimize the amount of cache required to hold this heavily-referenced table<br>(which only <em>needs</em> the two interpool pointer members of a pool_header).<br><br>/<em> 这可能是最大限度地减少持有这个严重引用的表所需的缓存量（它只需要</em> pool_header的两个池间指针成员）*/</p>
</blockquote>
<p>有点懵圈, 讲了一大堆云里雾里的, 关于<code>arena</code>, <code>pool</code>和<code>block</code>也有了一个模糊的概念, 下面就具体针对两个函数<code>_PyObject_Malloc</code>和<code>_PyObject_Free</code>, 分析Python的内存分配和内存释放过程.</p>
<h3 id="PyObject-Malloc"><a href="#PyObject-Malloc" class="headerlink" title="_PyObject_Malloc"></a>_PyObject_Malloc</h3><p>Python中的对大部分对象的内存分配都是通过这个函数<code>_PyObject_Malloc</code>完成的.</p>
<p>这个函数有三个作用: “分配block”, “分配pool”和”分配arena”.</p>
<p>函数的整体流程如下(为了更好的理解, 对源码进行了整理):</p>
<pre><code class="c">
static void *
_PyObject_Alloc(int use_calloc, void *ctx, size_t nelem, size_t elsize)
{
    size_t nbytes;
    block *bp;
    poolp pool;
    poolp next;
    uint size;

    _Py_AllocatedBlocks++;

    nbytes = nelem * elsize;  /* 计算需要申请的字节数 */

    if (nelem == 0 || elsize == 0)
        goto redirect;
    /* 申请的字节数是否小于等于512字节? */
    if ((nbytes - 1) &lt; SMALL_REQUEST_THRESHOLD) {
        LOCK(); /* 线程锁 */
        size = (uint)(nbytes - 1) &gt;&gt; ALIGNMENT_SHIFT; /* 转换成索引 */
        pool = usedpools[size + size]; /* 从usedpools中取出pool */
        /* 检查pool是否连接到了指定索引的usedpool是的元素
        如果连接到了那么pool和pool-&gt;nextpool地址应该不同 */
        if (pool != pool-&gt;nextpool) { /* 返回pool内的block */
            ++pool-&gt;ref.count; /* pool内分配的block数量加一 */
            bp = pool-&gt;freeblock; 
            /* 尝试通过离散链表获取block(使用完毕的block) */
            if ((pool-&gt;freeblock = *(block **)bp) != NULL) {
                UNLOCK(); /* 解锁线程 */
                return (void *)bp; /* 返回block */
            }
            /* 通过偏移量取出block(未使用的block) */
            if (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) {
                /* There is room for another block. */
                pool-&gt;freeblock = (block*)pool +
                                  pool-&gt;nextoffset;
                /* 设定下一个空block的偏移量 */
                pool-&gt;nextoffset += INDEX2SIZE(size);
                *(block **)(pool-&gt;freeblock) = NULL;
                UNLOCK();
                return (void *)bp; /* 返回block*/
            }
            /* 该pool已满, 无法再使用, 从usedpools中移除 */
            next = pool-&gt;nextpool;
            pool = pool-&gt;prevpool;
            next-&gt;prevpool = pool;
            pool-&gt;nextpool = next;
            UNLOCK();
            return (void *)bp; /* 返回block */
        }
        /* 没有可用的arena, 调用new_arena创建新的arenas */
        if (usable_arenas == NULL) {
            if (narenas_currently_allocated &gt;= MAX_ARENAS) {
                UNLOCK();
                goto redirect;
            }
            usable_arenas = new_arena(); /* 分配新的一批arena_objects */
            if (usable_arenas == NULL) {
                UNLOCK();
                goto redirect;
            }
            usable_arenas-&gt;nextarena =
                usable_arenas-&gt;prevarena = NULL;
        }

        /* 从arean中取出空闲的pool */
        pool = usable_arenas-&gt;freepools;
        if (pool != NULL) { /* 检查是否存在空闲的pool */
            usable_arenas-&gt;freepools = pool-&gt;nextpool; /* 把空闲的pool从链表中取出 */

            --usable_arenas-&gt;nfreepools; /* usable_arenas可用pool数减一 */
            if (usable_arenas-&gt;nfreepools == 0) {  /* arena中已经没有空闲pool, 将它移除 */

                usable_arenas = usable_arenas-&gt;nextarena;
                if (usable_arenas != NULL) {
                    usable_arenas-&gt;prevarena = NULL;
                }
            }
        init_pool: /* 初始化并返回pool */
            /* 连接usedpools的开头 */
            next = usedpools[size + size]; /* == prev */
            pool-&gt;nextpool = next;
            pool-&gt;prevpool = next;
            next-&gt;nextpool = pool;
            next-&gt;prevpool = pool;
            pool-&gt;ref.count = 1;
            if (pool-&gt;szidx == size) {
                /* 比较申请的大小和pool中block的固定大小*/
                /* 如果相同(曾经使用过, 而且size相同), 那么就不用进行初始化也无所谓 */
                bp = pool-&gt;freeblock;
                pool-&gt;freeblock = *(block **)bp; /* 设定下一个block地址 */
                UNLOCK();
                return (void *)bp; /* 返回block */
            }
            /* 初始化pool */
            pool-&gt;szidx = size;
            size = INDEX2SIZE(size);
            bp = (block *)pool + POOL_OVERHEAD;
            pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; 1);
            pool-&gt;maxnextoffset = POOL_SIZE - size;
            pool-&gt;freeblock = bp + size;
            *(block **)(pool-&gt;freeblock) = NULL;
            UNLOCK();
            return (void *)bp; /* 返回block */
        }
        /* 初始化空的pool */
        pool = (poolp)usable_arenas-&gt;pool_address;
        pool-&gt;arenaindex = (uint)(usable_arenas - arenas);
        pool-&gt;szidx = DUMMY_SIZE_IDX;
        usable_arenas-&gt;pool_address += POOL_SIZE;
        --usable_arenas-&gt;nfreepools;

        if (usable_arenas-&gt;nfreepools == 0) { /* 如果没有可用的pool了, 那么就设定下一个arena */
            usable_arenas = usable_arenas-&gt;nextarena;
            if (usable_arenas != NULL) {
                usable_arenas-&gt;prevarena = NULL;
            }
        }

        goto init_pool;
    }


redirect: /* 调用原生的malloc分配内存 */
    {
        void *result;
        result = PyMem_RawMalloc(nbytes);
        return result;
    }
}
</code></pre>
<pre><code class="c">static void *
_PyObject_Malloc(size_t nbytes)
{
    /* 是否小于等于512字节? */
    if ((nbytes - 1) &lt; SMALL_REQUEST_THRESHOLD) {
        /* (A)从usedpools中取出pool */
        if (pool != pool-&gt;nextpool) {
           /* (B)返回pool内的block */
        }
        /* 是否存在可以使用的arena? */
        if (usable_arenas == NULL) {
            /* (C)调用new_arena */
        }
        /* 从arena中取出使用空闲的pool */
        pool = usable_arenas-&gt;freepools;
        /* 是否存在空闲的pool */
        if (pool != NULL) {
            /* (D)初始化空闲的pool */    

            /* (E)初始化pool并返回block */
       }
    }

  redirect:
    {
        /* 当大于256字节时, 使用原生的malloc申请内存 */
        void *result;
        result = PyMem_RawMalloc(nbytes);
        return result;
    }
}
</code></pre>
<h3 id="PyObject-Free"><a href="#PyObject-Free" class="headerlink" title="_PyObject_Free"></a>_PyObject_Free</h3><p>和分配内存对应, <code>_PyObject_Free</code>释放用<code>_PyObject_Malloc</code>分配的内存. 这个函数主要三个作用: “释放block”, “释放pool”和”释放arena”.</p>
<p>下面是整理过的源码和注释:</p>
<pre><code class="c">static void
_PyObject_Free(void *ctx, void *p)
{
    poolp pool;
    block *lastfree;
    poolp next, prev;
    uint size;

    if (p == NULL)      /* 为NULL时, 不执行任何动作 */
        return;

    _Py_AllocatedBlocks--;

    pool = POOL_ADDR(p); /* 从作为释放对象的地址取出所属的pool */
    if (address_in_range(p, pool)) { /* 检查获得的pool是否正确 */
        LOCK(); /* 线程锁 */

        *(block **)p = lastfree = pool-&gt;freeblock; /* 构建使用完毕的block的离散链表 */
        pool-&gt;freeblock = (block *)p;  /* 将block设置为freeblock头 */
        if (lastfree) { /* 这个pool的最后free的block是否为NULL */
            struct arena_object* ao;
            uint nf;  /* ao-&gt;nfreepools */

            if (--pool-&gt;ref.count != 0) { /* pool正在使用used, 不执行任何操作 */
                UNLOCK();
                return;
            }

            /* pool变成empty状态, 从usedpools中移除 */
            /* prev &lt;-&gt; pool &lt;-&gt; next */
            /* prev &lt;-&gt; next */
            next = pool-&gt;nextpool;
            prev = pool-&gt;prevpool;
            next-&gt;prevpool = prev;
            prev-&gt;nextpool = next;

            /* 将pool返回到arena的freepools */
            ao = &amp;arenas[pool-&gt;arenaindex];
            pool-&gt;nextpool = ao-&gt;freepools;
            ao-&gt;freepools = pool;
            nf = ++ao-&gt;nfreepools;

             /* 释放arena */
            if (nf == ao-&gt;ntotalpools) { /* 当arena内全是空的pool, 就将其释放掉 */
                /* 从usable_arenas中移除 */
                if (ao-&gt;prevarena == NULL) {
                    usable_arenas = ao-&gt;nextarena;
                }
                else {
                    ao-&gt;prevarena-&gt;nextarena =
                        ao-&gt;nextarena;
                }
                if (ao-&gt;nextarena != NULL) {
                    ao-&gt;nextarena-&gt;prevarena =
                        ao-&gt;prevarena;
                }
                /* 为了再次利用arena, 将其连接到unused_arena_objects */
                ao-&gt;nextarena = unused_arena_objects;
                unused_arena_objects = ao;

                /* 释放掉arena维护的那块内存 */
                _PyObject_Arena.free(_PyObject_Arena.ctx,
                                     (void *)ao-&gt;address, ARENA_SIZE);
                ao-&gt;address = 0;                        /* mark unassociated */
                --narenas_currently_allocated;

                UNLOCK();
                return;
            }
            if (nf == 1) { /* arena中只有一个空的pool */
                /* 这里只有一个空的pool, 意味着在这次释放pool之前, 所有pool都在使用 */
                /* 本来没有连接到usable_arenas中, 现在需要连接到usable_arenas头 */
                ao-&gt;nextarena = usable_arenas;
                ao-&gt;prevarena = NULL;
                if (usable_arenas)
                    usable_arenas-&gt;prevarena = ao;
                usable_arenas = ao;

                UNLOCK();
                return;
            }

            if (ao-&gt;nextarena == NULL || nf &lt;= ao-&gt;nextarena-&gt;nfreepools) {
                /* 如果arena是最后一个arena, 或者这个arena_object中空闲的pool数量小于下一个 */
                /* 那么不执行任何操作 */
                UNLOCK();
                return;
            }
             /* 如果不是上面两种情况, 则需要对arena按从小到大排序 */
             /* 首先我们将这个arena从usable_arenas中拿出来 */
            if (ao-&gt;prevarena != NULL) {
                ao-&gt;prevarena-&gt;nextarena = ao-&gt;nextarena;
            }
            else {
                usable_arenas = ao-&gt;nextarena;
            }
            ao-&gt;nextarena-&gt;prevarena = ao-&gt;prevarena;

            /* 然后从usable_arenas中找到合适位置插入arena_object */
            while (ao-&gt;nextarena != NULL &amp;&amp;
                            nf &gt; ao-&gt;nextarena-&gt;nfreepools) {
                ao-&gt;prevarena = ao-&gt;nextarena;
                ao-&gt;nextarena = ao-&gt;nextarena-&gt;nextarena;
            }

            ao-&gt;prevarena-&gt;nextarena = ao;
            if (ao-&gt;nextarena != NULL)
                ao-&gt;nextarena-&gt;prevarena = ao;

            UNLOCK();
            return;
        }

        /* lastfree为NULL意味着这个pool内的所有block都已经分配完毕 */
        /* 需要从usedpools中取出这个大小类型的pool, 并将这个pool连接到usedpools开头 */
        --pool-&gt;ref.count;
        size = pool-&gt;szidx;
        next = usedpools[size + size];
        prev = next-&gt;prevpool;
        pool-&gt;nextpool = next;
        pool-&gt;prevpool = prev;
        next-&gt;prevpool = pool;
        prev-&gt;nextpool = pool;
        UNLOCK();
        return;
    }

redirect:
    /* 释放其他空间 */
    PyMem_RawFree(p);
}
</code></pre>
<h2 id="第3层特殊对象缓冲机制"><a href="#第3层特殊对象缓冲机制" class="headerlink" title="第3层特殊对象缓冲机制"></a>第3层特殊对象缓冲机制</h2><p>这一部分, 我们在前面的Python内置对象讲过, 针对一些常用的类型, Python提供了一系列的缓冲池技术.</p>
<!-- 当申请一个32字节的`pool`时, 需要将这个`pool`放入`usedpools`. 先得到它的`size class index`, 也就是3. 然后进行`usedpools[3+3]->nextpool = pool`即可.  -->
<!-- 

`PyObject_Malloc`中利用了这个技巧来判断某个`class size index`对应的`pool`是否存在于`usedpools`中.


```c
static void *
_PyObject_Alloc(int use_calloc, void *ctx, size_t nelem, size_t elsize)
{
    size_t nbytes;
    block *bp;
    poolp pool;
    poolp next;
    uint size;

    if ((nbytes - 1) < SMALL_REQUEST_THRESHOLD) {
        LOCK();

        /* 获得size class index */
        size = (uint)(nbytes - 1) >> ALIGNMENT_SHIFT;
        pool = usedpools[size + size];
        if (pool != pool->nextpool) { /* usedpools是否有可用的pool */
            ......
        }
      ......
}
```

### 创建pool


当Python启动的时候, `usedpools`这个内存池中并没有可用内存, 当我们开始申请小块内存的时候, Python才开始建立这个内存池. 假设我们申请`32`字节的内存, Python首先得到对应的`class size index=3`,  在`usedpools`对应的位置查找, 发现没有任何可用的`pool`, Python才会从`useable_arenas`链表中第一个可用的`arena`获得一个可用的`pool`. 考虑到, 这个`pool`将是用于分配`32`字节`block`的, 因此在此它需要被重新划分.

```c
[obmalloc.c]
static void * _PyObject_Alloc(int use_calloc, void *ctx, size_t nelem, size_t elsize)
{
    ...
  init_pool:  /* 初始化pool */
    // 将pool放入usedpools中
    next = usedpools[size + size];
    pool->nextpool = next;
    pool->prevpool = next;
    next->nextpool = pool;
    next->prevpool = pool;
    pool->ref.count = 1;
    // pool在之前就具有正确的size结构, 直接返回pool中的一个block
    if (pool->szidx == size) {
        bp = pool->freeblock;
        assert(bp != NULL);
        pool->freeblock = *(block **)bp;
        UNLOCK();
        if (use_calloc)
            memset(bp, 0, nbytes);
        return (void *)bp;
    }
    // 初始化pool_header, 将freeblock指向第二个block, 返回第一个block
    pool->szidx = size;
    size = INDEX2SIZE(size);
    bp = (block *)pool + POOL_OVERHEAD;
    pool->nextoffset = POOL_OVERHEAD + (size << 1);
    pool->maxnextoffset = POOL_SIZE - size;
    pool->freeblock = bp + size;
    *(block **)(pool->freeblock) = NULL;
    UNLOCK();
    if (use_calloc)
        memset(bp, 0, nbytes);
    return (void *)bp;
    ...
}
```

Python将得到的pool放入了usedpools中. 那么在什么情况下pool从empty转为used状态呢? 假设申请的内存为size class index 为 i. 字儿usedpools[i + i] 处没有处于used状态的pool. 同时全局变量freepools中海油处于empty的pool, 那么位于freepool维护的链表中头部pool将被取出来, 放入usedpools中, 这时, 这个pool也就从empry状态转为used状态.


```c
[obmalloc.c _PyObject_Alloc]
pool = usable_arenas->freepools;
if (pool != NULL) {
    usable_arenas->freepools = pool->nextpool;
    ...// 调整usable_arenas->nfreepools和usable_arenas自身

init_pool:
    ...
}
``` -->

    
  </div>

  
      <div class="git"></div>
  

</article>

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持作者</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/posts/8c8f8f97/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/posts/73bb8543/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

  <div id="gitment-comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    (function () {
      var gitment = new Gitment({
        owner: 'zhongshangwu',
        repo: 'zhongshangwu.github.io',
        oauth: {
          client_id: 'ecb8413d71a24ae7e38a',
          client_secret: '6aacbb72400e02734e754fce4b6204ae07ec9dc2'
        },
        
        
        
        
        
        
        
        
      })
      gitment.render('gitment-comments')
    })()
  </script>



    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
