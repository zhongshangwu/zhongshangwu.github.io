<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Python源码阅读-运行时环境初始化 | Shawn&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Python,源码," />
  

  <meta name="description" content="前面已经接触了许多执行引擎相关的工作，然而关于Python虚拟机还有一大块的是我们没有了解的，那就是运行时环境的初始化。 Python3启动后真正有意义的初始化动作是从Py_Initialize(位于pylifecycle.c文件)开始的，其内部调用的就是_Py_InitializeEx_Private函数，本节的主要内容就是以这个函数为入口，深入理解Python虚拟机的启动流程。">
<meta name="keywords" content="Python,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Python源码阅读-运行时环境初始化">
<meta property="og:url" content="http://shawnz.me/posts/73bb8543/index.html">
<meta property="og:site_name" content="Shawn&#39;s Blog">
<meta property="og:description" content="前面已经接触了许多执行引擎相关的工作，然而关于Python虚拟机还有一大块的是我们没有了解的，那就是运行时环境的初始化。 Python3启动后真正有意义的初始化动作是从Py_Initialize(位于pylifecycle.c文件)开始的，其内部调用的就是_Py_InitializeEx_Private函数，本节的主要内容就是以这个函数为入口，深入理解Python虚拟机的启动流程。">
<meta property="og:updated_time" content="2018-03-10T06:20:54.162Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python源码阅读-运行时环境初始化">
<meta name="twitter:description" content="前面已经接触了许多执行引擎相关的工作，然而关于Python虚拟机还有一大块的是我们没有了解的，那就是运行时环境的初始化。 Python3启动后真正有意义的初始化动作是从Py_Initialize(位于pylifecycle.c文件)开始的，其内部调用的就是_Py_InitializeEx_Private函数，本节的主要内容就是以这个函数为入口，深入理解Python虚拟机的启动流程。">

  

  
    <link rel="icon" href="/favicon.png">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/custom.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程模型"><span class="toc-text">线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程环境初始化"><span class="toc-text">线程环境初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统模块初始化"><span class="toc-text">系统模块初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#builtin-模块"><span class="toc-text">builtin 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sys-模块"><span class="toc-text">sys 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块备份"><span class="toc-text">模块备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置模块搜索路径"><span class="toc-text">设置模块搜索路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main模块"><span class="toc-text">main模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#site-packages"><span class="toc-text">site-packages</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#激活虚拟机"><span class="toc-text">激活虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#交互式环境"><span class="toc-text">交互式环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#脚本方式执行"><span class="toc-text">脚本方式执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-mod"><span class="toc-text">run_mod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名空间"><span class="toc-text">命名空间</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Python源码阅读-运行时环境初始化" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Python源码阅读-运行时环境初始化</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.01.17</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Shawn Zhong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>前面已经接触了许多执行引擎相关的工作，然而关于Python虚拟机还有一大块的是我们没有了解的，那就是运行时环境的初始化。</p>
<p>Python3启动后真正有意义的初始化动作是从<code>Py_Initialize</code>(位于<code>pylifecycle.c</code>文件)开始的，其内部调用的就是<code>_Py_InitializeEx_Private</code>函数，本节的主要内容就是以这个函数为入口，深入理解Python虚拟机的启动流程。</p>
<a id="more"></a>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>在接触虚拟机启动之前先了解一下Python的线程模型，我们知道Python的进程和线程是来自于操作系统，这里所说的线程模型是指在Python内部维护的这些操作系统进程和线程状态。下面是进程和线程的结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">is</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">is</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">tstate_head</span>;</span></span><br><span class="line">    PyObject *modules;</span><br><span class="line">    PyObject *modules_by_index;</span><br><span class="line">    PyObject *sysdict;</span><br><span class="line">    PyObject *builtins;</span><br><span class="line">    ......</span><br><span class="line">    _PyFrameEvalFunction eval_frame;</span><br><span class="line">&#125; PyInterpreterState;</span><br></pre></td></tr></table></figure>
<p>以及<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">ts</span> *<span class="title">next</span>;</span></span><br><span class="line">    PyInterpreterState *interp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="keyword">int</span> recursion_depth;</span><br><span class="line">    ......</span><br><span class="line">    PyObject *dict;  <span class="comment">/* Stores per-thread state */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> gilstate_counter;</span><br><span class="line">    <span class="keyword">long</span> thread_id; <span class="comment">/* Thread id where this tstate was created */</span></span><br><span class="line">    ......</span><br><span class="line">&#125; PyThreadState;</span><br></pre></td></tr></table></figure></p>
<h2 id="线程环境初始化"><a href="#线程环境初始化" class="headerlink" title="线程环境初始化"></a>线程环境初始化</h2><p>在虚拟机启动的时候，首先会初始化线程和进程环境。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interp = PyInterpreterState_New();</span><br><span class="line">tstate = PyThreadState_New(interp);</span><br><span class="line">(<span class="keyword">void</span>) PyThreadState_Swap(tstate);</span><br></pre></td></tr></table></figure>
<p>可以看到虚拟机首先会通过<code>PyInterpreterState_New</code>创建一个进程对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyInterpreterState *interp_head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">PyInterpreterState *</span><br><span class="line">PyInterpreterState_New(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyInterpreterState *interp = (PyInterpreterState *)</span><br><span class="line">                                 PyMem_RawMalloc(<span class="keyword">sizeof</span>(PyInterpreterState));</span><br><span class="line">    <span class="keyword">if</span> (interp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        HEAD_INIT();</span><br><span class="line">        interp-&gt;modules = <span class="literal">NULL</span>;</span><br><span class="line">        interp-&gt;modules_by_index = <span class="literal">NULL</span>;</span><br><span class="line">        interp-&gt;sysdict = <span class="literal">NULL</span>;</span><br><span class="line">        interp-&gt;builtins = <span class="literal">NULL</span>;</span><br><span class="line">        interp-&gt;builtins_copy = <span class="literal">NULL</span>;</span><br><span class="line">        interp-&gt;tstate_head = <span class="literal">NULL</span>;</span><br><span class="line">        ......</span><br><span class="line">        interp-&gt;eval_frame = _PyEval_EvalFrameDefault;</span><br><span class="line">        HEAD_LOCK();</span><br><span class="line">        interp-&gt;next = interp_head;</span><br><span class="line">        interp_head = interp;</span><br><span class="line">        HEAD_UNLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在python内部维护着一套全局管理的<code>PyInterpreterState</code>链表，表头为<code>interp_head</code>，通过指针<code>interp-&gt;next</code>指向下一个进程对象。</p>
<p>在创建完进程对象后，接着又创建了一个全新线程状态对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">PyThreadState *</span><br><span class="line">PyThreadState_New(PyInterpreterState *interp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> new_threadstate(interp, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyThreadState *</span><br><span class="line">new_threadstate(PyInterpreterState *interp, <span class="keyword">int</span> init)</span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = (PyThreadState *)PyMem_RawMalloc(<span class="keyword">sizeof</span>(PyThreadState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_PyThreadState_GetFrame == <span class="literal">NULL</span>) <span class="comment">/* 设置全局的函数调用栈获取函数 */</span></span><br><span class="line">        _PyThreadState_GetFrame = threadstate_getframe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tstate != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tstate-&gt;interp = interp; <span class="comment">/* 和线程对应的进程对象 */</span></span><br><span class="line"></span><br><span class="line">        tstate-&gt;frame = <span class="literal">NULL</span>;</span><br><span class="line">        tstate-&gt;recursion_depth = <span class="number">0</span>;</span><br><span class="line">        tstate-&gt;overflowed = <span class="number">0</span>;</span><br><span class="line">        tstate-&gt;recursion_critical = <span class="number">0</span>;</span><br><span class="line">        tstate-&gt;tracing = <span class="number">0</span>;</span><br><span class="line">        tstate-&gt;use_tracing = <span class="number">0</span>;</span><br><span class="line">        tstate-&gt;gilstate_counter = <span class="number">0</span>;</span><br><span class="line">        tstate-&gt;async_exc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_THREAD</span></span><br><span class="line">        tstate-&gt;thread_id = PyThread_get_thread_ident(); <span class="comment">/* 线程标识 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        tstate-&gt;thread_id = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        tstate-&gt;dict = <span class="literal">NULL</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (init)</span><br><span class="line">            _PyThreadState_Init(tstate);</span><br><span class="line">        HEAD_LOCK();</span><br><span class="line">        tstate-&gt;prev = <span class="literal">NULL</span>; <span class="comment">/* 线程链 */</span></span><br><span class="line">        tstate-&gt;next = interp-&gt;tstate_head;</span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;next)</span><br><span class="line">            tstate-&gt;next-&gt;prev = tstate;</span><br><span class="line">        interp-&gt;tstate_head = tstate; <span class="comment">/* 反向关联进程 */</span></span><br><span class="line">        HEAD_UNLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tstate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化线程对象的时候，Python也设置了从线程中获取函数调用栈的方法，这里说函数调用”栈“而不是“帧”是因为<code>PyFrameObject</code>之间也是一个链表结构。</p>
<p>在创建完进程和线程对象之后，虚拟机也为它俩建立了联系，这样任何时候都可以很容易的在<code>PyInterpreterState</code>对象和<code>PyThreadState</code>对象之间穿梭。</p>
<p>并且Python还通过一个全局的变量维护当前线程对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Py_atomic_address _PyThreadState_Current = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这里比较有意思的是<code>_Py_atomic_address</code>，在Python内部有一套<code>原子API</code>，使用这些<code>原子操作API</code>操作<code>原子变量</code>时，其它线程是不能访问该变量的。所以对那个全局的当前线程变量的操作是”线程安全“的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_TSTATE() \</span></span><br><span class="line">    ((PyThreadState*)_Py_atomic_load_relaxed(&amp;_PyThreadState_Current))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_TSTATE(value) \</span></span><br><span class="line">    _Py_atomic_store_relaxed(&amp;_PyThreadState_Current, (<span class="keyword">uintptr_t</span>)(value))</span><br><span class="line"></span><br><span class="line">PyThreadState *</span><br><span class="line">PyThreadState_Swap(PyThreadState *newts)</span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *oldts = GET_TSTATE();</span><br><span class="line"></span><br><span class="line">    SET_TSTATE(newts);</span><br><span class="line">    <span class="keyword">return</span> oldts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>*NOTE：Python中的GIL机制保证的是单条字节码执行的线程安全，不保证Python语句执行的线程安全。</code></p>
<p>在初始化线程环境后，虚拟机会对Python的类型系统和缓冲池进行初始化。接着就进入了系统模块的初始化工作。</p>
<h2 id="系统模块初始化"><a href="#系统模块初始化" class="headerlink" title="系统模块初始化"></a>系统模块初始化</h2><p>系统模块的初始，得从<code>__builtin__</code>开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interp-&gt;modules = PyDict_New();</span><br><span class="line">bimod = _PyBuiltin_Init();</span><br><span class="line">_PyImport_FixupBuiltin(bimod, <span class="string">"builtins"</span>);</span><br><span class="line">interp-&gt;builtins = PyModule_GetDict(bimod);</span><br></pre></td></tr></table></figure>
<p>可以从上面看到，进程对象创建了一个字典<code>modules</code>，维护着当前进程中的所有模块。</p>
<p>将内置类型对象添加到<code>builtins</code>模块中是在<code>_PyBuiltin_Init</code>中完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">_PyBuiltin_Init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *mod, *dict, *debug;</span><br><span class="line">    ...... <span class="comment">/* 检查类型系统是否初始化完毕 */</span></span><br><span class="line">    mod = PyModule_Create(&amp;builtinsmodule); <span class="comment">/* 创建builtins模块 */</span></span><br><span class="line">    dict = PyModule_GetDict(mod);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETBUILTIN(NAME, OBJECT) \ <span class="comment">/* 宏定义 */</span></span></span><br><span class="line">    <span class="keyword">if</span> (PyDict_SetItemString(dict, NAME, (PyObject *)OBJECT) &lt; <span class="number">0</span>)       \</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;                                                    \</span><br><span class="line">    <span class="comment">/* 将内置类型对象添加builtins模块的字典中 */</span></span><br><span class="line">    SETBUILTIN(<span class="string">"None"</span>,                  Py_None);</span><br><span class="line">    SETBUILTIN(<span class="string">"Ellipsis"</span>,              Py_Ellipsis);</span><br><span class="line">    ......</span><br><span class="line">    SETBUILTIN(<span class="string">"zip"</span>,                   &amp;PyZip_Type);</span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> SETBUILTIN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_PyBuiltin_Init</code>通过两个步骤完成对<code>builtin</code>的设置：</p>
<ul>
<li>创建<code>PyModuleObject</code>对象，这个对象正是Python内部模块的实现；</li>
<li>填充内置类型对象到新创建的<code>__builtin__</code>模块中；</li>
</ul>
<p>第二步的工作十分简单，我们直接来看看<code>__builtin__</code>模块是怎么创建的。</p>
<h3 id="builtin-模块"><a href="#builtin-模块" class="headerlink" title="builtin 模块"></a><strong>builtin</strong> 模块</h3><p>模块的创建是通过<code>PyModule_Create2</code>函数完成的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyModule_Create2(struct PyModuleDef* <span class="keyword">module</span>, <span class="keyword">int</span> module_api_version)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    PyModuleObject *m;</span><br><span class="line">    PyInterpreterState *interp = PyThreadState_Get()-&gt;interp; <span class="comment">/* 获取进程对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (interp-&gt;modules == <span class="literal">NULL</span>)</span><br><span class="line">        Py_FatalError(<span class="string">"Python import machinery not initialized"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!PyModuleDef_Init(<span class="keyword">module</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    name = <span class="keyword">module</span>-&gt;m_name;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> ((m = (PyModuleObject*)PyModule_New(name)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;m_methods != <span class="literal">NULL</span>) &#123; <span class="comment">/* 添加module函数中的methods */</span></span><br><span class="line">        <span class="keyword">if</span> (PyModule_AddFunctions((PyObject *) m, <span class="keyword">module</span>-&gt;m_methods) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;m_doc != <span class="literal">NULL</span>) &#123; <span class="comment">/* 添加module文档注释 */</span></span><br><span class="line">        <span class="keyword">if</span> (PyModule_SetDocString((PyObject *) m, <span class="keyword">module</span>-&gt;m_doc) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;md_def = <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">return</span> (PyObject*)m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们说<code>PyModuleObject</code>才是Python中模块的实现，那么<code>PyModuleDef</code>又是什么呢？我们来比较一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span>&#123;</span></span><br><span class="line">  PyModuleDef_Base m_base;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* m_name;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* m_doc;</span><br><span class="line">  Py_ssize_t m_size;</span><br><span class="line">  PyMethodDef *m_methods;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef_Slot</span>* <span class="title">m_slots</span>;</span></span><br><span class="line">  traverseproc m_traverse;</span><br><span class="line">  inquiry m_clear;</span><br><span class="line">  freefunc m_free;</span><br><span class="line">&#125; PyModuleDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *md_dict;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> *<span class="title">md_def</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *md_state;</span><br><span class="line">    PyObject *md_weaklist;</span><br><span class="line">    PyObject *md_name;</span><br><span class="line">&#125; PyModuleObject;</span><br></pre></td></tr></table></figure>
<p>应该可以大致看出来<code>PyModuleDef</code>是创建模块对象的一个模块定义，在这里面定义了模块名、注释以及模块函数等等。这么一来<code>builtinsmodule</code>应该就是<code>builtin</code>模块的定义所在，我来看看这里面都有什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">builtinsmodule</span> = &#123;</span></span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">"builtins"</span>,</span><br><span class="line">    builtin_doc,</span><br><span class="line">    <span class="number">-1</span>, <span class="comment">/* multiple "initialization" just copies the module dict. */</span></span><br><span class="line">    builtin_methods,</span><br><span class="line">    <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMethodDef builtin_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"__build_class__"</span>, (PyCFunction)builtin___build_class__,</span><br><span class="line">    METH_VARARGS | METH_KEYWORDS, build_class_doc&#125;,</span><br><span class="line">    &#123;<span class="string">"__import__"</span>,      (PyCFunction)builtin___import__, METH_VARARGS | METH_KEYWORDS, import_doc&#125;,</span><br><span class="line">    BUILTIN_ABS_METHODDEF</span><br><span class="line">    BUILTIN_ALL_METHODDEF</span><br><span class="line">    ......</span><br><span class="line">    &#123;<span class="string">"print"</span>,           (PyCFunction)builtin_print,      METH_VARARGS | METH_KEYWORDS, print_doc&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>,              <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>builtinsmodule</code>结构体中定义了<code>builtins</code>模块名，另外和模块定义相似，对于函数，Python也有类似的结构<code>PyMethodDef</code>，而<code>builtin_methods</code>结构体数组就维护了一大堆的函数名称到函数指针的映射。</p>
<p>现在弄懂了<code>PyModuleObject</code>和<code>PyModuleDef</code>后，我们再回到函数<code>PyModule_Create2</code>中，真正的创建模块对象的函数是<code>PyModule_New</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyModule_NewObject(PyObject *name)</span><br><span class="line">&#123;</span><br><span class="line">    PyModuleObject *m;</span><br><span class="line">    m = PyObject_GC_New(PyModuleObject, &amp;PyModule_Type); <span class="comment">/* 分配内存 */</span></span><br><span class="line">    m-&gt;md_def = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_state = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_weaklist = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_name = <span class="literal">NULL</span>;</span><br><span class="line">    m-&gt;md_dict = PyDict_New(); <span class="comment">/* 初始化各个域 */</span></span><br><span class="line">    <span class="keyword">if</span> (module_init_dict(m, m-&gt;md_dict, name, <span class="literal">NULL</span>) != <span class="number">0</span>) <span class="comment">/* 填充dict */</span></span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">module_init_dict(PyModuleObject *mod, PyObject *md_dict,</span><br><span class="line">                 PyObject *name, PyObject *doc)</span><br><span class="line">&#123;</span><br><span class="line">    _Py_IDENTIFIER(__name__);</span><br><span class="line">    _Py_IDENTIFIER(__doc__);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (md_dict == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (doc == <span class="literal">NULL</span>)</span><br><span class="line">        doc = Py_None;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___name__, name) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyDict_SetItemId(md_dict, &amp;PyId___doc__, doc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的函数中，我们通过<code>PyObject_GC_New</code>为模块对象分配内存后，就对各个域进行了初始化，其中<code>md_dict</code>是一个字典，在创建一个模块对象后，虚拟机会通过<code>module_init_dict</code>，在其中填充模块的<code>__name__</code>和<code>__doc__</code>等属性。</p>
<p>到现在模块对象有了，而且<code>md_dict</code>域中也有了名称和注释，但虚拟机还需要进一步的设置，模块才能正常工作。依旧是<code>PyModule_Create2</code>函数中，虚拟机会根据模块对象的<code>m_methods</code>域设置模块函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">PyModule_AddFunctions(PyObject *m, PyMethodDef *functions)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    PyObject *name = PyModule_GetNameObject(m);</span><br><span class="line">    res = _add_methods_to_object(m, name, functions); <span class="comment">/* 添加模块函数 */</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_add_methods_to_object(PyObject *<span class="keyword">module</span>, PyObject *name, PyMethodDef *functions)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *func;</span><br><span class="line">    PyMethodDef *fdef;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (fdef = functions; fdef-&gt;ml_name != <span class="literal">NULL</span>; fdef++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fdef-&gt;ml_flags &amp; METH_CLASS) ||</span><br><span class="line">            (fdef-&gt;ml_flags &amp; METH_STATIC)) &#123; <span class="comment">/* 类方法和静态方法不做处理 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        func = PyCFunction_NewEx(fdef, (PyObject*)<span class="keyword">module</span>, name); <span class="comment">/* 创建函数对象 */</span></span><br><span class="line">        <span class="keyword">if</span> (PyObject_SetAttrString(<span class="keyword">module</span>, fdef-&gt;ml_name, func) != <span class="number">0</span>) &#123; <span class="comment">/* 设置属性 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对每个<code>PyMethodDef</code>结构，Python都会创建一个对应的<code>PyCFunctionObject</code>对象(这里面也用到了“缓冲池”机制)，这个对象就是一个函数指针的包装。这些创建的函数对象以属性的方式绑定在模块对象上面。</p>
<p>最后进程对象的<code>builtins</code>指针也指向了<code>builtins</code>模块的<code>md_dict</code>域。</p>
<p>和<code>builtins</code>模块相似，<code>sys</code>模块也是这样创建并被设置的。</p>
<h3 id="sys-模块"><a href="#sys-模块" class="headerlink" title="sys 模块"></a>sys 模块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysmod = _PySys_Init();  <span class="comment">/* 创建并初始化sys模块 */</span></span><br><span class="line">interp-&gt;sysdict = PyModule_GetDict(sysmod);</span><br><span class="line">_PyImport_FixupBuiltin(sysmod, <span class="string">"sys"</span>);  <span class="comment">/* 备份sys模块 */</span></span><br><span class="line">PyDict_SetItemString(interp-&gt;sysdict, <span class="string">"modules"</span>, interp-&gt;modules);</span><br></pre></td></tr></table></figure>
<p>创建的<code>sys</code>模块对象中主要加入了一些Python的版本信息和操作系统相关的信息，例如<code>version</code>、<code>platform</code>、<code>maxsize</code>和<code>byteorder</code>等。</p>
<h3 id="模块备份"><a href="#模块备份" class="headerlink" title="模块备份"></a>模块备份</h3><p>在<code>builtins</code>和<code>sys</code>创建完后，都会有一个函数<code>_PyImport_FixupBuiltin();</code>，这个函数是用来备份的。</p>
<p>因为<code>interp-&gt;modules</code>维护的是一个字典，属于可变对象，所以其中的<code>&lt;模块名，模块对象&gt;</code>很容易被删除。Python为了避免在元素删除时再次初始化模块，会将所有的扩展module通过一个全局的字典对象来进行备份维护，其调用的是<code>_PyImport_FixupExtensionObject</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *extensions = <span class="literal">NULL</span>; <span class="comment">/* 一个全局的字典对象 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_PyImport_FixupBuiltin(PyObject *mod, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    PyObject *nameobj;</span><br><span class="line">    nameobj = PyUnicode_InternFromString(name);</span><br><span class="line">    res = _PyImport_FixupExtensionObject(mod, nameobj, nameobj);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_PyImport_FixupExtensionObject(PyObject *mod, PyObject *name,</span><br><span class="line">                               PyObject *filename)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *modules, *dict, *key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> *<span class="title">def</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (extensions == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        extensions = PyDict_New(); <span class="comment">/* 如果没有创建，则创建字典*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    def = PyModule_GetDef(mod); <span class="comment">/* 抽取module中的PyModuleDef */</span></span><br><span class="line">    modules = PyImport_GetModuleDict(); <span class="comment">/* 获取interp-&gt;modules */</span></span><br><span class="line">    <span class="keyword">if</span> (PyDict_SetItem(modules, name, mod) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_PyState_AddModule(mod, def) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyDict_DelItem(modules, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (def-&gt;m_size == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (def-&gt;m_base.m_copy) &#123;</span><br><span class="line">            <span class="comment">/* Somebody already imported the module,</span></span><br><span class="line"><span class="comment">               likely under a different name.</span></span><br><span class="line"><span class="comment">               XXX this should really not happen. */</span></span><br><span class="line">            Py_CLEAR(def-&gt;m_base.m_copy);</span><br><span class="line">        &#125;</span><br><span class="line">        dict = PyModule_GetDict(mod); <span class="comment">/* 抽取md_dict */</span></span><br><span class="line">        def-&gt;m_base.m_copy = PyDict_Copy(dict); <span class="comment">/* 复制dict */</span></span><br><span class="line">    &#125;</span><br><span class="line">    key = PyTuple_Pack(<span class="number">2</span>, filename, name); <span class="comment">/* 把名称打包作为键 */</span></span><br><span class="line">    res = PyDict_SetItem(extensions, key, (PyObject *)def); <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Python中<code>interp-&gt;modules</code>集合中某个扩展被删除后又被重新加载时, 就不需要再次为其初始化了。只需要用<code>extensions</code>中备份的<code>PyModuleDef</code>来创建一个新的<code>module</code>对象即可。</p>
<h3 id="设置模块搜索路径"><a href="#设置模块搜索路径" class="headerlink" title="设置模块搜索路径"></a>设置模块搜索路径</h3><p>当我们在Python中尝试导入模块时，就涉及到了一个叫”模块搜索路径“的概念，在虚拟机启动是通过下面的函数进行设置的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">PySys_SetPath(Py_GetPath());</span><br></pre></td></tr></table></figure></p>
<p>下面是<code>PySys_SetPath</code>的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">PySys_SetPath(<span class="keyword">const</span> <span class="keyword">wchar_t</span> *path)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    <span class="keyword">if</span> ((v = makepathobject(path, DELIM)) == <span class="literal">NULL</span>) <span class="comment">/* 创建路径对象 */</span></span><br><span class="line">        Py_FatalError(<span class="string">"can't create sys.path"</span>);</span><br><span class="line">    <span class="keyword">if</span> (_PySys_SetObjectId(&amp;PyId_path, v) != <span class="number">0</span>) <span class="comment">/* 设置路径对象到sysdict中 */</span></span><br><span class="line">        Py_FatalError(<span class="string">"can't assign sys.path"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_PySys_SetObjectId(_Py_Identifier *key, PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = PyThreadState_GET();</span><br><span class="line">    PyObject *sd = tstate-&gt;interp-&gt;sysdict;</span><br><span class="line">    <span class="keyword">return</span> _PyDict_SetItemId(sd, key, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里省略了路径的查找和路径对象的构建过程，在设置路径的过程中，Python将通过<code>makepathobject</code>构建的路径对象(一个列表)设置到了<code>interp-&gt;sysdict</code>中，而这个指针恰恰指向<code>sys</code>模块的<code>md_dict</code>域，所以我们在Python中敲入<code>sys.path</code>能够获得那个路径集合。</p>
<p>在设置好搜索路径之后，虚拟机还进行了许多琐碎的初始化工作，例如：<code>import</code>机制初始化，异常环境初始化，输出环境和编码器等等。</p>
<h3 id="main模块"><a href="#main模块" class="headerlink" title="main模块"></a>main模块</h3><p>另外，除了上面的<code>builtins</code>模块和<code>sys</code>模块外，虚拟机还有创建了一个特殊的模块：<code>__main__</code>模块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">initmain(PyInterpreterState *interp)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *loader, *ann_dict;</span><br><span class="line">    m = PyImport_AddModule(<span class="string">"__main__"</span>); <span class="comment">/* 创建名为__main__的模块 */</span></span><br><span class="line">    d = PyModule_GetDict(m); <span class="comment">/* 抽取md_dict*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PyDict_GetItemString(d, <span class="string">"__builtins__"</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PyObject *bimod = PyImport_ImportModule(<span class="string">"builtins"</span>);</span><br><span class="line">        PyDict_SetItemString(d, <span class="string">"__builtins__"</span>, bimod） <span class="comment">/* 将__builtins__模块插入到dict中 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>initmain</code>中，虚拟机先是创建了一个名为<code>__mian__</code>的模块，并将<code>__builtins__</code>添加到了该模块的<code>md_dict</code>中了。</p>
<p>在Python中，我们经常写<code>if __name__ == __main__</code>和这又有什么关系呢？</p>
<p>实际上，在以<code>python *.py</code>这种方式执行Python文件时，Python会沿着命名空间查找<code>__name__</code>，最后它会在<code>__main__</code>模块中，找到<code>__name__</code>对应的值是<code>__main__</code>。不过奇怪的是为什么会找到<code>__main__</code>模块的命名空间呢，不是还有<code>__builtin__</code>模块吗？这一点在下面的“命名空间”一节中有讲到。</p>
<h3 id="site-packages"><a href="#site-packages" class="headerlink" title="site-packages"></a>site-packages</h3><p>这是一个特殊的目录，我们的安装的第三方库一般都放置在这个目录里，所以也就要求这个路径需要添加到Python的”搜索路径“中去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Py_NoSiteFlag)</span><br><span class="line">   initsite(); <span class="comment">/* Module site */</span></span><br></pre></td></tr></table></figure>
<p>下面是它的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">initsite(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m;</span><br><span class="line">    m = PyImport_ImportModule(<span class="string">"site"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设计到了Python的<code>import</code>机制，这里先跳过不讲，只需要知道<code>PyImport_ImportModule</code>会导入一个叫<code>site</code>的模块，这个模块位于<code>%PythonHome%\Lib\site.py</code>。</p>
<p>在<code>site</code>模块中，Python做的事情就是：</p>
<ul>
<li>将<code>site-packages</code>路径加入到<code>sys.path</code>中</li>
<li>另一个就是处理<code>site-packages</code>目录下的所有<code>.pth</code>文件中的所有路径添加到<code>sys.path</code>中</li>
</ul>
<p>到现在为止，Python中绝大部分的初始化动作都已经完毕，下面是初始化后的内存分布情况：</p>
<h2 id="激活虚拟机"><a href="#激活虚拟机" class="headerlink" title="激活虚拟机"></a>激活虚拟机</h2><p>Python有两种运行方式，一是命令行下的交互环境；二是以脚本执行的方式。这两种方式都会在<code>Py_Initialize</code>之后调用<code>PyRun_AnyFileFlags</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Modules/main.c]</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">Py_Main(<span class="keyword">int</span> argc, <span class="keyword">wchar_t</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    Py_Initialize(); <span class="comment">/* 初始化 */</span></span><br><span class="line">    ......</span><br><span class="line">    run = PyRun_AnyFileExFlags(fp, filename_str, filename != <span class="literal">NULL</span>, p_cf);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是以脚本方式执行，那么<code>fp</code>就是脚本文件，<code>filename_str</code>就是文件名，而<code>p_cf</code>是Python的编译参数；<br><br>如果是以交互式环境下执行，那么<code>fp</code>就是<code>stdin</code>输入流，而<code>filename_str</code>就是<code>&lt;stdin&gt;</code>。</p>
<p>最后在函数<code>PyRun_AnyFileExFlags</code>中会对两种方式进行分流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">PyRun_AnyFileExFlags(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> closeit,</span><br><span class="line">                     PyCompilerFlags *flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename == <span class="literal">NULL</span>)</span><br><span class="line">        filename = <span class="string">"???"</span>;</span><br><span class="line">    <span class="comment">/* 判断，分流 */</span></span><br><span class="line">    <span class="keyword">if</span> (Py_FdIsInteractive(fp, filename)) &#123;</span><br><span class="line">        <span class="keyword">int</span> err = PyRun_InteractiveLoopFlags(fp, filename, flags);</span><br><span class="line">        <span class="keyword">if</span> (closeit)</span><br><span class="line">            fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> PyRun_SimpleFileExFlags(fp, filename, closeit, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python使用<code>Py_FdIsInteractive</code>判断输入是否是标准输入流，如果是，则代表着交互式运行环境，那么进入<code>PyRun_InteractiveLoopFlags</code>，否则使用<code>PyRun_SimpleFileExFlags</code>进行执行处理。</p>
<h3 id="交互式环境"><a href="#交互式环境" class="headerlink" title="交互式环境"></a>交互式环境</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">PyRun_InteractiveLoopFlags(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename_str, PyCompilerFlags *flags)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *filename, *v;</span><br><span class="line">    <span class="keyword">int</span> ret, err;</span><br><span class="line">    PyCompilerFlags local_flags;</span><br><span class="line">    <span class="keyword">int</span> nomem_count = <span class="number">0</span>;</span><br><span class="line">    filename = PyUnicode_DecodeFSDefault(filename_str); <span class="comment">/* 文件名 */</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 创建交互式提示符“&gt;&gt;&gt; ” */</span></span><br><span class="line">    v = _PySys_GetObjectId(&amp;PyId_ps1);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PySys_SetObjectId(&amp;PyId_ps1, v = PyUnicode_FromString(<span class="string">"&gt;&gt;&gt; "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 创建交互式提示符“... ” */</span></span><br><span class="line">    v = _PySys_GetObjectId(&amp;PyId_ps2);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _PySys_SetObjectId(&amp;PyId_ps2, v = PyUnicode_FromString(<span class="string">"... "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;<span class="comment">/* 进入交互式环境 */</span></span><br><span class="line">        ret = PyRun_InteractiveOneObjectEx(fp, filename, flags);</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret != E_EOF);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是在交互式运行环境下，虚拟机会在一个<code>loop</code>中循环执行。下面是<code>PyRun_InteractiveOneObjectEx</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">PyRun_InteractiveOneObjectEx(FILE *fp, PyObject *filename,</span><br><span class="line">                             PyCompilerFlags *flags)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *v, *w, *oenc = <span class="literal">NULL</span>, *mod_name;</span><br><span class="line">    mod_ty mod;</span><br><span class="line">    PyArena *arena;</span><br><span class="line">    <span class="keyword">char</span> *ps1 = <span class="string">""</span>, *ps2 = <span class="string">""</span>, *enc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> errcode = <span class="number">0</span>;</span><br><span class="line">    _Py_IDENTIFIER(__main__);</span><br><span class="line"></span><br><span class="line">    mod_name = _PyUnicode_FromId(&amp;PyId___main__); <span class="comment">/* borrowed */</span></span><br><span class="line">    ......</span><br><span class="line">    v = _PySys_GetObjectId(&amp;PyId_ps1);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        v = PyObject_Str(v);</span><br><span class="line">        ps1 = PyUnicode_AsUTF8(v);</span><br><span class="line">    &#125;</span><br><span class="line">    w = _PySys_GetObjectId(&amp;PyId_ps2);</span><br><span class="line">    <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        w = PyObject_Str(w);</span><br><span class="line">        ps2 = PyUnicode_AsUTF8(w);</span><br><span class="line">    &#125;</span><br><span class="line">    arena = PyArena_New();</span><br><span class="line">    mod = PyParser_ASTFromFileObject(fp, filename, enc,</span><br><span class="line">                                     Py_single_input, ps1, ps2,</span><br><span class="line">                                     flags, &amp;errcode, arena); <span class="comment">/* 构造抽象语法树AST */</span></span><br><span class="line">    m = PyImport_AddModuleObject(mod_name); <span class="comment">/* 导入__main__模块 */</span></span><br><span class="line">    d = PyModule_GetDict(m); <span class="comment">/* 抽取main模块的md_dict */</span></span><br><span class="line">    v = run_mod(mod, filename, d, d, flags, arena); <span class="comment">/* 执行用户输入的Python语句 */</span></span><br><span class="line">    PyArena_Free(arena);</span><br><span class="line">    flush_io();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>PyRun_InteractiveOneObjectEx</code>中调用<code>PyParser_ASTFromFileObject</code>对交互式环境下的用户输入Python语句进行编译， 其结果是结构与Python语句一样的抽象语法树<code>AST</code>。调用<code>run_mod</code>将最终完成对输入语句的执行。这里的参数<code>d</code>就将作为当前活动的<code>frame</code>对象的<code>locals</code>名字空间和<code>globals</code>名字空间。</p>
<h3 id="脚本方式执行"><a href="#脚本方式执行" class="headerlink" title="脚本方式执行"></a>脚本方式执行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">PyRun_SimpleFileExFlags(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> closeit,</span><br><span class="line">                        PyCompilerFlags *flags)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *m, *d, *v;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ext;</span><br><span class="line">    <span class="keyword">int</span> set_file_name = <span class="number">0</span>, ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    m = PyImport_AddModule(<span class="string">"__main__"</span>); <span class="comment">/* 导入main模块 */</span></span><br><span class="line">   </span><br><span class="line">    d = PyModule_GetDict(m);</span><br><span class="line">    <span class="keyword">if</span> (PyDict_GetItemString(d, <span class="string">"__file__"</span>) == <span class="literal">NULL</span>) &#123; .<span class="comment">/* 设置”__file__“属性 */</span></span><br><span class="line">        PyObject *f;</span><br><span class="line">        f = PyUnicode_DecodeFSDefault(filename);</span><br><span class="line">        yDict_SetItemString(d, <span class="string">"__file__"</span>, f)</span><br><span class="line">        set_file_name = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">strlen</span>(filename);</span><br><span class="line">    ext = filename + len - (len &gt; <span class="number">4</span> ? <span class="number">4</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (maybe_pyc_file(fp, filename, ext, closeit)) &#123; <span class="comment">/* 尝试从pyc文件执行 */</span></span><br><span class="line">        ......</span><br><span class="line">        v = run_pyc_file(pyc_fp, filename, d, d, flags);</span><br><span class="line">        fclose(pyc_fp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 如果是py文件 */</span></span><br><span class="line">        ......</span><br><span class="line">        v = PyRun_FileExFlags(fp, filename, Py_file_input, d, d,</span><br><span class="line">                              closeit, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">PyRun_FileExFlags(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename_str, <span class="keyword">int</span> start, PyObject *globals,</span><br><span class="line">                  PyObject *locals, <span class="keyword">int</span> closeit, PyCompilerFlags *flags)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *ret = <span class="literal">NULL</span>;</span><br><span class="line">    mod_ty mod;</span><br><span class="line">    PyArena *arena = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *filename;</span><br><span class="line">    filename = PyUnicode_DecodeFSDefault(filename_str);</span><br><span class="line">    mod = PyParser_ASTFromFileObject(fp, filename, <span class="literal">NULL</span>, start, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">/* 构造抽象语法树AST */</span></span><br><span class="line">                                     flags, <span class="literal">NULL</span>, arena); </span><br><span class="line">    ret = run_mod(mod, filename, globals, locals, flags, arena); <span class="comment">/* 执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以脚本的方式和交互式运行环境相似，输入都会经过编译后，传入<code>run_mod</code>执行，将<code>main</code>模块的<code>md_dict</code>作为<code>locals</code>命名空间和<code>globals</code>命名空间传入。</p>
<h3 id="run-mod"><a href="#run-mod" class="headerlink" title="run_mod"></a>run_mod</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">run_mod(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,</span><br><span class="line">            PyCompilerFlags *flags, PyArena *arena)</span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    co = PyAST_CompileObject(mod, filename, flags, <span class="number">-1</span>, arena); <span class="comment">/* 编译 */</span></span><br><span class="line">    v = PyEval_EvalCode((PyObject*)co, globals, locals); <span class="comment">/* 执行 */</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>run_mod</code>开始，虚拟机会通过传入的抽象语法树<code>AST</code>编译字节码指令序列，创建<code>PyCodeObject</code>，最后调用<code>PyEval_EvalCode</code>创建新的栈桢执行字节码对象。又回到了熟悉的地方。。。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>虚拟机在执行字节码的过程中，创建了<code>PyFrameObject</code>设置了三个命名空间：<code>locals</code>，<code>globals</code>和<code>builtins</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PyFrameObject *</span><br><span class="line">PyFrame_New(PyThreadState *tstate, PyCodeObject *code, PyObject *globals,</span><br><span class="line">            PyObject *locals)</span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *back = tstate-&gt;frame;</span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    PyObject *builtins;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    <span class="comment">/* builtins命名空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (back == <span class="literal">NULL</span> || back-&gt;f_globals != globals) &#123;<span class="comment">/* 尝试从main模块的dict中获取__builtin__模块 */</span></span><br><span class="line">        builtins = _PyDict_GetItemId(globals, &amp;PyId___builtins__); </span><br><span class="line">        builtins = PyModule_GetDict(builtins); <span class="comment">/* builtins命名空间就是builtin模块的md_dict */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        builtins = back-&gt;f_builtins; <span class="comment">/* 继承上一个栈桢的builtis命名空间 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;f_builtins = builtins; </span><br><span class="line">    f-&gt;f_back = back;</span><br><span class="line">    <span class="comment">/* globals命名空间 */</span></span><br><span class="line">    f-&gt;f_globals = globals;</span><br><span class="line">    <span class="comment">/* locals命名空间 */</span></span><br><span class="line">    <span class="keyword">if</span> ((code-&gt;co_flags &amp; (CO_NEWLOCALS | CO_OPTIMIZED)) ==</span><br><span class="line">        (CO_NEWLOCALS | CO_OPTIMIZED))</span><br><span class="line">        ; <span class="comment">/* f_locals = NULL; 函数调用，不需要locals命名空间 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (code-&gt;co_flags &amp; CO_NEWLOCALS) &#123;</span><br><span class="line">        locals = PyDict_New();</span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (locals == <span class="literal">NULL</span>)</span><br><span class="line">            locals = globals; <span class="comment">/* 一般情况，locals和globals指向同一dict */</span></span><br><span class="line">        f-&gt;f_locals = locals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以主模块的方式运行的化，虚拟机传入的<code>locals</code>和<code>globals</code>命名空间都是<code>main</code>模块的<code>md_dict</code>，所以<code>__name__</code>直接就会在<code>locals</code>命名空间找到，不会命中<code>builtins</code>命名空间。</p>
<p>在新创建的栈桢对象，它的builtins命名空间就是<code>__builtin__</code>模块的<code>md_dict</code>，所以我们能够直接在Python中使用这些内置的对象。同时也意味着：Python的所有线程共享同样的builtin名字空间。</p>

    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持作者</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/posts/89298142/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/posts/691b6e2d/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

  <div id="gitment-comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    (function () {
      var gitment = new Gitment({
        owner: 'zhongshangwu',
        repo: 'https://github.com/zhongshangwu/zhongshangwu.github.io',
        oauth: {
          client_id: 'ecb8413d71a24ae7e38a',
          client_secret: '6aacbb72400e02734e754fce4b6204ae07ec9dc2'
        },
        
        
        
        
        
        
        
        
      })
      gitment.render('gitment-comments')
    })()
  </script>



    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
