<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Python源码阅读-垃圾回收机制 | Shawn&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Python,源码," />
  

  <meta name="description" content="Python中的垃圾回收在Python中, 主要的内存管理手段是引用计数, 而标记-清除算法和分代收集机制是为了打破循环引用而补充的技术. 引用计数法经过前面的探索, 我们知道在所有Python对象头部都有着一个计数器, 如果对象的引用增加, 则计数器加一, 反之减一. 所以在Python中, 有两个宏定义来操作这个计数器:">
<meta name="keywords" content="Python,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Python源码阅读-垃圾回收机制">
<meta property="og:url" content="http://shawnz.me/posts/19171030/index.html">
<meta property="og:site_name" content="Shawn&#39;s Blog">
<meta property="og:description" content="Python中的垃圾回收在Python中, 主要的内存管理手段是引用计数, 而标记-清除算法和分代收集机制是为了打破循环引用而补充的技术. 引用计数法经过前面的探索, 我们知道在所有Python对象头部都有着一个计数器, 如果对象的引用增加, 则计数器加一, 反之减一. 所以在Python中, 有两个宏定义来操作这个计数器:">
<meta property="og:image" content="http://shawnz.me/images/pygc-1.png">
<meta property="og:image" content="http://shawnz.me/images/pygc-2.png">
<meta property="og:image" content="http://shawnz.me/images/pygc-3.png">
<meta property="og:updated_time" content="2018-03-10T06:20:54.198Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python源码阅读-垃圾回收机制">
<meta name="twitter:description" content="Python中的垃圾回收在Python中, 主要的内存管理手段是引用计数, 而标记-清除算法和分代收集机制是为了打破循环引用而补充的技术. 引用计数法经过前面的探索, 我们知道在所有Python对象头部都有着一个计数器, 如果对象的引用增加, 则计数器加一, 反之减一. 所以在Python中, 有两个宏定义来操作这个计数器:">
<meta name="twitter:image" content="http://shawnz.me/images/pygc-1.png">

  

  
    <link rel="icon" href="/favicon.png">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/custom.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python中的垃圾回收"><span class="toc-text">Python中的垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用计数法"><span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器对象"><span class="toc-text">容器对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#追踪容器对象"><span class="toc-text">追踪容器对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分代容器对象链表"><span class="toc-text">分代容器对象链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标记–清除算法"><span class="toc-text">标记–清除算法</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Python源码阅读-垃圾回收机制" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Python源码阅读-垃圾回收机制</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.01.20</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Shawn Zhong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="Python中的垃圾回收"><a href="#Python中的垃圾回收" class="headerlink" title="Python中的垃圾回收"></a>Python中的垃圾回收</h2><p>在Python中, 主要的内存管理手段是引用计数, 而标记-清除算法和分代收集机制是为了打破循环引用而补充的技术.</p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>经过前面的探索, 我们知道在所有Python对象头部都有着一个计数器, 如果对象的引用增加, 则计数器加一, 反之减一. 所以在Python中, 有两个宏定义来操作这个计数器:</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_INCREF(op) (                         \ <span class="comment">/* 增量计数 */</span></span></span><br><span class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span><br><span class="line">    ((PyObject *)(op))-&gt;ob_refcnt++)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_DECREF(op)                                   \ <span class="comment">/* 减量计数 */</span></span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                \</span><br><span class="line">        PyObject *_py_decref_tmp = (PyObject *)(op);    \</span><br><span class="line">        <span class="keyword">if</span> (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span><br><span class="line">        --(_py_decref_tmp)-&gt;ob_refcnt != <span class="number">0</span>)             \</span><br><span class="line">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span><br><span class="line">        <span class="keyword">else</span>                                            \</span><br><span class="line">            _Py_Dealloc(_py_decref_tmp);                \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>此外, 还提供了针对<code>NULL</code>检查的宏:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_XINCREF(op)                                \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                              \</span><br><span class="line">        PyObject *_py_xincref_tmp = (PyObject *)(op); \</span><br><span class="line">        <span class="keyword">if</span> (_py_xincref_tmp != <span class="literal">NULL</span>)                  \</span><br><span class="line">            Py_INCREF(_py_xincref_tmp);               \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_XDECREF(op)                                \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                              \</span><br><span class="line">        PyObject *_py_xdecref_tmp = (PyObject *)(op); \</span><br><span class="line">        <span class="keyword">if</span> (_py_xdecref_tmp != <span class="literal">NULL</span>)                  \</span><br><span class="line">            Py_DECREF(_py_xdecref_tmp);               \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>另外, 在减少引用计数器的时候, 我们发现有一个宏<code>_Py_Dealloc</code>, 这个宏负责调用对象的<code>tp_dealloc</code>函数释放对象:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Py_Dealloc(op) (                               \</span></span><br><span class="line">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</span><br></pre></td></tr></table></figure>
<p>而在<code>tp_dealloc</code>中又会调用<code>tp_free</code>, 这个函数指针一般都是<code>PyObject_GC_Del</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">PyObject_GC_Del(<span class="keyword">void</span> *op)</span><br><span class="line">&#123;</span><br><span class="line">    PyGC_Head *g = AS_GC(op);</span><br><span class="line">    <span class="comment">/* ... 省略部分释放前的处理 */</span></span><br><span class="line">    PyObject_FREE(g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终, 回到了我们在上一节中讲到的<code>PyObject_FREE</code>, 释放分配的内存.</p>
<p>所以引用计数的减量操作是这么一个流程:</p>
<blockquote>
<p><code>Py_DECREF -&gt; _PyDealloc -&gt; tp_dealloc -&gt; tp_free -&gt; PyObject_GC_Del -&gt; PyObject_FREE -&gt; PyObject_Free</code></p>
</blockquote>
<!-- 对于计数器, 我们还需要关注的一个问题是: 计数器溢出. -->
<h2 id="容器对象"><a href="#容器对象" class="headerlink" title="容器对象"></a>容器对象</h2><p>并不是所有Python对象会发生循环引用, 只有那些可能保留了其它对象引用的对象, 才可能发生循环引用, 关于这类对象我们称之为”容器对象”.</p>
<p>循环引用垃圾回收的对象只有这些容器对象. Python对于这些容器对象都分配了用于循环引用垃圾回收的结构体头, 这个头部包含一下信息:</p>
<ul>
<li>用于容器对象的双向链表的成员;</li>
<li>用于复制引用计数器的成员;</li>
</ul>
<p>其定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[objimpl.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _gc_head &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">union</span> _gc_head *gc_next; <span class="comment">/* 用于双向链表 */</span></span><br><span class="line">        <span class="keyword">union</span> _gc_head *gc_prev; <span class="comment">/* 用于双向链表 */</span></span><br><span class="line">        Py_ssize_t gc_refs; <span class="comment">/* 用于复制 */</span></span><br><span class="line">    &#125; gc;</span><br><span class="line">    <span class="keyword">double</span> dummy;  <span class="comment">/* force worst-case alignment */</span></span><br><span class="line">&#125; PyGC_Head;</span><br></pre></td></tr></table></figure>
<p>其中<code>dummy</code>的作用是: 即使结构体<code>gc</code>的大小为<code>9</code>字节这样不上不下的数值, <code>dummy</code>也可以将整个结构体<code>PyGC_Head</code>对齐为<code>long double</code>型.</p>
<p>在Python中, 创建容器对象和创建普通对象的内存分布是不一样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[gcmodule.c]</span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_GC_New(PyTypeObject *tp)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *op = _PyObject_GC_Malloc(_PyObject_SIZE(tp));</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>)</span><br><span class="line">        op = PyObject_INIT(op, tp);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生成容器对象的时候, 必须通过<code>_PyObject_GC_Malloc</code>分配用于循环引用垃圾回收的头:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyGC_REFS_UNTRACKED                    (-2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GC_UNTRACKED                    _PyGC_REFS_UNTRACKED</span></span><br><span class="line"></span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_GC_Malloc(<span class="keyword">size_t</span> basicsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _PyObject_GC_Alloc(<span class="number">0</span>, basicsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">_PyObject_GC_Alloc(<span class="keyword">int</span> use_calloc, <span class="keyword">size_t</span> basicsize)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *op;</span><br><span class="line">    PyGC_Head *g;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(PyGC_Head) + basicsize; <span class="comment">/* 为PyGC_Head和对象本身分配内存 */</span></span><br><span class="line">    g = (PyGC_Head *)PyObject_Malloc(size);</span><br><span class="line">    g-&gt;gc.gc_refs = <span class="number">0</span>;</span><br><span class="line">    _PyGCHead_SET_REFS(g, GC_UNTRACKED); </span><br><span class="line">    <span class="comment">/* 开始进行循环引用垃圾回收 */</span></span><br><span class="line">    generations[<span class="number">0</span>].count++; <span class="comment">/* number of allocated GC objects */</span></span><br><span class="line">    <span class="keyword">if</span> (generations[<span class="number">0</span>].count &gt; generations[<span class="number">0</span>].threshold &amp;&amp;</span><br><span class="line">        enabled &amp;&amp;</span><br><span class="line">        generations[<span class="number">0</span>].threshold &amp;&amp;</span><br><span class="line">        !collecting &amp;&amp;</span><br><span class="line">        !PyErr_Occurred()) &#123;</span><br><span class="line">        collecting = <span class="number">1</span>;</span><br><span class="line">        collect_generations();</span><br><span class="line">        collecting = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    op = FROM_GC(g);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的<code>_PyObject_GC_Malloc</code>可以看到, 对于容器对象, 在分配内存的时, 也为<code>PyGC_Head</code>分配了内存, 其位置位于容器对象之前.</p>
<p>在<code>GC_Head</code>部分, 除了用于构建双向链表的两个指针, 还通过<code>_PyGCHead_SET_REFS(g, GC_UNTRACKED);</code>将<code>GC_UNTRACKED</code>设置到了<code>gc_refs</code>域上. 这个标志(<code>-2</code>)的意思是”这个容器对象还没有被追踪”, 当出现这个标志<code>GC</code>会认为这个容器对象还没有被连接到容器对象链表上. 关于这部分在后面还会讲到.</p>
<p>所以经过这些后, 容器对象的内存分布应该如下:</p>
<p><img src="/images/pygc-1.png" alt=""></p>
<p>从图中, 我们可以发现一个问题, 那就是这些容器对象的头部有单独的一部分<code>PyGC_Head</code>, 但是在Python内部, 传递的是<code>*PyObject</code>指针. 这也就意味着需要我们在<code>PyGC_Head</code>和<code>PyObject_Head</code>之间进行地址转换, 而<code>FROM_GC</code>恰恰是将<code>PyGC_Head</code>转换成<code>PyObject_Head</code>的宏定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get an object's GC head */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AS_GC(o) ((PyGC_Head *)(o)-1)</span></span><br><span class="line"><span class="comment">/* Get the object given the GC head */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FROM_GC(g) ((PyObject *)(((PyGC_Head *)g)+1))</span></span><br></pre></td></tr></table></figure>
<p>上面两个转换算法, 隐性要求<code>PyGC_Head</code>大小对齐, 如果<code>PyGC_Head</code>的大小没有对齐, 那么<code>FROM_GC</code>返回的地址也是对齐不上的.</p>
<h2 id="追踪容器对象"><a href="#追踪容器对象" class="headerlink" title="追踪容器对象"></a>追踪容器对象</h2><p>为了释放循环引用, 需要将容器对象用双向链表连接起来. 不过在上面的内存分配过程中, 我们讲到<code>GC_UNTRACKED</code>标识着这个容器对象还没有被追踪, 那么就需要有个地方将容器对象加入双向链表中. 我们可以以列表对象的创建, 来看看容器对象是什么时候开始被追踪的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyList_New(Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    PyListObject *op;</span><br><span class="line">    ...</span><br><span class="line">    op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">    ...</span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建<code>list</code>对象的最后, 会通过<code>_PyObject_GC_TRACK</code>宏连接容器对象链表:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_GC_TRACK(o) do &#123; \</span></span><br><span class="line">    PyGC_Head *g = _Py_AS_GC(o); \</span><br><span class="line">    <span class="keyword">if</span> (_PyGCHead_REFS(g) != _PyGC_REFS_UNTRACKED) \</span><br><span class="line">        Py_FatalError(<span class="string">"GC object already tracked"</span>); \</span><br><span class="line">    _PyGCHead_SET_REFS(g, _PyGC_REFS_REACHABLE); \</span><br><span class="line">    g-&gt;gc.gc_next = _PyGC_generation0; \</span><br><span class="line">    g-&gt;gc.gc_prev = _PyGC_generation0-&gt;gc.gc_prev; \</span><br><span class="line">    g-&gt;gc.gc_prev-&gt;gc.gc_next = g; \</span><br><span class="line">    _PyGC_generation0-&gt;gc.gc_prev = g; \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这个宏有一点需要注意的是<code>do while</code>结构不是为了循环, 只是写宏的小技巧. 这个宏的过程可以概述为:</p>
<ul>
<li>首先从对象取出<code>PyGC_Head</code>的头地址;</li>
<li>接下来将标识<code>_PyGC_REFS_REACHABLE</code>设置到<code>PyGC_Head</code>的<code>gc_refs</code>域, 表示”程序可能达到的对象”;</li>
<li>最后拿出了连接所有容器对象的全局链表, 把这个对象加入到了链表中.</li>
</ul>
<p>循环引用垃圾回收正是利用这个全局链表来释放循环引用的对象.</p>
<p>和追踪容器对象对应的, 有一个宏用于结束追踪容器对象: <code>_PyObject_GC_UNTRACK</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_GC_UNTRACK(o) do &#123; \</span></span><br><span class="line">    PyGC_Head *g = _Py_AS_GC(o); \</span><br><span class="line">    _PyGCHead_SET_REFS(g, _PyGC_REFS_UNTRACKED); \</span><br><span class="line">    g-&gt;gc.gc_prev-&gt;gc.gc_next = g-&gt;gc.gc_next; \</span><br><span class="line">    g-&gt;gc.gc_next-&gt;gc.gc_prev = g-&gt;gc.gc_prev; \</span><br><span class="line">    g-&gt;gc.gc_next = <span class="literal">NULL</span>; \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_GC_IS_TRACKED(o) \</span></span><br><span class="line">    (_PyGC_REFS(o) != _PyGC_REFS_UNTRACKED)</span><br></pre></td></tr></table></figure>
<p>如果理解了上面的追踪容器对象, 那么这个宏也会十分容易理解: 标识容器对象未被追踪, 并将它从全局的容器对象链表中移除.</p>
<p>另外, Python还提供了一个宏<code>_PyObject_GC_IS_TRACKED</code>, 用于检查容器对象是否被追踪.</p>
<p>对于这个全局的容器对象链表, 我们可以画个图表示:</p>
<p><img src="/images/pygc-2.png" alt=""></p>
<h2 id="分代容器对象链表"><a href="#分代容器对象链表" class="headerlink" title="分代容器对象链表"></a>分代容器对象链表</h2><p>Python的容器对象链表被分为3代, 每一代都代表前面提到的一条容器对象链表. 为了引入分代机制, 需要增加一个额外的表头:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[gcmodule.c]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gc_generation</span> &#123;</span></span><br><span class="line">    PyGC_Head head;</span><br><span class="line">    <span class="keyword">int</span> threshold; <span class="comment">/* 开始GC的阀值 */</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">/* 该代的对象数量 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>容器对象将被连接到成员<code>head</code>, 当<code>count</code>成员数量超过<code>threshold</code>阀值时, Python就对这一代开启<code>GC</code>. Python通过一个全局变量来初始化各代的容器链表:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_GENERATIONS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEN_HEAD(n) (&amp;generations[n].head)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gc_generation</span> <span class="title">generations</span>[<span class="title">NUM_GENERATIONS</span>] = &#123;</span></span><br><span class="line">    <span class="comment">/* PyGC_Head,                               threshold,      count */</span></span><br><span class="line">    &#123;&#123;&#123;GEN_HEAD(<span class="number">0</span>), GEN_HEAD(<span class="number">0</span>), <span class="number">0</span>&#125;&#125;,           <span class="number">700</span>,            <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;&#123;&#123;GEN_HEAD(<span class="number">1</span>), GEN_HEAD(<span class="number">1</span>), <span class="number">0</span>&#125;&#125;,           <span class="number">10</span>,             <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;&#123;&#123;GEN_HEAD(<span class="number">2</span>), GEN_HEAD(<span class="number">2</span>), <span class="number">0</span>&#125;&#125;,           <span class="number">10</span>,             <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyGC_Head *_PyGC_generation0 = GEN_HEAD(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>各代的<code>PyGC_Head</code>, 双向链表都是以引用自身的形式初始化的, <code>_PyGC_generation0</code>指向0代容器对象链表.</p>
<p><img src="/images/pygc-3.png" alt=""></p>
<p>一开始所有刚创建的容器对象都被连接到0代链表上, 在<code>_PyObject_GC_Malloc</code>分配内存中, 会通过<code>generations[0].count++;</code>增加第0代所维护的链表的元素数量(这个<code>count</code>的增加被提前到追踪容器对象之前), 一旦这个<code>count</code>超过了<code>threshold</code>阀值, 就会触发<code>GC</code>. 从新生代到老生代, 只有经过循环引用垃圾回收存活下来的对象, 才能晋升.</p>
<p>当第0代的对象数量超过阀值后(没有禁用<code>GC</code>/没有正在<code>GC</code>/没有发生<code>GC</code>错误), 就会触发<code>collect_generations</code>: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Py_ssize_t</span><br><span class="line">collect_generations(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Py_ssize_t n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = NUM_GENERATIONS<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (generations[i].count &gt; generations[i].threshold) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == NUM_GENERATIONS - <span class="number">1</span></span><br><span class="line">                &amp;&amp; long_lived_pending &lt; long_lived_total / <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            n = collect_with_callback(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个函数我们可以看出来, Python的GC是通过第0代容器对象链表触发的. 在<code>collect_generations</code>中, 会找到超过阀值的”最老”的一代, 然后开始回收这一代的内存.</p>
<p>需要注意关于<code>long-lived objects</code>, 这在注释中有解释:</p>
<p>pass</p>
<h2 id="标记–清除算法"><a href="#标记–清除算法" class="headerlink" title="标记–清除算法"></a>标记–清除算法</h2><p>这是正式进入到Python的垃圾回收, 位于<code>collect_with_callback</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Py_ssize_t</span><br><span class="line">collect_with_callback(<span class="keyword">int</span> generation)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t result, collected, uncollectable;</span><br><span class="line">    invoke_gc_callback(<span class="string">"start"</span>, generation, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    result = collect(generation, &amp;collected, &amp;uncollectable, <span class="number">0</span>);</span><br><span class="line">    invoke_gc_callback(<span class="string">"stop"</span>, generation, collected, uncollectable);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正进行垃圾回收的是<code>collect</code>, 而<code>collect_with_callback</code>的作用是: 在之前和之后调用<code>callback</code>通知客户端垃圾回收开始或停止.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> Py_ssize_t</span><br><span class="line">collect(<span class="keyword">int</span> generation, Py_ssize_t *n_collected, Py_ssize_t *n_uncollectable,</span><br><span class="line">        <span class="keyword">int</span> nofail)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Py_ssize_t m = <span class="number">0</span>; <span class="comment">/* # objects collected */</span></span><br><span class="line">    Py_ssize_t n = <span class="number">0</span>; <span class="comment">/* # unreachable objects that couldn't be collected */</span></span><br><span class="line">    PyGC_Head *young; <span class="comment">/* 即将查找的一代 */</span></span><br><span class="line">    PyGC_Head *old; <span class="comment">/* 下一代 */</span></span><br><span class="line">    PyGC_Head unreachable; <span class="comment">/* 无异样不能到达对象的链表 */</span></span><br><span class="line">    PyGC_Head finalizers;  <span class="comment">/* objects with, &amp; reachable from, __del__ */</span></span><br><span class="line">    PyGC_Head *gc;</span><br><span class="line">    _PyTime_t t1 = <span class="number">0</span>;   <span class="comment">/* initialize to prevent a compiler warning */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gc_generation_stats</span> *<span class="title">stats</span> = &amp;<span class="title">generation_stats</span>[<span class="title">generation</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新计数器 */</span></span><br><span class="line">    <span class="keyword">if</span> (generation+<span class="number">1</span> &lt; NUM_GENERATIONS)</span><br><span class="line">        generations[generation+<span class="number">1</span>].count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= generation; i++)</span><br><span class="line">        generations[i].count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 合并我们正在处理的代及其以下的代的链表 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; generation; i++) &#123;</span><br><span class="line">        gc_list_merge(GEN_HEAD(i), GEN_HEAD(generation));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 给old变量赋值 */</span></span><br><span class="line">    young = GEN_HEAD(generation);</span><br><span class="line">    <span class="keyword">if</span> (generation &lt; NUM_GENERATIONS<span class="number">-1</span>)</span><br><span class="line">        old = GEN_HEAD(generation+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = young;</span><br><span class="line"></span><br><span class="line">    update_refs(young); <span class="comment">/* 把引用计数器复制到用于循环引用垃圾回收的头里 */</span></span><br><span class="line">    subtract_refs(young); <span class="comment">/* 删除实际引用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将计数器值为0的对象移动的unreachable对象链表中 */</span></span><br><span class="line">    gc_list_init(&amp;unreachable); </span><br><span class="line">    move_unreachable(young, &amp;unreachable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将循环引用垃圾回收中幸存的对象移到下一代 */</span></span><br><span class="line">    <span class="keyword">if</span> (young != old) &#123;</span><br><span class="line">        <span class="keyword">if</span> (generation == NUM_GENERATIONS - <span class="number">2</span>) &#123;</span><br><span class="line">            long_lived_pending += gc_list_size(young);</span><br><span class="line">        &#125;</span><br><span class="line">        gc_list_merge(young, old);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        untrack_dicts(young);</span><br><span class="line">        long_lived_pending = <span class="number">0</span>;</span><br><span class="line">        long_lived_total = gc_list_size(young);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 移出unreachable对象链表中有终结器的对象 */</span></span><br><span class="line">    gc_list_init(&amp;finalizers);</span><br><span class="line">    move_legacy_finalizers(&amp;unreachable, &amp;finalizers);</span><br><span class="line">    move_legacy_finalizer_reachable(&amp;finalizers);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 处理弱引用, 如果可能, 调用弱引用中注册的callback操作 */</span></span><br><span class="line">    m += handle_weakrefs(&amp;unreachable, old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 尝试调用unreachable中的容器对象tp_finalize操作, 如果有的话 */</span></span><br><span class="line">    finalize_garbage(&amp;unreachable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (check_garbage(&amp;unreachable)) &#123;</span><br><span class="line">        revive_garbage(&amp;unreachable);</span><br><span class="line">        gc_list_merge(&amp;unreachable, old);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* F. 调用tp_clear回收"不可达"容器对象</span></span><br><span class="line"><span class="comment">        delete_garbage(&amp;unreachable, old);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  	/* E.处理finalizers链表 */</span></span><br><span class="line">    (<span class="keyword">void</span>)handle_legacy_finalizers(&amp;finalizers, old);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果第3代超过了阀值, 则会清理freelists */</span></span><br><span class="line">    <span class="keyword">if</span> (generation == NUM_GENERATIONS<span class="number">-1</span>) &#123;</span><br><span class="line">        clear_freelists();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyErr_Occurred()) &#123; <span class="comment">/* 发生了GC异常 */</span></span><br><span class="line">        <span class="keyword">if</span> (nofail) &#123;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (gc_str == <span class="literal">NULL</span>)</span><br><span class="line">                gc_str = PyUnicode_FromString(<span class="string">"garbage collection"</span>);</span><br><span class="line">            PyErr_WriteUnraisable(gc_str);</span><br><span class="line">            Py_FatalError(<span class="string">"unexpected exception during garbage collection"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新统计信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (n_collected)</span><br><span class="line">        *n_collected = m;</span><br><span class="line">    <span class="keyword">if</span> (n_uncollectable)</span><br><span class="line">        *n_uncollectable = n;</span><br><span class="line">    stats-&gt;collections++;</span><br><span class="line">    stats-&gt;collected += m;</span><br><span class="line">    stats-&gt;uncollectable += n;</span><br><span class="line">    <span class="keyword">return</span> n+m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将这一过程分为几个小过程来一步步分析:</p>
<ul>
<li><p>(A). get_list_merge(): 将<code>from</code>链表连接到<code>to</code>链表的末尾:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[gcmodule.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc_list_merge</span><span class="params">(PyGC_Head *from, PyGC_Head *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PyGC_Head *tail;</span><br><span class="line">    assert(from != to);</span><br><span class="line">    <span class="keyword">if</span> (!gc_list_is_empty(from)) &#123;</span><br><span class="line">        tail = to-&gt;gc.gc_prev;</span><br><span class="line">        tail-&gt;gc.gc_next = from-&gt;gc.gc_next;</span><br><span class="line">        tail-&gt;gc.gc_next-&gt;gc.gc_prev = tail;</span><br><span class="line">        to-&gt;gc.gc_prev = from-&gt;gc.gc_prev;</span><br><span class="line">        to-&gt;gc.gc_prev-&gt;gc.gc_next = to;</span><br><span class="line">    &#125;</span><br><span class="line">    gc_list_init(from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc_list_init</span><span class="params">(PyGC_Head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;gc.gc_prev = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;gc.gc_next = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这也是<code>collect_generations</code>找到的是超过阀值”最老”的一代, 而<code>GC</code>能够处理它以及比它”年轻”的代的原因. 之后的标记—清楚算法将在这条合并后的链表上进行.</p>
</li>
<li><p>(B). update_refs()和subtract_refs(): 在这个阶段我们需要找到”Root Object”(不能被删除的对象)对象的集合. 这个过程中关键点在于怎么处理循环引用, 例如<code>A</code>引用<code>B</code>, 而<code>B</code>又引用<code>A</code>的情况.</p>
<ul>
<li>一种可选的方法是, 对于<code>A</code>引用<code>B</code>, 则将<code>B</code>的引用计数减一; 反之, 则将<code>A</code>的引用计数减一. 如果两个对象互相引用, 那么它的引用计数将变为<code>0</code>, 表示”不可达”.<br><br>这种方法有个问题是, 如果<code>A</code>引用<code>C</code>, 而<code>C</code>不在这个链表中, 如果将<code>C</code>的引用计数减一, 而最终<code>A</code>没有被回收, 那么将会造成对<code>C</code>的悬空引用, 这就需要对<code>C</code>的引用进行恢复.</li>
<li><p>针对循环引用, Python采用更好的做法: 复制原始引用, 只改动副本计数器, 即<code>gc_refs</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">update_refs(PyGC_Head *containers)</span><br><span class="line">&#123;</span><br><span class="line">    PyGC_Head *gc = containers-&gt;gc.gc_next;</span><br><span class="line">    <span class="keyword">for</span> (; gc != containers; gc = gc-&gt;gc.gc_next) &#123;</span><br><span class="line">        _PyGCHead_SET_REFS(gc, Py_REFCNT(FROM_GC(gc)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update_refs</code>遍历容器对象链表, 复制容器对象的真实引用计数到<code>PyGC_Head-&gt;gc_refs</code>中. 而<code>subtract_refs</code>负责清除容链表器对象之间的循环引用.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">subtract_refs(PyGC_Head *containers)</span><br><span class="line">&#123;</span><br><span class="line">    traverseproc traverse;</span><br><span class="line">    PyGC_Head *gc = containers-&gt;gc.gc_next;</span><br><span class="line">    <span class="keyword">for</span> (; gc != containers; gc=gc-&gt;gc.gc_next) &#123;</span><br><span class="line">        traverse = Py_TYPE(FROM_GC(gc))-&gt;tp_traverse;</span><br><span class="line">        (<span class="keyword">void</span>) traverse(FROM_GC(gc),</span><br><span class="line">                       (visitproc)visit_decref,</span><br><span class="line">                       <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>subtract_refs</code>中会遍历所有容器对象, 然后获得容器对象上的<code>tp_traverse</code>函数指针, 这个函数的会遍历容器对象里的元素, 并且调用函数参数<code>visit</code>传递进去的函数来访问元素. 这样一来, <code>subtract_refs</code>中就能通过传递进去函数<code>visit_decref</code>访问容器对象里的元素.<br><br>*NOTE: <code>traverse</code>实现了访问者模式, 这里访问用的函数为<code>visit_decref</code>.</p>
<p>下面是<code>visit_decref</code>的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">visit_decref(PyObject *op, <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyObject_IS_GC(op)) &#123;</span><br><span class="line">        PyGC_Head *gc = AS_GC(op);</span><br><span class="line">        <span class="keyword">if</span> (_PyGCHead_REFS(gc) &gt; <span class="number">0</span>)</span><br><span class="line">            _PyGCHead_DECREF(gc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在完成了<code>subtract_refs</code>之后, 容器对象链表中所有容器对象之间的循环引用都已被摘除. 如果还有容器对象的<code>gc_ref!=0</code>, 就意味着存在这些对象的外部引用, 也就是作为后面”标记—清楚”算法的”Root Object”集合.</p>
</li>
</ul>
</li>
<li><p>(C). move_unreachable(): 将原始链表划分为两个链表.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">move_unreachable(PyGC_Head *young, PyGC_Head *unreachable)</span><br><span class="line">&#123;</span><br><span class="line">    PyGC_Head *gc = young-&gt;gc.gc_next;</span><br><span class="line">    <span class="keyword">while</span> (gc != young) &#123;</span><br><span class="line">        PyGC_Head *next;</span><br><span class="line">        <span class="keyword">if</span> (_PyGCHead_REFS(gc)) &#123;</span><br><span class="line">            PyObject *op = FROM_GC(gc);</span><br><span class="line">            traverseproc traverse = Py_TYPE(op)-&gt;tp_traverse;</span><br><span class="line">            _PyGCHead_SET_REFS(gc, GC_REACHABLE);</span><br><span class="line">            (<span class="keyword">void</span>) traverse(op, (visitproc)visit_reachable, (<span class="keyword">void</span> *)young);</span><br><span class="line">            next = gc-&gt;gc.gc_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            next = gc-&gt;gc.gc_next;</span><br><span class="line">            gc_list_move(gc, unreachable);</span><br><span class="line">            _PyGCHead_SET_REFS(gc, GC_TENTATIVELY_UNREACHABLE);</span><br><span class="line">        &#125;</span><br><span class="line">        gc = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这一过程分为两种情况:</p>
<ul>
<li>gc_refs为0的容器对象: 对于这类容器对象, 我们将它标记为<code>GC_TENTATIVELY_UNREACHABLE</code>, 意思是”暂且认为她是不可达的”;</li>
<li><p>gc_refs不为0的容器对象: 对于这些有外部引用的对象, 即<code>Root Object</code>, 我们会将它标记为<code>GC_REACHABLE</code>, 意思是”可达”的. 而且我们使用<code>visit_reachable</code>去访问容器对象里面的元素:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">visit_reachable(PyObject *op, PyGC_Head *reachable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyObject_IS_GC(op)) &#123; </span><br><span class="line">        PyGC_Head *gc = AS_GC(op);</span><br><span class="line">        <span class="keyword">const</span> Py_ssize_t gc_refs = _PyGCHead_REFS(gc);</span><br><span class="line">        <span class="keyword">if</span> (gc_refs == <span class="number">0</span>) &#123; <span class="comment">/* 对于还没有处理的对象, 恢复其gc_refs */</span></span><br><span class="line">            _PyGCHead_SET_REFS(gc, <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="comment">/* 对于已经被挪到unreachable链表的对象, 再将其移到young链表中 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (gc_refs == GC_TENTATIVELY_UNREACHABLE) &#123; </span><br><span class="line">            gc_list_move(gc, reachable);</span><br><span class="line">            _PyGCHead_SET_REFS(gc, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于”可达”的容器对象里的容器对象, 如果, <code>gc_refs</code>为0, 则将其设定为1, 以表示准确的引用关系; 如果<code>gc_refs</code>为<code>GC_TENTATIVELY_UNREACHABLE</code>, 说明里面存了非活动对象, 需要从里面救出来, 移动到<code>reachable</code>链表(即<code>young</code>容器对象链表), 将<code>gc_refs</code>设为1.</p>
</li>
</ul>
</li>
<li><p>(D). move_legacy_finalizers(): 移出<code>unreachable</code>容器链表中那些有终结器的容器对象, 并加入<code>finalizers</code>链表, 标识为<code>GC_REACHABLE</code>.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">move_legacy_finalizers(PyGC_Head *unreachable, PyGC_Head *finalizers)</span><br><span class="line">&#123;</span><br><span class="line">    PyGC_Head *gc;</span><br><span class="line">    PyGC_Head *next;</span><br><span class="line">    <span class="keyword">for</span> (gc = unreachable-&gt;gc.gc_next; gc != unreachable; gc = next) &#123;</span><br><span class="line">        PyObject *op = FROM_GC(gc);</span><br><span class="line">        next = gc-&gt;gc.gc_next;</span><br><span class="line">        <span class="keyword">if</span> (has_legacy_finalizer(op)) &#123;</span><br><span class="line">            gc_list_move(gc, finalizers);</span><br><span class="line">            _PyGCHead_SET_REFS(gc, GC_REACHABLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>(E). <code>move_legacy_finalizer_reachable()</code>: 从已经移出的<code>finalizers</code>链表中容器对象开始查找, 移出该对象引用的对象, 这些被引用的对象也不应该被释放.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">move_legacy_finalizer_reachable(PyGC_Head *finalizers)</span><br><span class="line">&#123;</span><br><span class="line">    traverseproc traverse;</span><br><span class="line">    PyGC_Head *gc = finalizers-&gt;gc.gc_next;</span><br><span class="line">    <span class="keyword">for</span> (; gc != finalizers; gc = gc-&gt;gc.gc_next) &#123;</span><br><span class="line">        traverse = Py_TYPE(FROM_GC(gc))-&gt;tp_traverse;</span><br><span class="line">        (<span class="keyword">void</span>) traverse(FROM_GC(gc), visitproc)visit_move, (<span class="keyword">void</span> *)finalizers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">visit_move(PyObject *op, PyGC_Head *tolist)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyObject_IS_GC(op)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IS_TENTATIVELY_UNREACHABLE(op)) &#123;</span><br><span class="line">            PyGC_Head *gc = AS_GC(op);</span><br><span class="line">            gc_list_move(gc, tolist);</span><br><span class="line">            _PyGCHead_SET_REFS(gc, GC_REACHABLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>(F). delete_garbage(): 打破容器对象的循环引用, 这就需要对对象的实际ob_ref做修改, 是它变为0, 触发对象的销毁.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">delete_garbage(PyGC_Head *collectable, PyGC_Head *old)</span><br><span class="line">&#123;</span><br><span class="line">    inquiry clear;</span><br><span class="line">    <span class="keyword">while</span> (!gc_list_is_empty(collectable)) &#123;</span><br><span class="line">        PyGC_Head *gc = collectable-&gt;gc.gc_next;</span><br><span class="line">        PyObject *op = FROM_GC(gc);</span><br><span class="line">           <span class="keyword">if</span> ((clear = Py_TYPE(op)-&gt;tp_clear) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               Py_INCREF(op);</span><br><span class="line">               clear(op);</span><br><span class="line">               Py_DECREF(op);</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">if</span> (collectable-&gt;gc.gc_next == gc) &#123;</span><br><span class="line">            gc_list_move(gc, old);</span><br><span class="line">            _PyGCHead_SET_REFS(gc, GC_REACHABLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在其中会调用容器对象的<code>tp_clear</code>操作, 调整容器对象中引用的每个对象的引用计数值, 从而打破循环引用安全回收.</p>
<p>  现在我们假设两个列表<code>list_1</code>和<code>list_2</code>互相引用, 我们看看是怎么回收这两个对象的. 假设先调用<code>list_1</code>的<code>tp_clear</code>操作:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">list_clear(PyListObject *a)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject **item = a-&gt;ob_item;</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        i = Py_SIZE(a);</span><br><span class="line">        Py_SIZE(a) = <span class="number">0</span>;</span><br><span class="line">        a-&gt;ob_item = <span class="literal">NULL</span>;</span><br><span class="line">        a-&gt;allocated = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Py_XDECREF(item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        PyMem_FREE(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  它会先减少<code>list_1</code>中引用的每一个对象的引用计数, 即<code>list_2</code>的引用计数会减少到0, 引发对象销毁工作, 调用<code>list_2</code>的<code>tp_dealloc</code>操作, :</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">list_dealloc(PyListObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject_GC_UnTrack(op);</span><br><span class="line">    <span class="keyword">if</span> (op-&gt;ob_item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        i = Py_SIZE(op);</span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        PyMem_FREE(op-&gt;ob_item);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>list_2</code>的<code>tp_dealloc</code>首先会将自己从<code>GC</code>容器对象链表中移出, 同样它也会调整引用的对象的计数值, 使得<code>list_1</code>的引用计数减少到0, 触发<code>list_1</code>的销毁.</p>
</li>
<li><p>(G). handle_legacy_finalizers(): 对全局变量<code>garbage</code>注册之前保存的<code>finalizers</code>链表.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">handle_legacy_finalizers(PyGC_Head *finalizers, PyGC_Head *old)</span><br><span class="line">&#123;</span><br><span class="line">    PyGC_Head *gc = finalizers-&gt;gc.gc_next;</span><br><span class="line">    <span class="keyword">if</span> (garbage == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        garbage = PyList_New(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; gc != finalizers; gc = gc-&gt;gc.gc_next) &#123;</span><br><span class="line">        PyObject *op = FROM_GC(gc);</span><br><span class="line">        <span class="keyword">if</span> ((debug &amp; DEBUG_SAVEALL) || has_legacy_finalizer(op)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PyList_Append(garbage, op) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gc_list_merge(finalizers, old);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  全局变量<code>garbage</code>是一个<code>PyList_Object</code>, 它保存了那些注册了<code>__del__</code>操作的实例对象, 而且这些对象会晋升到”老一代”.</p>
<p>  为了能处理这些变量, Python提供了<code>gc</code>模块, 来处理全局变量<code>garbage</code>:</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> gc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.garbage</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另外, 关于Python的垃圾回收有几点需要注意的:</p>
<ul>
<li>在垃圾回收中有对弱引用(<code>weakref</code>)的处理, 因为它们能够注册<code>callback</code>, 能被正确的清理;</li>
<li>而有终结器<code>__del__</code>的实例对象不同, 在Python3之前它们是不能够自动清理的, 原因是假设两个对象<code>A`</code>B<code>循环引用, 各自有自己的终结器, 如果先终结化了第一个对象</code>A<code>, 而终结第二个对象</code>B<code>的时候, 如果需要用到</code>A`, 那么就会陷入矛盾. 而在Python3中是通过一个临时可见的链表保存着这些容器对象, 使得垃圾回收能够清理这些有终结器的实例对象.</li>
<li>虽然大部分对象创建的时候通过<code>PyGC_New</code>添加到了容器对象链表中, 但是并非垃圾收集机制才能回收, 正常的引用计数就可以完成对象的销毁.</li>
</ul>

    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持作者</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/posts/691b6e2d/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/posts/f75280fd/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

  <div id="gitment-comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    (function () {
      var gitment = new Gitment({
        owner: 'zhongshangwu',
        repo: 'zhongshangwu.github.io',
        oauth: {
          client_id: 'ecb8413d71a24ae7e38a',
          client_secret: '6aacbb72400e02734e754fce4b6204ae07ec9dc2'
        },
        
        
        
        
        
        
        
        
      })
      gitment.render('gitment-comments')
    })()
  </script>



    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
