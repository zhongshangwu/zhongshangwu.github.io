<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Python源码阅读-函数机制 | Shawn&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Python,源码," />
  

  <meta name="description" content="在Python中，函数是一等对象  函数对象">
<meta name="keywords" content="Python,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Python源码阅读-函数机制">
<meta property="og:url" content="http://shawnz.me/posts/c981e5e/index.html">
<meta property="og:site_name" content="Shawn&#39;s Blog">
<meta property="og:description" content="在Python中，函数是一等对象  函数对象">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-1.png">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-2.png">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-3.png">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-4.png">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-5.png">
<meta property="og:updated_time" content="2018-03-10T06:20:54.162Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python源码阅读-函数机制">
<meta name="twitter:description" content="在Python中，函数是一等对象  函数对象">
<meta name="twitter:image" content="http://shawnz.me/images/pyfunctionobject-1.png">

  

  
    <link rel="icon" href="/favicon.png">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/custom.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数对象"><span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无参函数调用"><span class="toc-text">无参函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数参数"><span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位置参数函数调用"><span class="toc-text">位置参数函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认参数函数调用"><span class="toc-text">默认参数函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键词参数函数调用"><span class="toc-text">关键词参数函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可变参数调用"><span class="toc-text">可变参数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PyEval-EvalCodeWithName"><span class="toc-text">_PyEval_EvalCodeWithName</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰器"><span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未完，待续。。。"><span class="toc-text">未完，待续。。。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resources"><span class="toc-text">Resources</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Python源码阅读-函数机制" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Python源码阅读-函数机制</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.01.11</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Shawn Zhong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <blockquote>
<p>在Python中，函数是一等对象</p>
</blockquote>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><a id="more"></a>
<p>在Python中函数的声明和实现的字节码是在不同<code>PyCodeObject</code>中的，它以一种嵌套的形式存储在外层<code>PyCodeObject</code>的<code>co_const</code>常量表中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code object f at <span class="number">0x7ff60e613ed0</span>&gt;)</span><br><span class="line"><span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">'f'</span>)</span><br><span class="line"><span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line"><span class="number">6</span> STORE_NAME               <span class="number">0</span> (f)</span><br><span class="line">    print(<span class="string">"func"</span>)</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="number">8</span> LOAD_NAME                <span class="number">0</span> (f)</span><br><span class="line"><span class="number">10</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line"><span class="number">12</span> POP_TOP</span><br><span class="line"><span class="number">14</span> LOAD_CONST               <span class="number">2</span> (<span class="keyword">None</span>)</span><br><span class="line"><span class="number">16</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>我们说<code>PyCodeObject</code>是对源码编译的结果，存储的静态信息，例如：常量表(<code>co_const</code>)，符号表(<code>co_names</code>)以及字节码(<code>co_code</code>)。</p>
<p>而<code>PyFunctionObject</code>则是动态产生的，确切的说是在<code>def f()</code>语句的时候创建的，体现在字节码上就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> LOAD_CONST               <span class="number">0</span> (&lt;code object f at <span class="number">0x7ff60e613ed0</span>&gt;)</span><br><span class="line"><span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">'f'</span>)</span><br><span class="line"><span class="number">4</span> MAKE_FUNCTION            <span class="number">0</span></span><br><span class="line"><span class="number">6</span> STORE_NAME               <span class="number">0</span> (f)</span><br></pre></td></tr></table></figure></p>
<p>这四条指令先后会：将函数<code>f</code>对应的<code>PyCodeObject</code>对象压入栈；把常量表中的<code>f</code>压入栈；构建函数对象<code>PyFunctionObject</code>；以及将键<code>f</code>和值<code>PyFunctionObject</code>存入命名空间(这里<code>f_locals</code>和<code>f_globals</code>是指向同一处命名空间)。</p>
<p>对于一段静态的代码块来说，它只会对应一个<code>PyCodeObject</code>，而可能会创建多个<code>PyFunctionObject</code>。</p>
<p>下面是<code>PyFunctionObject</code>的定义，可以看到函数对应的<code>PyCodeObject</code>会被设置为域<code>func_code</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *func_code;	<span class="comment">/* A code object, the __code__ attribute */</span></span><br><span class="line">    PyObject *func_globals;	<span class="comment">/* A dictionary (other mappings won't do) */</span></span><br><span class="line">    PyObject *func_defaults;	<span class="comment">/* NULL or a tuple */</span></span><br><span class="line">    PyObject *func_kwdefaults;	<span class="comment">/* NULL or a dict */</span></span><br><span class="line">    PyObject *func_closure;	<span class="comment">/* NULL or a tuple of cell objects */</span></span><br><span class="line">    PyObject *func_doc;		<span class="comment">/* The __doc__ attribute, can be anything */</span></span><br><span class="line">    PyObject *func_name;	<span class="comment">/* The __name__ attribute, a string object */</span></span><br><span class="line">    PyObject *func_dict;	<span class="comment">/* The __dict__ attribute, a dict or NULL */</span></span><br><span class="line">    PyObject *func_weakreflist;	<span class="comment">/* List of weak references */</span></span><br><span class="line">    PyObject *func_module;	<span class="comment">/* The __module__ attribute, can be anything */</span></span><br><span class="line">    PyObject *func_annotations;	<span class="comment">/* Annotations, a dict or NULL */</span></span><br><span class="line">    PyObject *func_qualname;    <span class="comment">/* The qualified name */</span></span><br><span class="line">&#125; PyFunctionObject;</span><br></pre></td></tr></table></figure>
<p>创建函数对象的指令<code>MAKE_FUNCTION</code>，可以在<code>ceval.c</code>中找到对应的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TARGET(MAKE_FUNCTION) &#123;</span><br><span class="line">    PyObject *qualname = POP();</span><br><span class="line">    PyObject *codeobj = POP();</span><br><span class="line">    PyFunctionObject *func = (PyFunctionObject *)</span><br><span class="line">        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);</span><br><span class="line">    ...</span><br><span class="line">    PUSH((PyObject *)func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>MAKE_FUNCTION</code>指令首先会从运行时栈中弹出函数的限定名称<code>qualname</code>和函数对应的字节码对象<code>codeobj</code>，并将当前命名空间<code>f_globals</code>作为函数的全局命名空间来创建函数对象(具体的初始化过程这里先不深入)，最后压入运行时栈。</p>
<h2 id="无参函数调用"><a href="#无参函数调用" class="headerlink" title="无参函数调用"></a>无参函数调用</h2><p>创建完函数对象并存入命名空间中后，接下来就可以调用函数了。</p>
<p>我们从最简单的无参函数调用开始，<code>CALL_FUNCTION 0</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TARGET(CALL_FUNCTION) &#123;</span><br><span class="line">    PyObject **sp, *res;</span><br><span class="line">    PCALL(PCALL_ALL);</span><br><span class="line">    sp = stack_pointer;</span><br><span class="line">    res = call_function(&amp;sp, oparg, <span class="literal">NULL</span>);</span><br><span class="line">    stack_pointer = sp;</span><br><span class="line">    PUSH(res);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CALL_FUNCTION</code>指令代码中，虚拟机只是保存了栈指针，以在函数调用过后恢复，并将函数调用的结果压入运行时栈。具体的实现在<code>call_function</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject **pfunc = (*pp_stack) - oparg - <span class="number">1</span>;  <span class="comment">/* 获取函数对象 */</span></span><br><span class="line">    PyObject *func = *pfunc;</span><br><span class="line">    PyObject *x, *w;</span><br><span class="line">    Py_ssize_t nkwargs = (kwnames == <span class="literal">NULL</span>) ? <span class="number">0</span> : PyTuple_GET_SIZE(kwnames);</span><br><span class="line">    Py_ssize_t nargs = oparg - nkwargs; <span class="comment">/* 参数处理 */</span></span><br><span class="line">    PyObject **<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyCFunction_Check(func)) &#123;  </span><br><span class="line">        ...  <span class="comment">/* CFucntion */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyMethod_Check(func) &amp;&amp; PyMethod_GET_SELF(func) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ... <span class="comment">/* Method */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span> = (*pp_stack) - nargs - nkwargs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PyFunction_Check(func)) &#123;  <span class="comment">/* Function */</span></span><br><span class="line">            x = fast_function(func, <span class="built_in">stack</span>, nargs, kwnames);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>call_function</code>不光在函数调用的时候会使用，<code>CFunction</code>和<code>Method</code>也会调用这个方法。<code>call_function</code>首先要做的就是获取栈上的函数对象，也就是通过指令<code>CALL_FUNCTION</code>前一个指令<code>LOAD_NAME 0</code>压入运行时栈的。在这里指针<code>func</code>指向的是栈顶位置-1的地方(<code>(*pp_stack) - oparg - 1</code>)。</p>
<p>具体的参数处理我们先跳过，来看看<code>fast_function</code>是怎么调用函数的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">fast_function(PyObject *func, PyObject **<span class="built_in">stack</span>,</span><br><span class="line">              Py_ssize_t nargs, PyObject *kwnames)</span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);  <span class="comment">/* code对象 */</span></span><br><span class="line">    PyObject *globals = PyFunction_GET_GLOBALS(func); <span class="comment">/* globals命名空间 */</span></span><br><span class="line">    PyObject *argdefs = PyFunction_GET_DEFAULTS(func); <span class="comment">/* 默认参数 */</span></span><br><span class="line">    PyObject *kwdefs, *closure, *name, *qualname;</span><br><span class="line">    PyObject **d;</span><br><span class="line">    Py_ssize_t nkwargs = (kwnames == <span class="literal">NULL</span>) ? <span class="number">0</span> : PyTuple_GET_SIZE(kwnames);</span><br><span class="line">    Py_ssize_t nd;</span><br><span class="line"></span><br><span class="line">    PCALL(PCALL_FUNCTION);</span><br><span class="line">    PCALL(PCALL_FAST_FUNCTION);</span><br><span class="line">    <span class="comment">/* 一般函数的快速通道 */</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount == <span class="number">0</span> &amp;&amp; nkwargs == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (argdefs == <span class="literal">NULL</span> &amp;&amp; co-&gt;co_argcount == nargs) &#123;</span><br><span class="line">            <span class="comment">/* 这是我们调用f()进入的地方 */</span></span><br><span class="line">            <span class="keyword">return</span> _PyFunction_FastCall(co, <span class="built_in">stack</span>, nargs, globals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nargs == <span class="number">0</span> &amp;&amp; argdefs != <span class="literal">NULL</span></span><br><span class="line">                 &amp;&amp; co-&gt;co_argcount == Py_SIZE(argdefs)) &#123;</span><br><span class="line">            <span class="built_in">stack</span> = &amp;PyTuple_GET_ITEM(argdefs, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> _PyFunction_FastCall(co, <span class="built_in">stack</span>, Py_SIZE(argdefs), globals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kwdefs = PyFunction_GET_KW_DEFAULTS(func);</span><br><span class="line">    closure = PyFunction_GET_CLOSURE(func);</span><br><span class="line">    name = ((PyFunctionObject *)func) -&gt; func_name;</span><br><span class="line">    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argdefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d = &amp;PyTuple_GET_ITEM(argdefs, <span class="number">0</span>);</span><br><span class="line">        nd = Py_SIZE(argdefs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d = <span class="literal">NULL</span>;</span><br><span class="line">        nd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)<span class="literal">NULL</span>,</span><br><span class="line">                                    ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>fast_function</code>做的大部分工作在参数处理上，而这里我们重点关注函数是怎么调用。当使用无参形式调用函数的时候，最终会进入<code>_PyFunction_FastCall</code>快速通道；其他的情况下，会使用<code>_PyEval_EvalCodeWithName</code>处理<code>code</code>对象。</p>
<p>在<code>_PyFunction_FastCall</code>中，虚拟机会创建一个新的<code>frame</code>，并递归调用<code>PyEval_EvalFrameEx</code>来处理栈桢。而在另一条路径<code>_PyEval_EvalCodeWithName</code>，我们知道虚拟机也会创建新的栈桢，最终也是调用<code>PyEval_EvalFrameEx</code>来处理。</p>
<p>所以函数的调用过程就是：创建新的栈桢，在新的栈桢中执行代码。在这个过程中<code>PyFunctionObject</code>只是起到打包和传递<code>code</code>对象以及<code>globals</code>的作用。</p>
<p>下面是<code>_PyFunction_FastCall</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject*</span><br><span class="line">_PyFunction_FastCall(PyCodeObject *co, PyObject **args, Py_ssize_t nargs,</span><br><span class="line">                     PyObject *globals)</span><br><span class="line">&#123;</span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    PyThreadState *tstate = PyThreadState_GET();</span><br><span class="line">    PyObject **fastlocals;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    PCALL(PCALL_FASTER_FUNCTION);</span><br><span class="line">    f = PyFrame_New(tstate, co, globals, <span class="literal">NULL</span>); <span class="comment">/* 创建新的frame */</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理 */</span></span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">        Py_INCREF(*args);</span><br><span class="line">        fastlocals[i] = *args++;</span><br><span class="line">    &#125;</span><br><span class="line">    result = PyEval_EvalFrameEx(f,<span class="number">0</span>); <span class="comment">/* 递归处理frame */</span></span><br><span class="line"></span><br><span class="line">    ++tstate-&gt;recursion_depth; <span class="comment">/* 递归深度为什么在这里加？ */</span></span><br><span class="line">    Py_DECREF(f);</span><br><span class="line">    --tstate-&gt;recursion_depth;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>上面已经分析过了函数调用的整体框架，现在让我们来加上参数传递机制。</p>
<p>在Python中函数的参数可以分为几类：</p>
<ul>
<li>位置参数：<code>f(a, b)</code>，其中<code>a</code>和<code>b</code>被称为位置参数；</li>
<li>关键字参数：<code>f(a, b, name=&quot;Python&quot;)</code>，其中<code>name</code>被称为关键字参数；</li>
<li>扩展位置参数：<code>f(a, b, *args)</code>，可以使用<code>*</code>收集剩余的位置参数；</li>
<li>扩展关键字参数：<code>f(a, b, **kwargs)</code>，可以使用<code>**</code>收集剩余的关键词参数；</li>
<li>仅限关键字参数：这是Python3中新引入的，<code>f(a, b, *list, c=None, **kwargs)</code>，仅限关键参数必须位于某个<code>*</code>参数或单个<code>*</code>后面，强制使用关键字参数传递。</li>
</ul>
<h2 id="位置参数函数调用"><a href="#位置参数函数调用" class="headerlink" title="位置参数函数调用"></a>位置参数函数调用</h2><p>我们使用一个简单的例子来分析，Python的位置参数的传递和函数调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name, age)</span>:</span></span><br><span class="line"><span class="comment"># 0 LOAD_CONST               0 (&lt;code object f at 0x7fbd0fe3bed0&gt;)</span></span><br><span class="line"><span class="comment"># 2 LOAD_CONST               1 ('f')</span></span><br><span class="line"><span class="comment"># 4 MAKE_FUNCTION            0</span></span><br><span class="line"><span class="comment"># 6 STORE_NAME               0 (f)</span></span><br><span class="line"></span><br><span class="line">    print(name, age)</span><br><span class="line">    <span class="comment"># 0 LOAD_GLOBAL              0 (print)</span></span><br><span class="line">    <span class="comment"># 2 LOAD_FAST                0 (name)</span></span><br><span class="line">    <span class="comment"># 4 LOAD_FAST                1 (age)</span></span><br><span class="line">    <span class="comment"># 6 CALL_FUNCTION            2</span></span><br><span class="line">    <span class="comment"># 8 POP_TOP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 10 LOAD_FAST                1 (age)</span></span><br><span class="line">    <span class="comment"># 12 LOAD_CONST               1 (3)</span></span><br><span class="line">    <span class="comment"># 14 INPLACE_ADD</span></span><br><span class="line">    <span class="comment"># 16 STORE_FAST               1 (age)</span></span><br><span class="line">    <span class="comment"># 18 LOAD_CONST               0 (None)</span></span><br><span class="line">    <span class="comment"># 20 RETURN_VALUE</span></span><br><span class="line"></span><br><span class="line">f(<span class="string">"Python"</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 8 LOAD_NAME                0 (f)</span></span><br><span class="line"><span class="comment"># 10 LOAD_CONST               2 ('Python')</span></span><br><span class="line"><span class="comment"># 12 LOAD_CONST               5 (5)</span></span><br><span class="line"><span class="comment"># 14 CALL_FUNCTION            2</span></span><br><span class="line"><span class="comment"># 16 POP_TOP</span></span><br><span class="line"><span class="comment"># 18 LOAD_CONST               4 (None)</span></span><br><span class="line"><span class="comment"># 20 RETURN_VALUE</span></span><br></pre></td></tr></table></figure>
<p>和无参函数一样，首先是创建函数对象，在<code>CALL_FUNCTION</code>前会有三条<code>LOAD</code>指令，虚拟机会加载函数需要的参数压入运行时栈，入栈完成后运行时栈如下：</p>
<p><img src="/images/pyfunctionobject-1.png" alt=""></p>
<p>在<code>CALL_FUNCTION 2</code>指令中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TARGET(CALL_FUNCTION) &#123;</span><br><span class="line">    res = call_function(&amp;sp, oparg, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject **pfunc = (*pp_stack) - oparg - <span class="number">1</span>;  <span class="comment">/* 获取函数对象 */</span></span><br><span class="line">    Py_ssize_t nkwargs = (kwnames == <span class="literal">NULL</span>) ? <span class="number">0</span> : PyTuple_GET_SIZE(kwnames);</span><br><span class="line">    Py_ssize_t nargs = oparg - nkwargs; <span class="comment">/* 参数处理 */</span></span><br><span class="line">    PyObject **<span class="built_in">stack</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* stack指针将指向第一个参数 */</span></span><br><span class="line">    <span class="built_in">stack</span> = (*pp_stack) - nargs - nkwargs;</span><br><span class="line">    x = fast_function(func, <span class="built_in">stack</span>, nargs, kwnames);</span><br></pre></td></tr></table></figure></p>
<p>可以发现<code>CALL_FUNCTION</code>指令在调用<code>call_function</code>方法时传递的参数<code>kwnames</code>是空的，这点和Python2不同，Python3中<code>CALL_FUNCTION</code>指令只会在以位置参数的方式调用函数时使用。</p>
<p>在这里的指令参数<code>oparg</code>为<code>2</code>，代表参数的个数。将栈顶指针减2减1就可以得到我们的<code>PyFunctionObject</code>对象的指针。在处理完参数后，<code>fast_function</code>最终会调用<code>_PyFunction_FastCall</code>进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject*</span><br><span class="line">_PyFunction_FastCall(PyCodeObject *co, PyObject **args, Py_ssize_t nargs,</span><br><span class="line">                     PyObject *globals)</span><br><span class="line">&#123;   ...</span><br><span class="line">   f = PyFrame_New(tstate, co, globals, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 新栈桢的localsplus域 */</span></span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    <span class="comment">/* 拷贝位置参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nargs; i++) &#123;</span><br><span class="line">        Py_INCREF(*args);</span><br><span class="line">        fastlocals[i] = *args++;</span><br><span class="line">    &#125;</span><br><span class="line">    result = PyEval_EvalFrameEx(f,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在创建好新的栈桢对象<code>f</code>后，虚拟机会将加载在当前运行时栈中的位置参数<code>Python</code>和<code>5</code>拷贝到新的栈桢的<code>f_localspuls</code>域，这个域里面也包括了栈桢的运行时栈。这时<code>f</code>的运行时栈还是空的，<code>f_localsplus</code>的内存布局如下：</p>
<p><img src="/images/pyfunctionobject-2.png" alt=""></p>
<p>现在，函数参数已经放在了<code>PyFrameObject</code>的<code>f_localsplus</code>域中，那么在函数执行的时候就可以访问和操作这两个参数了。实际上，虚拟机正是通过两条指令<code>LOAD_FAST</code>和<code>STORE_FAST</code>操作<code>f_localspuls</code>这片内存区域的，在<code>_PyEval_EvalFrameDefault</code>中我们可以看到这些操作定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fastlocals = f-&gt;f_localsplus;  <span class="comment">/* 将fastlocals设为f_localsplus域 */</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETLOCAL(i)     (fastlocals[i])</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETLOCAL(i, value)      do &#123; PyObject *tmp = GETLOCAL(i); \</span></span><br><span class="line">                                     GETLOCAL(i) = value; \</span><br><span class="line">                                     Py_XDECREF(tmp); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">TARGET(LOAD_FAST) &#123;  <span class="comment">/* 将fastlocals中的对象压入运行时栈 */</span></span><br><span class="line">    PyObject *value = GETLOCAL(oparg);</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    PUSH(value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TARGET(STORE_FAST) &#123; <span class="comment">/* 从运行时栈弹出，并存回fastlocals */</span></span><br><span class="line">    PyObject *value = POP();</span><br><span class="line">    SETLOCAL(oparg, value);</span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样通过位置参数的调用函数过程现在已经比较清晰了：Python会将位置参数值从左到右压入当前栈桢运行时栈，并使用指令<code>CALL_FUNCTION</code>调用函数，最终它会跳转到<code>_PyFunction_FastCall</code>方法中创建新的栈桢，并将运行时栈中的参数值依次存储在新的栈桢的<code>f_localsplus</code>域中，等待函数的执行。</p>
<p>而在函数执行的过程中，Python并没有使用通常的按名称查找的做法，而是通过一个索引(偏移位置)来访问<code>f_localspul</code>域中存储的参数值。这也就是<code>位置参数</code>的由来。</p>
<h2 id="默认参数函数调用"><a href="#默认参数函数调用" class="headerlink" title="默认参数函数调用"></a>默认参数函数调用</h2><p>在继续学习关键字参数之前，我们先看看Python是怎么处理默认参数的。我们猜默认参数应该是在<code>MAKE_FUNCTION</code>里处理的。果然，我们在这条指令的实现处发现了如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;func -&gt;func_closure = POP(); &#125;</span><br><span class="line"><span class="keyword">if</span> (oparg &amp; <span class="number">0x04</span>) &#123;func-&gt;func_annotations = POP();&#125;</span><br><span class="line"><span class="keyword">if</span> (oparg &amp; <span class="number">0x02</span>) &#123;func-&gt;func_kwdefaults = POP();&#125;</span><br><span class="line"><span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;func-&gt;func_defaults = POP();&#125;</span><br></pre></td></tr></table></figure>
<p>这条指令的参数<code>oparg</code>采用“掩码”的形式实现，如果值为<code>1</code>那么，它会从运行时栈中弹出默认参数，并设为函数对象的<code>func_defaults</code>域。</p>
<p>这一点字节码可以证明，在压入<code>code</code>对象和名称<code>f</code>之前，有一条<code>LOAD_CONST</code>指令将<code>(&#39;Python&#39;, 3)</code>也一并压入了栈中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name=<span class="string">"Python"</span>, age=<span class="number">3</span>)</span>:</span></span><br><span class="line"><span class="comment"># 0 LOAD_CONST               5 (('Python', 3)) </span></span><br><span class="line"><span class="comment"># 2 LOAD_CONST               2 (&lt;code object f at 0x7f2e7f099ed0&gt;</span></span><br><span class="line"><span class="comment"># 4 LOAD_CONST               3 ('f')   </span></span><br><span class="line"><span class="comment"># 6 MAKE_FUNCTION            1  </span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">f()</span><br></pre></td></tr></table></figure></p>
<p>接下来的调用，依旧是<code>fast_function</code>函数。之前我们看见除了上面的正常无参函数调用外，还有一种情况就是函数调用的时候没有传递参数，但是所有参数都有默认值，这个时候虚拟机也会走<code>_PyFunction_FastCall</code>通道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">fast_function(PyObject *func, PyObject **<span class="built_in">stack</span>,</span><br><span class="line">              Py_ssize_t nargs, PyObject *kwnames)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount == <span class="number">0</span> &amp;&amp; nkwargs == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))</span><br><span class="line">        &#123;   <span class="comment">/* 正常无参函数调用 */</span></span><br><span class="line">            <span class="keyword">if</span> (argdefs == <span class="literal">NULL</span> &amp;&amp; co-&gt;co_argcount == nargs) &#123;</span><br><span class="line">                <span class="keyword">return</span> _PyFunction_FastCall(co, <span class="built_in">stack</span>, nargs, globals);</span><br><span class="line">            &#125; <span class="comment">/* 函数调用没有给参数，但是所有参数都有默认参数值 */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nargs == <span class="number">0</span> &amp;&amp; argdefs != <span class="literal">NULL</span></span><br><span class="line">                    &amp;&amp; co-&gt;co_argcount == Py_SIZE(argdefs)) &#123;</span><br><span class="line">                <span class="built_in">stack</span> = &amp;PyTuple_GET_ITEM(argdefs, <span class="number">0</span>);  <span class="comment">/* 栈指针指向func_defaults第一个元素 */</span></span><br><span class="line">                <span class="keyword">return</span> _PyFunction_FastCall(co, <span class="built_in">stack</span>, Py_SIZE(argdefs), globals);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在应该很明显了，默认参数会在执行函数声明语句的时候，存储在函数对象的<code>func_defaults</code>域，在函数调用的时候使用宏定义<code>PyFunction_GET_DEFAULTS</code>获取这些参数值，并让栈指针指向它。接下来在<code>_PyFunction_FastCall</code>依然会通过<code>*arg++</code>设置好<code>f_localsplus</code>域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyFunction_GET_DEFAULTS(func) \</span></span><br><span class="line">    (((PyFunctionObject *)func) -&gt; func_defaults)</span><br></pre></td></tr></table></figure>
<h2 id="关键词参数函数调用"><a href="#关键词参数函数调用" class="headerlink" title="关键词参数函数调用"></a>关键词参数函数调用</h2><p>Python3中带关键词参数的函数调用指令不再是<code>CALL_FUNCTION</code>了，而是<code>CALL_FUNCTION_KW</code>，还是上一个例子，不过这里在调用函数的时候稍作修改，我们可以看到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="string">"Python"</span>, age=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 8 LOAD_NAME                0 (f) </span></span><br><span class="line"><span class="comment"># 10 LOAD_CONST               2 ('Python')       </span></span><br><span class="line"><span class="comment"># 12 LOAD_CONST               3 (3)       </span></span><br><span class="line"><span class="comment"># 14 LOAD_CONST               4 (('age',)) </span></span><br><span class="line"><span class="comment"># 16 CALL_FUNCTION_KW         2    </span></span><br><span class="line"><span class="comment"># ...`</span></span><br></pre></td></tr></table></figure></p>
<p>其他地方和使用位置参数调用函数一样，这里的<code>CALL_FUNTION_KW 2</code>之前多做的一项工作就是把常量表中的符号<code>age</code>，压入运行时栈，来到<code>CALL_FUNTION_KW</code>指令的实现处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TARGET(CALL_FUNCTION_KW) &#123;</span><br><span class="line">    PyObject **sp, *res, *names;</span><br><span class="line">    names = POP();  <span class="comment">/* 弹出关键字参数名称元组 */</span></span><br><span class="line">    PCALL(PCALL_ALL);</span><br><span class="line">    sp = stack_pointer;</span><br><span class="line">    res = call_function(&amp;sp, oparg, names);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>CALL_FUNCTION</code>没什么两样，不过是从运行时栈中弹出了最后压入的关键字参数名称。从它只会调用一次<code>POP()</code>，可以知道这些名称是以一个元组形式一起压入栈中，事实上也恰恰如此：<code>((&#39;age&#39;,))</code>。</p>
<p>依旧还是<code>call_function</code>函数，不过现在我们有了<code>knames</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject **pfunc = (*pp_stack) - oparg - <span class="number">1</span>;</span><br><span class="line">    PyObject *func = *pfunc;</span><br><span class="line">    Py_ssize_t nkwargs = (kwnames == <span class="literal">NULL</span>) ? <span class="number">0</span> : PyTuple_GET_SIZE(kwnames);</span><br><span class="line">    Py_ssize_t nargs = oparg - nkwargs;</span><br></pre></td></tr></table></figure></p>
<p>现在我们对这些参数处理有了更进一步的认识：python在传递参数的时候，无论是位置参数还是关键字参数，都会将参数值先压入运行时栈中，对于关键次参数还用<code>kwnames</code>传递关键字参数名称，这样一来虚拟机就可以把这些名称和关键字参数值一一对应起来(隐性要求就是位置参数在前)。</p>
<p>不过这样一来在<code>fast_function</code>中，就不会走<code>_PyFunction_FastCall</code>这条通道了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">fast_function(PyObject *func, PyObject **<span class="built_in">stack</span>,</span><br><span class="line">              Py_ssize_t nargs, PyObject *kwnames)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount == <span class="number">0</span> &amp;&amp; nkwargs == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 关键字参数就不会走这条通道了 */</span></span><br><span class="line">        <span class="keyword">return</span> _PyFunction_FastCall(co, <span class="built_in">stack</span>, Py_SIZE(argdefs), globals);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    kwdefs = PyFunction_GET_KW_DEFAULTS(func); <span class="comment">/* 仅限关键字参数默认值 */</span></span><br><span class="line">    closure = PyFunction_GET_CL OSURE(func);  <span class="comment">/* 闭包 */</span></span><br><span class="line">    name = ((PyFunctionObject*)func) -&gt; func_name;</span><br><span class="line">    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argdefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d = &amp;PyTuple_GET_ITEM(argdefs, <span class="number">0</span>); <span class="comment">/* 熟悉的默认参数值 */</span></span><br><span class="line">        nd = Py_SIZE(argdefs); <span class="comment">/* 默认值个数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d = <span class="literal">NULL</span>;</span><br><span class="line">        nd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)<span class="literal">NULL</span>,</span><br><span class="line">            <span class="built_in">stack</span>, nargs, <span class="comment">/* 位置参数 */</span></span><br><span class="line">            nkwargs ? &amp;PyTuple_GET_ITEM(kwnames, <span class="number">0</span>) : <span class="literal">NULL</span>, <span class="comment">/* 关键字参数名称*/</span></span><br><span class="line">            <span class="built_in">stack</span> + nargs, <span class="comment">/* 关键字参数值 */</span></span><br><span class="line">            nkwargs, <span class="number">1</span>, <span class="comment">/* 关键字参数个数以及step */</span></span><br><span class="line">            d, (<span class="keyword">int</span>)nd, kwdefs, <span class="comment">/* 位置参数默认值， 仅限关键字参数默认值 */</span></span><br><span class="line">            closure, name, qualname); <span class="comment">/* 函数信息 */</span></span><br></pre></td></tr></table></figure>
<p>经过这一步，我们可以得到大部分的和关键字参数相关的信息，至于<code>_PyEval_EvalCodeWithName</code>具体是怎么处理这些参数的先放在一旁，继续看看扩展参数机制。</p>
<h2 id="可变参数调用"><a href="#可变参数调用" class="headerlink" title="可变参数调用"></a>可变参数调用</h2><p>有几种不同的形式通过可变位置参数来调用函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">f(*b)</span><br><span class="line"><span class="comment"># 22 LOAD_NAME                2 (b)   </span></span><br><span class="line"><span class="comment"># 24 CALL_FUNCTION_EX         0      </span></span><br><span class="line">f(a, *b)</span><br><span class="line"><span class="comment"># 22 LOAD_NAME                1 (a)</span></span><br><span class="line"><span class="comment"># 24 BUILD_TUPLE              1  </span></span><br><span class="line"><span class="comment"># 26 LOAD_NAME                2 (b)    </span></span><br><span class="line"><span class="comment"># 28 BUILD_TUPLE_UNPACK_WITH_CALL     2       </span></span><br><span class="line"><span class="comment"># 30 CALL_FUNCTION_EX         0   </span></span><br><span class="line">f(*b, a)</span><br><span class="line"><span class="comment"># 22 LOAD_NAME                2 (b) </span></span><br><span class="line"><span class="comment"># 24 LOAD_NAME                1 (a)</span></span><br><span class="line"><span class="comment"># 26 BUILD_TUPLE              1       </span></span><br><span class="line"><span class="comment"># 28 BUILD_TUPLE_UNPACK_WITH_CALL     2         </span></span><br><span class="line"><span class="comment"># 30 CALL_FUNCTION_EX         0   </span></span><br><span class="line">f(a, *b, c)</span><br><span class="line"><span class="comment"># 22 LOAD_NAME                1 (a)      </span></span><br><span class="line"><span class="comment"># 24 BUILD_TUPLE              1   </span></span><br><span class="line"><span class="comment"># 26 LOAD_NAME                2 (b)   </span></span><br><span class="line"><span class="comment"># 28 LOAD_NAME                3 (c)   </span></span><br><span class="line"><span class="comment"># 30 BUILD_TUPLE              1 </span></span><br><span class="line"><span class="comment"># 32 BUILD_TUPLE_UNPACK_WITH_CALL     3   </span></span><br><span class="line"><span class="comment"># 34 CALL_FUNCTION_EX         0</span></span><br></pre></td></tr></table></figure>
<p>这几种方式的字节码大同小异，主要设计两个指令<code>BUILD_TUPLE</code>和<code>BUILD_TUPLE_UNPACK_WITH_CALL</code>，我们来看看这两条指令都是做什么用的(省略了部分实现)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从栈顶中弹出oparg个元素，来构建一个元组并压入栈中 */</span></span><br><span class="line">TARGET(BUILD_TUPLE) &#123;</span><br><span class="line">    PyObject *tup = PyTuple_New(oparg);</span><br><span class="line">    <span class="keyword">while</span> (--oparg &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        PyObject *item = POP();</span><br><span class="line">        PyTuple_SET_ITEM(tup, oparg, item);</span><br><span class="line">    &#125;</span><br><span class="line">    PUSH(tup);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TARGET(BUILD_TUPLE_UNPACK_WITH_CALL)</span><br><span class="line">TARGET(BUILD_TUPLE_UNPACK)</span><br><span class="line">TARGET(BUILD_LIST_UNPACK) &#123;</span><br><span class="line">    <span class="keyword">int</span> convert_to_tuple = opcode != BUILD_LIST_UNPACK;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject *sum = PyList_New(<span class="number">0</span>);</span><br><span class="line">    PyObject *return_value;</span><br><span class="line">    <span class="keyword">for</span> (i = oparg; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        PyObject *none_val;</span><br><span class="line">        none_val = _PyList_Extend((PyListObject *)sum, PEEK(i)); <span class="comment">/* 将多个列表合并成一个 */</span></span><br><span class="line">        <span class="comment">/* PEEK()的定义</span></span><br><span class="line"><span class="comment">        define PEEK(n)           (stack_pointer[-(n)])</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (convert_to_tuple) &#123;</span><br><span class="line">        return_value = PyList_AsTuple(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        return_value = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (oparg--)</span><br><span class="line">        Py_DECREF(POP()); <span class="comment">/* 弹出栈上的元素 */</span></span><br><span class="line">    PUSH(return_value); <span class="comment">/* 将构建的元组或列表压栈 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合<code>BUILD_TUPLE</code>和<code>BUILD_TUPLE_UNPACK_WITH_CALL</code>的定义，我们知道无论以什么样的顺序使用可变参数，最终Python需要做的就是将它们打包成一个元组压入运行时栈中</p>
<p>和可变位置参数相似，可变关键字参数也有<code>BUILD_MAP</code>和<code>BUILD_MAP_UNPACK_WITH_CALL</code>，它们达到的效果和前者一样，会将多个关键字参数和<code>**</code>参数打包成一个字典压入栈中。</p>
<p>最后可变参数的处理函数指令都是<code>CALL_FUNCTION_EX</code>(只不过带可变关键字参数的会指令参数为<code>1</code>)。</p>
<p>在下面的<code>CALL_FUNCTION_EX</code>中，我省略掉了大部分的异常处理和引用处理代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TARGET(CALL_FUNCTION_EX) &#123;</span><br><span class="line">    PyObject *func, *callargs, *kwargs = <span class="literal">NULL</span>, *result;</span><br><span class="line">    <span class="keyword">if</span> (oparg &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">        kwargs = POP();</span><br><span class="line">    &#125;</span><br><span class="line">    callargs = POP();</span><br><span class="line">    func = TOP();</span><br><span class="line">    result = do_call_core(func, callargs, kwargs);</span><br><span class="line">    SET_TOP(result);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到逻辑还是很清晰的：如果指令参数为1，那么会先从栈顶弹出关键字参数字典，然后弹出位置参数元组和取得函数对象，最后调用<code>do_call_core</code>执行函数。</p>
<p>在<code>do_call_core</code>中，如果<code>func</code>是函数的话，那么最终执行的<code>PyObject_Call(func, callargs, kwdict);</code>，也就是我们的<code>PyFunction_Type</code>上定义的<code>function_call</code>函数。</p>
<p>在<code>function_call</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">function_call(PyObject *func, PyObject *arg, PyObject *kw)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *result;</span><br><span class="line">    PyObject *argdefs;</span><br><span class="line">    PyObject *kwtuple = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject **d, **k;</span><br><span class="line">    Py_ssize_t nk, nd;</span><br><span class="line"></span><br><span class="line">    argdefs = PyFunction_GET_DEFAULTS(func); <span class="comment">/* 获取默认参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argdefs != <span class="literal">NULL</span> &amp;&amp; PyTuple_Check(argdefs)) &#123;</span><br><span class="line">        d = &amp;PyTuple_GET_ITEM((PyTupleObject *)argdefs, <span class="number">0</span>); <span class="comment">/* 指向默认参数起始地址 */</span></span><br><span class="line">        nd = PyTuple_GET_SIZE(argdefs); <span class="comment">/* 默认参数个数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d = <span class="literal">NULL</span>;</span><br><span class="line">        nd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kw != <span class="literal">NULL</span> &amp;&amp; PyDict_Check(kw)) &#123;</span><br><span class="line">        Py_ssize_t pos, i;</span><br><span class="line">        nk = PyDict_Size(kw);</span><br><span class="line">        kwtuple = PyTuple_New(<span class="number">2</span>*nk);</span><br><span class="line">        <span class="keyword">if</span> (kwtuple == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        k = &amp;PyTuple_GET_ITEM(kwtuple, <span class="number">0</span>); <span class="comment">/* 将关键字参数字典转换成元组 */</span></span><br><span class="line">        pos = i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (PyDict_Next(kw, &amp;pos, &amp;k[i], &amp;k[i+<span class="number">1</span>])) &#123; <span class="comment">/* 对k里面的元素初始化 */</span></span><br><span class="line">            Py_INCREF(k[i]);</span><br><span class="line">            Py_INCREF(k[i+<span class="number">1</span>]);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="comment">/* 最终k是参数名称和参数值交叉形式的元组 */</span></span><br><span class="line">        nk = i/<span class="number">2</span>;  <span class="comment">/* 关键字参数个数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        k = <span class="literal">NULL</span>;</span><br><span class="line">        nk = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result = PyEval_EvalCodeEx(</span><br><span class="line">        PyFunction_GET_CODE(func),</span><br><span class="line">        PyFunction_GET_GLOBALS(func), (PyObject *)<span class="literal">NULL</span>,</span><br><span class="line">        &amp;PyTuple_GET_ITEM(arg, <span class="number">0</span>), PyTuple_GET_SIZE(arg),</span><br><span class="line">        k, nk, d, nd,</span><br><span class="line">        PyFunction_GET_KW_DEFAULTS(func),</span><br><span class="line">        PyFunction_GET_CLOSURE(func));</span><br><span class="line">    Py_XDECREF(kwtuple);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数里面，Python获取了各种函数相关的信息，并调用<code>PyEval_EvalCodeEx</code>。</p>
<p>比较有趣的是，这里关键字参数和指令<code>CALL_FUNCTION_KW</code>中的不一样，之前的关键字参数的名称和值是分开的，而这里以一种名称和值交叉形式的元组打包在一起。所以在<code>PyEval_EvalCodeEx</code>中，需要进一步加工：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> _PyEval_EvalCodeWithName(_co, globals, locals,</span><br><span class="line">                                args, argcount,</span><br><span class="line">                                kws, kws != <span class="literal">NULL</span> ? kws + <span class="number">1</span> : <span class="literal">NULL</span>, <span class="comment">/* 名称和值是相邻的 */</span></span><br><span class="line">                                kwcount, <span class="number">2</span>, <span class="comment">/* step的作用指导虚拟机怎么查找下一个名称和值 */</span></span><br><span class="line">                                defs, defcount,</span><br><span class="line">                                kwdefs, closure,</span><br><span class="line">                                <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>殊途同归，最终还是到了<code>_PyEval_EvalCodeWithName</code>，所以在Python中不管函数是以什么样的方式调用(其实不包括单纯的位置参数调用方式:))，最终都会走到<code>_PyEval_EvalCodeWithName</code>这里。这也是函数处理的一个核心函数，它里面包含了<code>闭包</code>、<code>生成器</code>和<code>协程</code>等的处理。</p>
<h2 id="PyEval-EvalCodeWithName"><a href="#PyEval-EvalCodeWithName" class="headerlink" title="_PyEval_EvalCodeWithName"></a>_PyEval_EvalCodeWithName</h2><p>在看这个函数的时候，我是有点慌的。。。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* This is gonna seem *real weird*, but if you put some other code between</span></span><br><span class="line"><span class="comment">   PyEval_EvalFrame() and PyEval_EvalCodeEx() you will need to adjust</span></span><br><span class="line"><span class="comment">   the test in the if statements in Misc/gdbinit (pystack and pystackv). */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,</span><br><span class="line">           PyObject **args, Py_ssize_t argcount, <span class="comment">/* 位置参数信息 */</span></span><br><span class="line">           PyObject **kwnames, PyObject **kwargs, <span class="comment">/* 关键字参数信息 */</span></span><br><span class="line">           Py_ssize_t kwcount, <span class="keyword">int</span> kwstep,  <span class="comment">/* 关键字参数信息 */</span></span><br><span class="line">           PyObject **defs, Py_ssize_t defcount, <span class="comment">/* 默认参数信息 */</span></span><br><span class="line">           PyObject *kwdefs, PyObject *closure, <span class="comment">/* 仅限关键字信息和闭包 */</span></span><br><span class="line">           PyObject *name, PyObject *qualname) <span class="comment">/* 名称 */</span></span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject* co = (PyCodeObject*)_co;</span><br><span class="line">    PyFrameObject *f;</span><br><span class="line">    PyObject *retval = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject **fastlocals, **freevars;</span><br><span class="line">    PyThreadState *tstate;</span><br><span class="line">    PyObject *x, *u;</span><br><span class="line">    <span class="comment">/* 从code中获取签名的参数总数=位置参数个数+仅限关键字参数个数 */</span></span><br><span class="line">    <span class="keyword">const</span> Py_ssize_t total_args = co-&gt;co_argcount + co-&gt;co_kwonlyargcount; </span><br><span class="line">    Py_ssize_t i, n;</span><br><span class="line">    PyObject *kwdict;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建新的栈桢 */</span></span><br><span class="line">    tstate = PyThreadState_GET();</span><br><span class="line">    f = PyFrame_New(tstate, co, globals, locals);</span><br><span class="line">    <span class="comment">/* localspuls域 */</span></span><br><span class="line">    fastlocals = f-&gt;f_localsplus;</span><br><span class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 有可变关键字参数，则为关键字参数创建一个字典 (**kwags) */</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARKEYWORDS) &#123;</span><br><span class="line">        kwdict = PyDict_New();</span><br><span class="line">        i = total_args; <span class="comment">/* i为签名中已知的位置参数和仅限关键字参数个数 */</span></span><br><span class="line">        <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123; <span class="comment">/* 有可变位置参数，则为可变参数预留一个空槽 */</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        SETLOCAL(i, kwdict); <span class="comment">/* 将可变关键字参数字典设置在localsplus域 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        kwdict = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 调用时的位置参数个数大于签名里的位置参数个数 */</span></span><br><span class="line">    <span class="comment">/* Copy positional arguments into local variables */</span></span><br><span class="line">    <span class="keyword">if</span> (argcount &gt; co-&gt;co_argcount) &#123;</span><br><span class="line">        n = co-&gt;co_argcount; <span class="comment">/* n为签名中的位置参数个数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n = argcount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">/* 将前n个位置参数设置在localsplus域 */</span></span><br><span class="line">        x = args[i];</span><br><span class="line">        Py_INCREF(x);</span><br><span class="line">        SETLOCAL(i, x); <span class="comment">/* 显然位置参数在localsplus域最前面 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把调用时多余的位置参数打包成 *args元组 */</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_VARARGS) &#123;</span><br><span class="line">        u = PyTuple_New(argcount - n);</span><br><span class="line">        SETLOCAL(total_args, u); <span class="comment">/* 把u设置在位置参数+仅限关键字参数之后 */</span></span><br><span class="line">        <span class="keyword">for</span> (i = n; i &lt; argcount; i++) &#123;</span><br><span class="line">            x = args[i];</span><br><span class="line">            Py_INCREF(x);</span><br><span class="line">            PyTuple_SET_ITEM(u, i-n, x); <span class="comment">/* 可变参数元组初始化值 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将关键字参数作为两个平行数组处理 */</span></span><br><span class="line">    kwcount *= kwstep; <span class="comment">/* 乘以step，正确处理kwargs元组中的实际个数 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; kwcount; i += kwstep) &#123;</span><br><span class="line">        PyObject **co_varnames;</span><br><span class="line">        PyObject *keyword = kwnames[i]; <span class="comment">/* 以正确的step取得关键字参数名称 */</span></span><br><span class="line">        PyObject *value = kwargs[i]; <span class="comment">/* 以正确的step取得关键字参数名称 */</span></span><br><span class="line">        Py_ssize_t j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Speed hack: do raw pointer compares. As names are</span></span><br><span class="line"><span class="comment">           normally interned this should almost always hit. */</span></span><br><span class="line">        <span class="comment">/* 快速通道：在函数变量名表中查找是否出现关键字参数名称keyword */</span></span><br><span class="line">        co_varnames = ((PyTupleObject *)(co-&gt;co_varnames))-&gt;ob_item;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; total_args; j++) &#123;</span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="keyword">if</span> (name == keyword) &#123;</span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 慢速通道：在函数变量名表中查找是否出现关键字参数名称keyword */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; total_args; j++) &#123;</span><br><span class="line">            PyObject *name = co_varnames[j];</span><br><span class="line">            <span class="keyword">int</span> cmp = PyObject_RichCompareBool( keyword, name, Py_EQ);</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> kw_found;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果没有找到keyword名称，且函数不允许可变关键字参数，那么报错 */</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= total_args &amp;&amp; kwdict == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                         <span class="string">"%U() got an unexpected keyword argument '%S'"</span>,</span><br><span class="line">                         co-&gt;co_name, keyword);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果允许可变关键字参数，且在函数变量名称表没有找到keyword，</span></span><br><span class="line"><span class="comment">        则将关键字参数设置在可变关键字参数字典中 */</span></span><br><span class="line">        <span class="keyword">if</span> (PyDict_SetItem(kwdict, keyword, value) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      kw_found:</span><br><span class="line">        <span class="comment">/* 在名称表中位置j找到了变量名称，但是已经通过位置参数设置好了，那么会产生冲突报错 */</span></span><br><span class="line">        <span class="keyword">if</span> (GETLOCAL(j) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                         <span class="string">"%U() got multiple values for argument '%S'"</span>,</span><br><span class="line">                         co-&gt;co_name, keyword);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(value);</span><br><span class="line">        <span class="comment">/* 在localsplus相应位置设置好关键字参数 */</span></span><br><span class="line">        SETLOCAL(j, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 位置参数个数大于形参个数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argcount &gt; co-&gt;co_argcount &amp;&amp; !(co-&gt;co_flags &amp; CO_VARARGS)) &#123;</span><br><span class="line">        too_many_positional(co, argcount, defcount, fastlocals);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 位置参数给少了，需要使用默认参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (argcount &lt; co-&gt;co_argcount) &#123;</span><br><span class="line">        Py_ssize_t m = co-&gt;co_argcount - defcount;</span><br><span class="line">        Py_ssize_t missing = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = argcount; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (GETLOCAL(i) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                missing++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (missing) &#123;</span><br><span class="line">            missing_arguments(co, missing, defcount, fastlocals);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m)</span><br><span class="line">            i = n - m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 对于剩余没有给参数值的参数，使用默认位置参数值 */</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; defcount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (GETLOCAL(m+i) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                PyObject *def = defs[i];</span><br><span class="line">                Py_INCREF(def);</span><br><span class="line">                SETLOCAL(m+i, def);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对缺失的关键字参数，使用默认关键字参数值 */</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_kwonlyargcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_ssize_t missing = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = co-&gt;co_argcount; i &lt; total_args; i++) &#123;</span><br><span class="line">            PyObject *name;</span><br><span class="line">            <span class="keyword">if</span> (GETLOCAL(i) != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            name = PyTuple_GET_ITEM(co-&gt;co_varnames, i);</span><br><span class="line">            <span class="keyword">if</span> (kwdefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                PyObject *def = PyDict_GetItem(kwdefs, name);</span><br><span class="line">                <span class="keyword">if</span> (def) &#123;</span><br><span class="line">                    Py_INCREF(def);</span><br><span class="line">                    SETLOCAL(i, def);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            missing++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (missing) &#123;</span><br><span class="line">            missing_arguments(co, missing, <span class="number">-1</span>, fastlocals);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate and initialize storage for cell vars, and copy free</span></span><br><span class="line"><span class="comment">       vars into frame. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_cellvars); ++i) &#123;</span><br><span class="line">        PyObject *c;</span><br><span class="line">        <span class="keyword">int</span> arg;</span><br><span class="line">        <span class="comment">/* Possibly account for the cell variable being an argument. */</span></span><br><span class="line">        <span class="keyword">if</span> (co-&gt;co_cell2arg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            (arg = co-&gt;co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) &#123;</span><br><span class="line">            c = PyCell_New(GETLOCAL(arg));</span><br><span class="line">            <span class="comment">/* Clear the local copy. */</span></span><br><span class="line">            SETLOCAL(arg, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            c = PyCell_New(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        SETLOCAL(co-&gt;co_nlocals + i, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy closure variables to free variables */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) &#123;</span><br><span class="line">        PyObject *o = PyTuple_GET_ITEM(closure, i);</span><br><span class="line">        Py_INCREF(o);</span><br><span class="line">        freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle generator/coroutine/asynchronous generator */</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_flags &amp; (CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR)) &#123;</span><br><span class="line">        PyObject *gen;</span><br><span class="line">        PyObject *coro_wrapper = tstate-&gt;coroutine_wrapper;</span><br><span class="line">        <span class="keyword">int</span> is_coro = co-&gt;co_flags &amp; CO_COROUTINE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_coro &amp;&amp; tstate-&gt;in_coroutine_wrapper) &#123;</span><br><span class="line">            assert(coro_wrapper != <span class="literal">NULL</span>);</span><br><span class="line">            PyErr_Format(PyExc_RuntimeError,</span><br><span class="line">                         <span class="string">"coroutine wrapper %.200R attempted "</span></span><br><span class="line">                         <span class="string">"to recursively wrap %.200R"</span>,</span><br><span class="line">                         coro_wrapper,</span><br><span class="line">                         co);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don't need to keep the reference to f_back, it will be set</span></span><br><span class="line"><span class="comment">         * when the generator is resumed. */</span></span><br><span class="line">        Py_CLEAR(f-&gt;f_back);</span><br><span class="line"></span><br><span class="line">        PCALL(PCALL_GENERATOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create a new generator that owns the ready to run frame</span></span><br><span class="line"><span class="comment">         * and return that as the value. */</span></span><br><span class="line">        <span class="keyword">if</span> (is_coro) &#123;</span><br><span class="line">            gen = PyCoro_New(f, name, qualname);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (co-&gt;co_flags &amp; CO_ASYNC_GENERATOR) &#123;</span><br><span class="line">            gen = PyAsyncGen_New(f, name, qualname);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gen = PyGen_NewWithQualName(f, name, qualname);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gen == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_coro &amp;&amp; coro_wrapper != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyObject *wrapped;</span><br><span class="line">            tstate-&gt;in_coroutine_wrapper = <span class="number">1</span>;</span><br><span class="line">            wrapped = PyObject_CallFunction(coro_wrapper, <span class="string">"N"</span>, gen);</span><br><span class="line">            tstate-&gt;in_coroutine_wrapper = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> wrapped;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retval = PyEval_EvalFrameEx(f,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fail: <span class="comment">/* Jump here from prelude on failure */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* decref'ing the frame can cause __del__ methods to get invoked,</span></span><br><span class="line"><span class="comment">       which can call back into Python.  While we're done with the</span></span><br><span class="line"><span class="comment">       current Python frame (f), the associated C stack is still in use,</span></span><br><span class="line"><span class="comment">       so recursion_depth must be boosted for the duration.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert(tstate != <span class="literal">NULL</span>);</span><br><span class="line">    ++tstate-&gt;recursion_depth;</span><br><span class="line">    Py_DECREF(f);</span><br><span class="line">    --tstate-&gt;recursion_depth;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>名字空间与函数捆绑后的结果被称为一个闭包(closure)。</p>
<p>Python闭包的实现和<code>PyCodeObject</code>的两个属性有关：</p>
<ul>
<li><code>co_cellvars</code>：通常是一个元组，保存嵌套作用域中使用的变量名集合；</li>
<li><code>co_freevars</code>：通常是一个元组，保存使用了的外层作用域中的变量名集合。</li>
</ul>
<p>另外在创建栈桢对象<code>PyFrameObject</code>时也有一个属性和闭包相关，<code>f_localsplus</code>维护的那块内存大小：<br><br><code>extras=code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees</code><br><br>对应着：运行时栈，局部变量，cell对象和free对象。</p>
<p>我们来看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># 0 LOAD_CONST               0 (&lt;code object get_func&gt;)</span></span><br><span class="line"><span class="comment"># 2 LOAD_CONST               1 ('get_func')</span></span><br><span class="line"><span class="comment"># 4 MAKE_FUNCTION            0</span></span><br><span class="line"><span class="comment"># 6 STORE_NAME               0 (get_func)</span></span><br><span class="line"></span><br><span class="line">    value = <span class="string">"value"</span></span><br><span class="line">    <span class="comment"># 0 LOAD_CONST               1 ('value')</span></span><br><span class="line">    <span class="comment"># 2 STORE_DEREF              0 (value)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 4 LOAD_CLOSURE             0 (value)</span></span><br><span class="line">    <span class="comment"># 6 BUILD_TUPLE              1</span></span><br><span class="line">    <span class="comment"># 8 LOAD_CONST               2 (&lt;code object inner_func&gt;)</span></span><br><span class="line">    <span class="comment"># 10 LOAD_CONST               3 ('get_func.&lt;locals&gt;.inner_func')</span></span><br><span class="line">    <span class="comment"># 12 MAKE_FUNCTION            8</span></span><br><span class="line">    <span class="comment"># 14 STORE_FAST               0 (inner_func)</span></span><br><span class="line">        print(value)</span><br><span class="line">        <span class="comment"># 0 LOAD_GLOBAL              0 (print)</span></span><br><span class="line">        <span class="comment"># 2 LOAD_DEREF               0 (value)</span></span><br><span class="line">        <span class="comment"># 4 CALL_FUNCTION            1</span></span><br><span class="line">        <span class="comment"># 6 POP_TOP</span></span><br><span class="line">        <span class="comment"># 8 LOAD_CONST               0 (None)</span></span><br><span class="line">        <span class="comment"># 10 RETURN_VALUE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_func</span><br><span class="line">    <span class="comment"># 16 LOAD_FAST                0 (inner_func)</span></span><br><span class="line">    <span class="comment"># 18 RETURN_VALUE</span></span><br><span class="line"></span><br><span class="line">show_value = get_func()</span><br><span class="line">show_value()</span><br><span class="line"><span class="comment"># 14 LOAD_NAME                1 (show_value)</span></span><br><span class="line"><span class="comment"># 16 CALL_FUNCTION            0</span></span><br><span class="line"><span class="comment"># 18 POP_TOP</span></span><br><span class="line"><span class="comment"># 20 LOAD_CONST               2 (None)</span></span><br><span class="line"><span class="comment"># 22 RETURN_VALUE</span></span><br></pre></td></tr></table></figure>
<p>我们从<code>CALL_FUNCTION</code>指令开始，闭包就是从这里还是处理的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_cellvars); ++i) &#123;</span><br><span class="line">    PyObject *c;</span><br><span class="line">    <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="comment">/* Possibly account for the cell variable being an argument. */</span></span><br><span class="line">    <span class="keyword">if</span> (co-&gt;co_cell2arg != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (arg = co-&gt;co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) &#123;</span><br><span class="line">        c = PyCell_New(GETLOCAL(arg));</span><br><span class="line">        SETLOCAL(arg, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        c = PyCell_New(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    SETLOCAL(co-&gt;co_nlocals + i, c); <span class="comment">/* 存放cell对象在locals后 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于闭包的静态信息，经过编译后存放在<code>PyCodeObject</code>的<code>co_cellvars</code>和<code>co_freevars</code>中，而在创建新的栈桢的时候需要通过这些静态信息，创建<code>cell</code>保存到<code>f_localsplus</code>域中。要注意的是<code>cell</code>的在<code>localsplus</code>域中的位置位于局部变量后。</p>
<p>这些<code>PyCellObject</code>对象十分简单，只有一个<code>ob_ref</code>指向一个<code>object</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	PyObject_HEAD</span><br><span class="line">	PyObject *ob_ref;</span><br><span class="line">&#125; PyCellObject;</span><br></pre></td></tr></table></figure>
<p>这里我们创建的<code>PyCellObject</code>对象的<code>ob_ref</code>指针指向<code>NULL</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyCell_New(PyObject *obj)</span><br><span class="line">&#123;</span><br><span class="line">    PyCellObject *op;</span><br><span class="line">    op = (PyCellObject *)PyObject_GC_New(PyCellObject, &amp;PyCell_Type);</span><br><span class="line">    op-&gt;ob_ref = obj;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们可以看到，在创建完新的栈桢对象后，<code>f_localsplus</code>区域内的这些<code>cell</code>对象的<code>ob_ref</code>依然指向一个空地址，那么是在什么时候初始化的呢？</p>
<p>答案是在调用<code>PyEval_EvalFrameEx(f, 0)</code>执行栈桢的时候，我们可以看到在<code>get_func</code>函数执行过程中，有个字节码就是<code>2 STORE_DEREF 0</code>，这是这个字节码，将：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">freevars = f-&gt;f_localsplus + co-&gt;co_nlocals; <span class="comment">/* 指向f_localsplus中ncells第一个位置 */</span></span><br><span class="line"></span><br><span class="line">TARGET(STORE_DEREF) &#123;</span><br><span class="line">    PyObject *v = POP(); <span class="comment">/* 这里pop弹出的就是在STORE_DEREF前入栈的value */</span></span><br><span class="line">    PyObject *cell = freevars[oparg]; <span class="comment">/* 从f_localsplus中获取cell对象设置ob_ref */</span></span><br><span class="line">    PyObject *oldobj = PyCell_GET(cell);</span><br><span class="line">    PyCell_SET(cell, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>STORE_DEREF</code>从运行时栈中弹出<code>value</code>符号对应的对象值，并将这个变量值和<code>cell</code>对象绑定，通过<code>cell</code>对象我们可以使用这些约束了。</p>
<p><img src="/images/pyfunctionobject-3.png" alt=""></p>
<p>我们再来看看，<code>inner_func</code>函数中是怎么使用这些“冻结”的<code>cell</code>的：在创建<code>inner_func</code>函数对象之前，有个字节码<code>4 LOAD_CLOSURE  0 (value)</code>，这个字节码的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TARGET(LOAD_CLOSURE) &#123;</span><br><span class="line">    PyObject *cell = freevars[oparg];</span><br><span class="line">    PUSH(cell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用很明显，从<code>f_localsplus</code>中获取指令参数指定位置的<code>cell</code>对象，并将它压入运行时栈中。</p>
<p>而在<code>MAKE_FUNCTION</code>创建<code>inner_function</code>函数对象是指令参数为<code>8</code>，那么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oparg &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">    func -&gt;func_closure = POP(); <span class="comment">/* 可以是一个包含多个cell对象的元组，这个例子中元组里只有一个cell */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这到了”搬运工“发挥作用的时刻了，虚拟机将压入栈中的<code>cell</code>对象绑定在了新创建的函数对象<code>func_closure</code>域，现在内部函数就可以使用外部函数”冻结“的变量值了。最后这个新创建的<code>functionobject</code>被放置在栈桢对象的<code>f_localsplus</code>域。</p>
<p><img src="/images/pyfunctionobject-4.png" alt=""></p>
<p>既然内部函数的<code>func_clousre</code>域有了<code>cell</code>对象元组，那么我就可以在执行<code>inner_func</code>的时候，使用外部函数的局部变量了。还是熟悉的配方，在<code>_PyEval_EvalCodeWithName</code>创建栈桢对象过程中，由于内部函数的<code>PyCodeObject</code>有<code>co_freevars</code>，所以我们需要进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) &#123;</span><br><span class="line">    PyObject *o = PyTuple_GET_ITEM(closure, i); <span class="comment">/* 这个closure就是从func对象中获取的func_closure */</span></span><br><span class="line">    freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o; <span class="comment">/* 设置co_cellvars区域后面 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，在将<code>PyFunctionObject</code>携带的<code>func_closure</code>中的<code>PyCellObject</code>，绑定在新的栈桢的<code>f_localsplus</code>域中的<code>free</code>变量区后，就可以引用外部函数的符号了。</p>
<p><img src="/images/pyfunctionobject-5.png" alt=""></p>
<p>和<code>STORE_DEREF</code>指令将运行时栈中的值存放在<code>cell</code>变量区相似，Python也有一个指令<code>LOAD_DEREF</code>从<code>free</code>变量区加载到运行时栈中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TARGET(LOAD_DEREF) &#123;</span><br><span class="line">    PyObject *cell = freevars[oparg];</span><br><span class="line">    PyObject *value = PyCell_GET(cell);</span><br><span class="line">    PUSH(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下“闭包”的处理，几个关键的变量和属性：</p>
<ul>
<li>在<code>PyCodeObject</code>中的<code>co_cellvars</code>和<code>co_freevars</code>；</li>
<li><code>FunctionObject</code>中的<code>func_closure</code>，传递<code>PyCellObject</code>给内部函数；</li>
<li><code>PyFrameObject</code>中的<code>f_localsplus</code>的<code>cell</code>变量区和<code>free</code>变量区；</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器就是”闭包“的一种运用，然后Python在加上装饰器<code>语法糖</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">decorator(func)</span><br></pre></td></tr></table></figure>
<h2 id="未完，待续。。。"><a href="#未完，待续。。。" class="headerlink" title="未完，待续。。。"></a>未完，待续。。。</h2><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2>
    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持作者</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/posts/eab2cd72/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/posts/75b3e8d4/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

  <div id="gitment-comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    (function () {
      var gitment = new Gitment({
        owner: 'zhongshangwu',
        repo: 'zhongshangwu.github.io',
        oauth: {
          client_id: 'ecb8413d71a24ae7e38a',
          client_secret: '6aacbb72400e02734e754fce4b6204ae07ec9dc2'
        },
        
        
        
        
        
        
        
        
      })
      gitment.render('gitment-comments')
    })()
  </script>



    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
