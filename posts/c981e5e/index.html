<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Python源码阅读-函数机制 | Shawn&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Python,源码," />
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.12.0/styles/atom-one-light.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>

  <meta name="description" content="在Python中，函数是一等对象  函数对象">
<meta name="keywords" content="Python,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Python源码阅读-函数机制">
<meta property="og:url" content="http://shawnz.me/posts/c981e5e/index.html">
<meta property="og:site_name" content="Shawn&#39;s Blog">
<meta property="og:description" content="在Python中，函数是一等对象  函数对象">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-1.png">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-2.png">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-3.png">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-4.png">
<meta property="og:image" content="http://shawnz.me/images/pyfunctionobject-5.png">
<meta property="og:updated_time" content="2018-03-10T06:20:54.162Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python源码阅读-函数机制">
<meta name="twitter:description" content="在Python中，函数是一等对象  函数对象">
<meta name="twitter:image" content="http://shawnz.me/images/pyfunctionobject-1.png">

  

  
    <link rel="icon" href="/favicon.png">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/custom.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数对象"><span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无参函数调用"><span class="toc-text">无参函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数参数"><span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位置参数函数调用"><span class="toc-text">位置参数函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认参数函数调用"><span class="toc-text">默认参数函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键词参数函数调用"><span class="toc-text">关键词参数函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可变参数调用"><span class="toc-text">可变参数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PyEval-EvalCodeWithName"><span class="toc-text">_PyEval_EvalCodeWithName</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰器"><span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未完，待续。。。"><span class="toc-text">未完，待续。。。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resources"><span class="toc-text">Resources</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Python源码阅读-函数机制" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Python源码阅读-函数机制</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.01.11</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Shawn Zhong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <blockquote>
<p>在Python中，函数是一等对象</p>
</blockquote>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><a id="more"></a>
<p>在Python中函数的声明和实现的字节码是在不同<code>PyCodeObject</code>中的，它以一种嵌套的形式存储在外层<code>PyCodeObject</code>的<code>co_const</code>常量表中：</p>
<pre><code class="python">def f():
0 LOAD_CONST               0 (&lt;code object f at 0x7ff60e613ed0&gt;)
2 LOAD_CONST               1 (&#39;f&#39;)
4 MAKE_FUNCTION            0
6 STORE_NAME               0 (f)
    print(&quot;func&quot;)

f()
8 LOAD_NAME                0 (f)
10 CALL_FUNCTION            0
12 POP_TOP
14 LOAD_CONST               2 (None)
16 RETURN_VALUE
</code></pre>
<p>我们说<code>PyCodeObject</code>是对源码编译的结果，存储的静态信息，例如：常量表(<code>co_const</code>)，符号表(<code>co_names</code>)以及字节码(<code>co_code</code>)。</p>
<p>而<code>PyFunctionObject</code>则是动态产生的，确切的说是在<code>def f()</code>语句的时候创建的，体现在字节码上就是：</p>
<pre><code class="python">0 LOAD_CONST               0 (&lt;code object f at 0x7ff60e613ed0&gt;)
2 LOAD_CONST               1 (&#39;f&#39;)
4 MAKE_FUNCTION            0
6 STORE_NAME               0 (f)
</code></pre>
<p>这四条指令先后会：将函数<code>f</code>对应的<code>PyCodeObject</code>对象压入栈；把常量表中的<code>f</code>压入栈；构建函数对象<code>PyFunctionObject</code>；以及将键<code>f</code>和值<code>PyFunctionObject</code>存入命名空间(这里<code>f_locals</code>和<code>f_globals</code>是指向同一处命名空间)。</p>
<p>对于一段静态的代码块来说，它只会对应一个<code>PyCodeObject</code>，而可能会创建多个<code>PyFunctionObject</code>。</p>
<p>下面是<code>PyFunctionObject</code>的定义，可以看到函数对应的<code>PyCodeObject</code>会被设置为域<code>func_code</code>：</p>
<pre><code class="c">typedef struct {
    PyObject_HEAD
    PyObject *func_code;    /* A code object, the __code__ attribute */
    PyObject *func_globals;    /* A dictionary (other mappings won&#39;t do) */
    PyObject *func_defaults;    /* NULL or a tuple */
    PyObject *func_kwdefaults;    /* NULL or a dict */
    PyObject *func_closure;    /* NULL or a tuple of cell objects */
    PyObject *func_doc;        /* The __doc__ attribute, can be anything */
    PyObject *func_name;    /* The __name__ attribute, a string object */
    PyObject *func_dict;    /* The __dict__ attribute, a dict or NULL */
    PyObject *func_weakreflist;    /* List of weak references */
    PyObject *func_module;    /* The __module__ attribute, can be anything */
    PyObject *func_annotations;    /* Annotations, a dict or NULL */
    PyObject *func_qualname;    /* The qualified name */
} PyFunctionObject;
</code></pre>
<p>创建函数对象的指令<code>MAKE_FUNCTION</code>，可以在<code>ceval.c</code>中找到对应的实现：</p>
<pre><code class="c">TARGET(MAKE_FUNCTION) {
    PyObject *qualname = POP();
    PyObject *codeobj = POP();
    PyFunctionObject *func = (PyFunctionObject *)
        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);
    ...
    PUSH((PyObject *)func);
}
</code></pre>
<p><code>MAKE_FUNCTION</code>指令首先会从运行时栈中弹出函数的限定名称<code>qualname</code>和函数对应的字节码对象<code>codeobj</code>，并将当前命名空间<code>f_globals</code>作为函数的全局命名空间来创建函数对象(具体的初始化过程这里先不深入)，最后压入运行时栈。</p>
<h2 id="无参函数调用"><a href="#无参函数调用" class="headerlink" title="无参函数调用"></a>无参函数调用</h2><p>创建完函数对象并存入命名空间中后，接下来就可以调用函数了。</p>
<p>我们从最简单的无参函数调用开始，<code>CALL_FUNCTION 0</code>：</p>
<pre><code class="c">TARGET(CALL_FUNCTION) {
    PyObject **sp, *res;
    PCALL(PCALL_ALL);
    sp = stack_pointer;
    res = call_function(&amp;sp, oparg, NULL);
    stack_pointer = sp;
    PUSH(res);
    ...
}
</code></pre>
<p><code>CALL_FUNCTION</code>指令代码中，虚拟机只是保存了栈指针，以在函数调用过后恢复，并将函数调用的结果压入运行时栈。具体的实现在<code>call_function</code>中：</p>
<pre><code class="c">static PyObject *
call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)
{
    PyObject **pfunc = (*pp_stack) - oparg - 1;  /* 获取函数对象 */
    PyObject *func = *pfunc;
    PyObject *x, *w;
    Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames);
    Py_ssize_t nargs = oparg - nkwargs; /* 参数处理 */
    PyObject **stack;

    if (PyCFunction_Check(func)) {  
        ...  /* CFucntion */
    }
    else {
        if (PyMethod_Check(func) &amp;&amp; PyMethod_GET_SELF(func) != NULL) {
            ... /* Method */
        }
        stack = (*pp_stack) - nargs - nkwargs;

        if (PyFunction_Check(func)) {  /* Function */
            x = fast_function(func, stack, nargs, kwnames);
        }
        ...
    }
}
</code></pre>
<p><code>call_function</code>不光在函数调用的时候会使用，<code>CFunction</code>和<code>Method</code>也会调用这个方法。<code>call_function</code>首先要做的就是获取栈上的函数对象，也就是通过指令<code>CALL_FUNCTION</code>前一个指令<code>LOAD_NAME 0</code>压入运行时栈的。在这里指针<code>func</code>指向的是栈顶位置-1的地方(<code>(*pp_stack) - oparg - 1</code>)。</p>
<p>具体的参数处理我们先跳过，来看看<code>fast_function</code>是怎么调用函数的：</p>
<pre><code class="c">static PyObject *
fast_function(PyObject *func, PyObject **stack,
              Py_ssize_t nargs, PyObject *kwnames)
{
    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);  /* code对象 */
    PyObject *globals = PyFunction_GET_GLOBALS(func); /* globals命名空间 */
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func); /* 默认参数 */
    PyObject *kwdefs, *closure, *name, *qualname;
    PyObject **d;
    Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames);
    Py_ssize_t nd;

    PCALL(PCALL_FUNCTION);
    PCALL(PCALL_FAST_FUNCTION);
    /* 一般函数的快速通道 */
    if (co-&gt;co_kwonlyargcount == 0 &amp;&amp; nkwargs == 0 &amp;&amp;
        co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))
    {
        if (argdefs == NULL &amp;&amp; co-&gt;co_argcount == nargs) {
            /* 这是我们调用f()进入的地方 */
            return _PyFunction_FastCall(co, stack, nargs, globals);
        }
        else if (nargs == 0 &amp;&amp; argdefs != NULL
                 &amp;&amp; co-&gt;co_argcount == Py_SIZE(argdefs)) {
            stack = &amp;PyTuple_GET_ITEM(argdefs, 0);
            return _PyFunction_FastCall(co, stack, Py_SIZE(argdefs), globals);
        }
    }

    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
    closure = PyFunction_GET_CLOSURE(func);
    name = ((PyFunctionObject *)func) -&gt; func_name;
    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;

    if (argdefs != NULL) {
        d = &amp;PyTuple_GET_ITEM(argdefs, 0);
        nd = Py_SIZE(argdefs);
    }
    else {
        d = NULL;
        nd = 0;
    }
    return _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)NULL,
                                    ...);
}
</code></pre>
<p>在<code>fast_function</code>做的大部分工作在参数处理上，而这里我们重点关注函数是怎么调用。当使用无参形式调用函数的时候，最终会进入<code>_PyFunction_FastCall</code>快速通道；其他的情况下，会使用<code>_PyEval_EvalCodeWithName</code>处理<code>code</code>对象。</p>
<p>在<code>_PyFunction_FastCall</code>中，虚拟机会创建一个新的<code>frame</code>，并递归调用<code>PyEval_EvalFrameEx</code>来处理栈桢。而在另一条路径<code>_PyEval_EvalCodeWithName</code>，我们知道虚拟机也会创建新的栈桢，最终也是调用<code>PyEval_EvalFrameEx</code>来处理。</p>
<p>所以函数的调用过程就是：创建新的栈桢，在新的栈桢中执行代码。在这个过程中<code>PyFunctionObject</code>只是起到打包和传递<code>code</code>对象以及<code>globals</code>的作用。</p>
<p>下面是<code>_PyFunction_FastCall</code>的实现：</p>
<pre><code class="c">static PyObject*
_PyFunction_FastCall(PyCodeObject *co, PyObject **args, Py_ssize_t nargs,
                     PyObject *globals)
{
    PyFrameObject *f;
    PyThreadState *tstate = PyThreadState_GET();
    PyObject **fastlocals;
    Py_ssize_t i;
    PyObject *result;

    PCALL(PCALL_FASTER_FUNCTION);
    f = PyFrame_New(tstate, co, globals, NULL); /* 创建新的frame */
    if (f == NULL) {
        return NULL;
    }
    /* 处理 */
    fastlocals = f-&gt;f_localsplus;

    for (i = 0; i &lt; nargs; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0); /* 递归处理frame */

    ++tstate-&gt;recursion_depth; /* 递归深度为什么在这里加？ */
    Py_DECREF(f);
    --tstate-&gt;recursion_depth;
    return result;
}
</code></pre>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>上面已经分析过了函数调用的整体框架，现在让我们来加上参数传递机制。</p>
<p>在Python中函数的参数可以分为几类：</p>
<ul>
<li>位置参数：<code>f(a, b)</code>，其中<code>a</code>和<code>b</code>被称为位置参数；</li>
<li>关键字参数：<code>f(a, b, name=&quot;Python&quot;)</code>，其中<code>name</code>被称为关键字参数；</li>
<li>扩展位置参数：<code>f(a, b, *args)</code>，可以使用<code>*</code>收集剩余的位置参数；</li>
<li>扩展关键字参数：<code>f(a, b, **kwargs)</code>，可以使用<code>**</code>收集剩余的关键词参数；</li>
<li>仅限关键字参数：这是Python3中新引入的，<code>f(a, b, *list, c=None, **kwargs)</code>，仅限关键参数必须位于某个<code>*</code>参数或单个<code>*</code>后面，强制使用关键字参数传递。</li>
</ul>
<h2 id="位置参数函数调用"><a href="#位置参数函数调用" class="headerlink" title="位置参数函数调用"></a>位置参数函数调用</h2><p>我们使用一个简单的例子来分析，Python的位置参数的传递和函数调用：</p>
<pre><code class="python">def f(name, age):
# 0 LOAD_CONST               0 (&lt;code object f at 0x7fbd0fe3bed0&gt;)
# 2 LOAD_CONST               1 (&#39;f&#39;)
# 4 MAKE_FUNCTION            0
# 6 STORE_NAME               0 (f)

    print(name, age)
    # 0 LOAD_GLOBAL              0 (print)
    # 2 LOAD_FAST                0 (name)
    # 4 LOAD_FAST                1 (age)
    # 6 CALL_FUNCTION            2
    # 8 POP_TOP

    # 10 LOAD_FAST                1 (age)
    # 12 LOAD_CONST               1 (3)
    # 14 INPLACE_ADD
    # 16 STORE_FAST               1 (age)
    # 18 LOAD_CONST               0 (None)
    # 20 RETURN_VALUE

f(&quot;Python&quot;, 5)
# 8 LOAD_NAME                0 (f)
# 10 LOAD_CONST               2 (&#39;Python&#39;)
# 12 LOAD_CONST               5 (5)
# 14 CALL_FUNCTION            2
# 16 POP_TOP
# 18 LOAD_CONST               4 (None)
# 20 RETURN_VALUE
</code></pre>
<p>和无参函数一样，首先是创建函数对象，在<code>CALL_FUNCTION</code>前会有三条<code>LOAD</code>指令，虚拟机会加载函数需要的参数压入运行时栈，入栈完成后运行时栈如下：</p>
<p><img src="/images/pyfunctionobject-1.png" alt=""></p>
<p>在<code>CALL_FUNCTION 2</code>指令中</p>
<pre><code class="c">TARGET(CALL_FUNCTION) {
    res = call_function(&amp;sp, oparg, NULL);
}

static PyObject *
call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)
{
    PyObject **pfunc = (*pp_stack) - oparg - 1;  /* 获取函数对象 */
    Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames);
    Py_ssize_t nargs = oparg - nkwargs; /* 参数处理 */
    PyObject **stack;
    ...
    /* stack指针将指向第一个参数 */
    stack = (*pp_stack) - nargs - nkwargs;
    x = fast_function(func, stack, nargs, kwnames);
</code></pre>
<p>可以发现<code>CALL_FUNCTION</code>指令在调用<code>call_function</code>方法时传递的参数<code>kwnames</code>是空的，这点和Python2不同，Python3中<code>CALL_FUNCTION</code>指令只会在以位置参数的方式调用函数时使用。</p>
<p>在这里的指令参数<code>oparg</code>为<code>2</code>，代表参数的个数。将栈顶指针减2减1就可以得到我们的<code>PyFunctionObject</code>对象的指针。在处理完参数后，<code>fast_function</code>最终会调用<code>_PyFunction_FastCall</code>进行处理。</p>
<pre><code class="c">static PyObject*
_PyFunction_FastCall(PyCodeObject *co, PyObject **args, Py_ssize_t nargs,
                     PyObject *globals)
{   ...
   f = PyFrame_New(tstate, co, globals, NULL);
    if (f == NULL) {
        return NULL;
    }
    /* 新栈桢的localsplus域 */
    fastlocals = f-&gt;f_localsplus;
    /* 拷贝位置参数 */
    for (i = 0; i &lt; nargs; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0);
</code></pre>
<p>在创建好新的栈桢对象<code>f</code>后，虚拟机会将加载在当前运行时栈中的位置参数<code>Python</code>和<code>5</code>拷贝到新的栈桢的<code>f_localspuls</code>域，这个域里面也包括了栈桢的运行时栈。这时<code>f</code>的运行时栈还是空的，<code>f_localsplus</code>的内存布局如下：</p>
<p><img src="/images/pyfunctionobject-2.png" alt=""></p>
<p>现在，函数参数已经放在了<code>PyFrameObject</code>的<code>f_localsplus</code>域中，那么在函数执行的时候就可以访问和操作这两个参数了。实际上，虚拟机正是通过两条指令<code>LOAD_FAST</code>和<code>STORE_FAST</code>操作<code>f_localspuls</code>这片内存区域的，在<code>_PyEval_EvalFrameDefault</code>中我们可以看到这些操作定义</p>
<pre><code class="c">fastlocals = f-&gt;f_localsplus;  /* 将fastlocals设为f_localsplus域 */
...
#define GETLOCAL(i)     (fastlocals[i])

#define SETLOCAL(i, value)      do { PyObject *tmp = GETLOCAL(i); \
                                     GETLOCAL(i) = value; \
                                     Py_XDECREF(tmp); } while (0)

TARGET(LOAD_FAST) {  /* 将fastlocals中的对象压入运行时栈 */
    PyObject *value = GETLOCAL(oparg);
    Py_INCREF(value);
    PUSH(value);
    FAST_DISPATCH();
}

TARGET(STORE_FAST) { /* 从运行时栈弹出，并存回fastlocals */
    PyObject *value = POP();
    SETLOCAL(oparg, value);
    FAST_DISPATCH();
}
</code></pre>
<p>这样通过位置参数的调用函数过程现在已经比较清晰了：Python会将位置参数值从左到右压入当前栈桢运行时栈，并使用指令<code>CALL_FUNCTION</code>调用函数，最终它会跳转到<code>_PyFunction_FastCall</code>方法中创建新的栈桢，并将运行时栈中的参数值依次存储在新的栈桢的<code>f_localsplus</code>域中，等待函数的执行。</p>
<p>而在函数执行的过程中，Python并没有使用通常的按名称查找的做法，而是通过一个索引(偏移位置)来访问<code>f_localspul</code>域中存储的参数值。这也就是<code>位置参数</code>的由来。</p>
<h2 id="默认参数函数调用"><a href="#默认参数函数调用" class="headerlink" title="默认参数函数调用"></a>默认参数函数调用</h2><p>在继续学习关键字参数之前，我们先看看Python是怎么处理默认参数的。我们猜默认参数应该是在<code>MAKE_FUNCTION</code>里处理的。果然，我们在这条指令的实现处发现了如下代码：</p>
<pre><code class="c">if (oparg &amp; 0x08) {func -&gt;func_closure = POP(); }
if (oparg &amp; 0x04) {func-&gt;func_annotations = POP();}
if (oparg &amp; 0x02) {func-&gt;func_kwdefaults = POP();}
if (oparg &amp; 0x01) {func-&gt;func_defaults = POP();}
</code></pre>
<p>这条指令的参数<code>oparg</code>采用“掩码”的形式实现，如果值为<code>1</code>那么，它会从运行时栈中弹出默认参数，并设为函数对象的<code>func_defaults</code>域。</p>
<p>这一点字节码可以证明，在压入<code>code</code>对象和名称<code>f</code>之前，有一条<code>LOAD_CONST</code>指令将<code>(&#39;Python&#39;, 3)</code>也一并压入了栈中：</p>
<pre><code class="python">def f(name=&quot;Python&quot;, age=3):
# 0 LOAD_CONST               5 ((&#39;Python&#39;, 3)) 
# 2 LOAD_CONST               2 (&lt;code object f at 0x7f2e7f099ed0&gt;
# 4 LOAD_CONST               3 (&#39;f&#39;)   
# 6 MAKE_FUNCTION            1  
    pass
f()
</code></pre>
<p>接下来的调用，依旧是<code>fast_function</code>函数。之前我们看见除了上面的正常无参函数调用外，还有一种情况就是函数调用的时候没有传递参数，但是所有参数都有默认值，这个时候虚拟机也会走<code>_PyFunction_FastCall</code>通道。</p>
<pre><code class="c">static PyObject *
fast_function(PyObject *func, PyObject **stack,
              Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
    ...
    if (co-&gt;co_kwonlyargcount == 0 &amp;&amp; nkwargs == 0 &amp;&amp;
            co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))
        {   /* 正常无参函数调用 */
            if (argdefs == NULL &amp;&amp; co-&gt;co_argcount == nargs) {
                return _PyFunction_FastCall(co, stack, nargs, globals);
            } /* 函数调用没有给参数，但是所有参数都有默认参数值 */
            else if (nargs == 0 &amp;&amp; argdefs != NULL
                    &amp;&amp; co-&gt;co_argcount == Py_SIZE(argdefs)) {
                stack = &amp;PyTuple_GET_ITEM(argdefs, 0);  /* 栈指针指向func_defaults第一个元素 */
                return _PyFunction_FastCall(co, stack, Py_SIZE(argdefs), globals);
            }
        }
}
</code></pre>
<p>到现在应该很明显了，默认参数会在执行函数声明语句的时候，存储在函数对象的<code>func_defaults</code>域，在函数调用的时候使用宏定义<code>PyFunction_GET_DEFAULTS</code>获取这些参数值，并让栈指针指向它。接下来在<code>_PyFunction_FastCall</code>依然会通过<code>*arg++</code>设置好<code>f_localsplus</code>域。</p>
<pre><code class="c">#define PyFunction_GET_DEFAULTS(func) \
    (((PyFunctionObject *)func) -&gt; func_defaults)
</code></pre>
<h2 id="关键词参数函数调用"><a href="#关键词参数函数调用" class="headerlink" title="关键词参数函数调用"></a>关键词参数函数调用</h2><p>Python3中带关键词参数的函数调用指令不再是<code>CALL_FUNCTION</code>了，而是<code>CALL_FUNCTION_KW</code>，还是上一个例子，不过这里在调用函数的时候稍作修改，我们可以看到：</p>
<pre><code class="python">f(&quot;Python&quot;, age=3)
# 8 LOAD_NAME                0 (f) 
# 10 LOAD_CONST               2 (&#39;Python&#39;)       
# 12 LOAD_CONST               3 (3)       
# 14 LOAD_CONST               4 ((&#39;age&#39;,)) 
# 16 CALL_FUNCTION_KW         2    
# ...`
</code></pre>
<p>其他地方和使用位置参数调用函数一样，这里的<code>CALL_FUNTION_KW 2</code>之前多做的一项工作就是把常量表中的符号<code>age</code>，压入运行时栈，来到<code>CALL_FUNTION_KW</code>指令的实现处：</p>
<pre><code class="c">TARGET(CALL_FUNCTION_KW) {
    PyObject **sp, *res, *names;
    names = POP();  /* 弹出关键字参数名称元组 */
    PCALL(PCALL_ALL);
    sp = stack_pointer;
    res = call_function(&amp;sp, oparg, names);
    ...
}
</code></pre>
<p>和<code>CALL_FUNCTION</code>没什么两样，不过是从运行时栈中弹出了最后压入的关键字参数名称。从它只会调用一次<code>POP()</code>，可以知道这些名称是以一个元组形式一起压入栈中，事实上也恰恰如此：<code>((&#39;age&#39;,))</code>。</p>
<p>依旧还是<code>call_function</code>函数，不过现在我们有了<code>knames</code>：</p>
<pre><code class="c">static PyObject *
call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)
{
    PyObject **pfunc = (*pp_stack) - oparg - 1;
    PyObject *func = *pfunc;
    Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames);
    Py_ssize_t nargs = oparg - nkwargs;
</code></pre>
<p>现在我们对这些参数处理有了更进一步的认识：python在传递参数的时候，无论是位置参数还是关键字参数，都会将参数值先压入运行时栈中，对于关键次参数还用<code>kwnames</code>传递关键字参数名称，这样一来虚拟机就可以把这些名称和关键字参数值一一对应起来(隐性要求就是位置参数在前)。</p>
<p>不过这样一来在<code>fast_function</code>中，就不会走<code>_PyFunction_FastCall</code>这条通道了：</p>
<pre><code class="c">static PyObject *
fast_function(PyObject *func, PyObject **stack,
              Py_ssize_t nargs, PyObject *kwnames)
{
    if (co-&gt;co_kwonlyargcount == 0 &amp;&amp; nkwargs == 0 &amp;&amp;
        co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))
    {
        /* 关键字参数就不会走这条通道了 */
        return _PyFunction_FastCall(co, stack, Py_SIZE(argdefs), globals);
    }

    kwdefs = PyFunction_GET_KW_DEFAULTS(func); /* 仅限关键字参数默认值 */
    closure = PyFunction_GET_CL OSURE(func);  /* 闭包 */
    name = ((PyFunctionObject*)func) -&gt; func_name;
    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;

    if (argdefs != NULL) {
        d = &amp;PyTuple_GET_ITEM(argdefs, 0); /* 熟悉的默认参数值 */
        nd = Py_SIZE(argdefs); /* 默认值个数 */
    }
    else {
        d = NULL;
        nd = 0;
    }
    return _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)NULL,
            stack, nargs, /* 位置参数 */
            nkwargs ? &amp;PyTuple_GET_ITEM(kwnames, 0) : NULL, /* 关键字参数名称*/
            stack + nargs, /* 关键字参数值 */
            nkwargs, 1, /* 关键字参数个数以及step */
            d, (int)nd, kwdefs, /* 位置参数默认值， 仅限关键字参数默认值 */
            closure, name, qualname); /* 函数信息 */
</code></pre>
<p>经过这一步，我们可以得到大部分的和关键字参数相关的信息，至于<code>_PyEval_EvalCodeWithName</code>具体是怎么处理这些参数的先放在一旁，继续看看扩展参数机制。</p>
<h2 id="可变参数调用"><a href="#可变参数调用" class="headerlink" title="可变参数调用"></a>可变参数调用</h2><p>有几种不同的形式通过可变位置参数来调用函数：</p>
<pre><code class="python">f(*b)
# 22 LOAD_NAME                2 (b)   
# 24 CALL_FUNCTION_EX         0      
f(a, *b)
# 22 LOAD_NAME                1 (a)
# 24 BUILD_TUPLE              1  
# 26 LOAD_NAME                2 (b)    
# 28 BUILD_TUPLE_UNPACK_WITH_CALL     2       
# 30 CALL_FUNCTION_EX         0   
f(*b, a)
# 22 LOAD_NAME                2 (b) 
# 24 LOAD_NAME                1 (a)
# 26 BUILD_TUPLE              1       
# 28 BUILD_TUPLE_UNPACK_WITH_CALL     2         
# 30 CALL_FUNCTION_EX         0   
f(a, *b, c)
# 22 LOAD_NAME                1 (a)      
# 24 BUILD_TUPLE              1   
# 26 LOAD_NAME                2 (b)   
# 28 LOAD_NAME                3 (c)   
# 30 BUILD_TUPLE              1 
# 32 BUILD_TUPLE_UNPACK_WITH_CALL     3   
# 34 CALL_FUNCTION_EX         0      
</code></pre>
<p>这几种方式的字节码大同小异，主要设计两个指令<code>BUILD_TUPLE</code>和<code>BUILD_TUPLE_UNPACK_WITH_CALL</code>，我们来看看这两条指令都是做什么用的(省略了部分实现)：</p>
<pre><code class="c">/* 从栈顶中弹出oparg个元素，来构建一个元组并压入栈中 */
TARGET(BUILD_TUPLE) {
    PyObject *tup = PyTuple_New(oparg);
    while (--oparg &gt;= 0) {
        PyObject *item = POP();
        PyTuple_SET_ITEM(tup, oparg, item);
    }
    PUSH(tup);
}

TARGET(BUILD_TUPLE_UNPACK_WITH_CALL)
TARGET(BUILD_TUPLE_UNPACK)
TARGET(BUILD_LIST_UNPACK) {
    int convert_to_tuple = opcode != BUILD_LIST_UNPACK;
    Py_ssize_t i;
    PyObject *sum = PyList_New(0);
    PyObject *return_value;
    for (i = oparg; i &gt; 0; i--) {
        PyObject *none_val;
        none_val = _PyList_Extend((PyListObject *)sum, PEEK(i)); /* 将多个列表合并成一个 */
        /* PEEK()的定义
        define PEEK(n)           (stack_pointer[-(n)])
        */
    }
    if (convert_to_tuple) {
        return_value = PyList_AsTuple(sum);
    }
    else {
        return_value = sum;
    }
    while (oparg--)
        Py_DECREF(POP()); /* 弹出栈上的元素 */
    PUSH(return_value); /* 将构建的元组或列表压栈 */
}
</code></pre>
<p>结合<code>BUILD_TUPLE</code>和<code>BUILD_TUPLE_UNPACK_WITH_CALL</code>的定义，我们知道无论以什么样的顺序使用可变参数，最终Python需要做的就是将它们打包成一个元组压入运行时栈中</p>
<p>和可变位置参数相似，可变关键字参数也有<code>BUILD_MAP</code>和<code>BUILD_MAP_UNPACK_WITH_CALL</code>，它们达到的效果和前者一样，会将多个关键字参数和<code>**</code>参数打包成一个字典压入栈中。</p>
<p>最后可变参数的处理函数指令都是<code>CALL_FUNCTION_EX</code>(只不过带可变关键字参数的会指令参数为<code>1</code>)。</p>
<p>在下面的<code>CALL_FUNCTION_EX</code>中，我省略掉了大部分的异常处理和引用处理代码:</p>
<pre><code class="c">TARGET(CALL_FUNCTION_EX) {
    PyObject *func, *callargs, *kwargs = NULL, *result;
    if (oparg &amp; 0x01) {
        kwargs = POP();
    }
    callargs = POP();
    func = TOP();
    result = do_call_core(func, callargs, kwargs);
    SET_TOP(result);
    DISPATCH();
}
</code></pre>
<p>可以看到逻辑还是很清晰的：如果指令参数为1，那么会先从栈顶弹出关键字参数字典，然后弹出位置参数元组和取得函数对象，最后调用<code>do_call_core</code>执行函数。</p>
<p>在<code>do_call_core</code>中，如果<code>func</code>是函数的话，那么最终执行的<code>PyObject_Call(func, callargs, kwdict);</code>，也就是我们的<code>PyFunction_Type</code>上定义的<code>function_call</code>函数。</p>
<p>在<code>function_call</code>中：</p>
<pre><code class="c">static PyObject *
function_call(PyObject *func, PyObject *arg, PyObject *kw)
{
    PyObject *result;
    PyObject *argdefs;
    PyObject *kwtuple = NULL;
    PyObject **d, **k;
    Py_ssize_t nk, nd;

    argdefs = PyFunction_GET_DEFAULTS(func); /* 获取默认参数 */
    if (argdefs != NULL &amp;&amp; PyTuple_Check(argdefs)) {
        d = &amp;PyTuple_GET_ITEM((PyTupleObject *)argdefs, 0); /* 指向默认参数起始地址 */
        nd = PyTuple_GET_SIZE(argdefs); /* 默认参数个数 */
    }
    else {
        d = NULL;
        nd = 0;
    }

    if (kw != NULL &amp;&amp; PyDict_Check(kw)) {
        Py_ssize_t pos, i;
        nk = PyDict_Size(kw);
        kwtuple = PyTuple_New(2*nk);
        if (kwtuple == NULL)
            return NULL;
        k = &amp;PyTuple_GET_ITEM(kwtuple, 0); /* 将关键字参数字典转换成元组 */
        pos = i = 0;
        while (PyDict_Next(kw, &amp;pos, &amp;k[i], &amp;k[i+1])) { /* 对k里面的元素初始化 */
            Py_INCREF(k[i]);
            Py_INCREF(k[i+1]);
            i += 2;
        } /* 最终k是参数名称和参数值交叉形式的元组 */
        nk = i/2;  /* 关键字参数个数 */
    }
    else {
        k = NULL;
        nk = 0;
    }
    result = PyEval_EvalCodeEx(
        PyFunction_GET_CODE(func),
        PyFunction_GET_GLOBALS(func), (PyObject *)NULL,
        &amp;PyTuple_GET_ITEM(arg, 0), PyTuple_GET_SIZE(arg),
        k, nk, d, nd,
        PyFunction_GET_KW_DEFAULTS(func),
        PyFunction_GET_CLOSURE(func));
    Py_XDECREF(kwtuple);
    return result;
}
</code></pre>
<p>在这个函数里面，Python获取了各种函数相关的信息，并调用<code>PyEval_EvalCodeEx</code>。</p>
<p>比较有趣的是，这里关键字参数和指令<code>CALL_FUNCTION_KW</code>中的不一样，之前的关键字参数的名称和值是分开的，而这里以一种名称和值交叉形式的元组打包在一起。所以在<code>PyEval_EvalCodeEx</code>中，需要进一步加工：</p>
<pre><code class="c">return _PyEval_EvalCodeWithName(_co, globals, locals,
                                args, argcount,
                                kws, kws != NULL ? kws + 1 : NULL, /* 名称和值是相邻的 */
                                kwcount, 2, /* step的作用指导虚拟机怎么查找下一个名称和值 */
                                defs, defcount,
                                kwdefs, closure,
                                NULL, NULL);
</code></pre>
<p>殊途同归，最终还是到了<code>_PyEval_EvalCodeWithName</code>，所以在Python中不管函数是以什么样的方式调用(其实不包括单纯的位置参数调用方式:))，最终都会走到<code>_PyEval_EvalCodeWithName</code>这里。这也是函数处理的一个核心函数，它里面包含了<code>闭包</code>、<code>生成器</code>和<code>协程</code>等的处理。</p>
<h2 id="PyEval-EvalCodeWithName"><a href="#PyEval-EvalCodeWithName" class="headerlink" title="_PyEval_EvalCodeWithName"></a>_PyEval_EvalCodeWithName</h2><p>在看这个函数的时候，我是有点慌的。。。</p>
<pre><code class="c">
/* This is gonna seem *real weird*, but if you put some other code between
   PyEval_EvalFrame() and PyEval_EvalCodeEx() you will need to adjust
   the test in the if statements in Misc/gdbinit (pystack and pystackv). */

static PyObject *
_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,
           PyObject **args, Py_ssize_t argcount, /* 位置参数信息 */
           PyObject **kwnames, PyObject **kwargs, /* 关键字参数信息 */
           Py_ssize_t kwcount, int kwstep,  /* 关键字参数信息 */
           PyObject **defs, Py_ssize_t defcount, /* 默认参数信息 */
           PyObject *kwdefs, PyObject *closure, /* 仅限关键字信息和闭包 */
           PyObject *name, PyObject *qualname) /* 名称 */
{
    PyCodeObject* co = (PyCodeObject*)_co;
    PyFrameObject *f;
    PyObject *retval = NULL;
    PyObject **fastlocals, **freevars;
    PyThreadState *tstate;
    PyObject *x, *u;
    /* 从code中获取签名的参数总数=位置参数个数+仅限关键字参数个数 */
    const Py_ssize_t total_args = co-&gt;co_argcount + co-&gt;co_kwonlyargcount; 
    Py_ssize_t i, n;
    PyObject *kwdict;

    /* 创建新的栈桢 */
    tstate = PyThreadState_GET();
    f = PyFrame_New(tstate, co, globals, locals);
    /* localspuls域 */
    fastlocals = f-&gt;f_localsplus;
    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;

    /* 有可变关键字参数，则为关键字参数创建一个字典 (**kwags) */
    if (co-&gt;co_flags &amp; CO_VARKEYWORDS) {
        kwdict = PyDict_New();
        i = total_args; /* i为签名中已知的位置参数和仅限关键字参数个数 */
        if (co-&gt;co_flags &amp; CO_VARARGS) { /* 有可变位置参数，则为可变参数预留一个空槽 */
            i++;
        }
        SETLOCAL(i, kwdict); /* 将可变关键字参数字典设置在localsplus域 */
    }
    else {
        kwdict = NULL;
    }
    /* 调用时的位置参数个数大于签名里的位置参数个数 */
    /* Copy positional arguments into local variables */
    if (argcount &gt; co-&gt;co_argcount) {
        n = co-&gt;co_argcount; /* n为签名中的位置参数个数 */
    }
    else {
        n = argcount;
    }
    for (i = 0; i &lt; n; i++) { /* 将前n个位置参数设置在localsplus域 */
        x = args[i];
        Py_INCREF(x);
        SETLOCAL(i, x); /* 显然位置参数在localsplus域最前面 */
    }

    /* 把调用时多余的位置参数打包成 *args元组 */
    if (co-&gt;co_flags &amp; CO_VARARGS) {
        u = PyTuple_New(argcount - n);
        SETLOCAL(total_args, u); /* 把u设置在位置参数+仅限关键字参数之后 */
        for (i = n; i &lt; argcount; i++) {
            x = args[i];
            Py_INCREF(x);
            PyTuple_SET_ITEM(u, i-n, x); /* 可变参数元组初始化值 */
        }
    }

    /* 将关键字参数作为两个平行数组处理 */
    kwcount *= kwstep; /* 乘以step，正确处理kwargs元组中的实际个数 */
    for (i = 0; i &lt; kwcount; i += kwstep) {
        PyObject **co_varnames;
        PyObject *keyword = kwnames[i]; /* 以正确的step取得关键字参数名称 */
        PyObject *value = kwargs[i]; /* 以正确的step取得关键字参数名称 */
        Py_ssize_t j;

        /* Speed hack: do raw pointer compares. As names are
           normally interned this should almost always hit. */
        /* 快速通道：在函数变量名表中查找是否出现关键字参数名称keyword */
        co_varnames = ((PyTupleObject *)(co-&gt;co_varnames))-&gt;ob_item;
        for (j = 0; j &lt; total_args; j++) {
            PyObject *name = co_varnames[j];
            if (name == keyword) {
                goto kw_found;
            }
        }

        /* 慢速通道：在函数变量名表中查找是否出现关键字参数名称keyword */
        for (j = 0; j &lt; total_args; j++) {
            PyObject *name = co_varnames[j];
            int cmp = PyObject_RichCompareBool( keyword, name, Py_EQ);
            if (cmp &gt; 0) {
                goto kw_found;
            }
            else if (cmp &lt; 0) {
                goto fail;
            }
        }
        /* 如果没有找到keyword名称，且函数不允许可变关键字参数，那么报错 */
        if (j &gt;= total_args &amp;&amp; kwdict == NULL) {
            PyErr_Format(PyExc_TypeError,
                         &quot;%U() got an unexpected keyword argument &#39;%S&#39;&quot;,
                         co-&gt;co_name, keyword);
            goto fail;
        }
        /* 如果允许可变关键字参数，且在函数变量名称表没有找到keyword，
        则将关键字参数设置在可变关键字参数字典中 */
        if (PyDict_SetItem(kwdict, keyword, value) == -1) {
            goto fail;
        }
        continue;

      kw_found:
        /* 在名称表中位置j找到了变量名称，但是已经通过位置参数设置好了，那么会产生冲突报错 */
        if (GETLOCAL(j) != NULL) {
            PyErr_Format(PyExc_TypeError,
                         &quot;%U() got multiple values for argument &#39;%S&#39;&quot;,
                         co-&gt;co_name, keyword);
            goto fail;
        }
        Py_INCREF(value);
        /* 在localsplus相应位置设置好关键字参数 */
        SETLOCAL(j, value);
    }

    /* 位置参数个数大于形参个数 */
    if (argcount &gt; co-&gt;co_argcount &amp;&amp; !(co-&gt;co_flags &amp; CO_VARARGS)) {
        too_many_positional(co, argcount, defcount, fastlocals);
        goto fail;
    }

    /* 位置参数给少了，需要使用默认参数 */
    if (argcount &lt; co-&gt;co_argcount) {
        Py_ssize_t m = co-&gt;co_argcount - defcount;
        Py_ssize_t missing = 0;
        for (i = argcount; i &lt; m; i++) {
            if (GETLOCAL(i) == NULL) {
                missing++;
            }
        }
        if (missing) {
            missing_arguments(co, missing, defcount, fastlocals);
            goto fail;
        }
        if (n &gt; m)
            i = n - m;
        else
            i = 0;
        /* 对于剩余没有给参数值的参数，使用默认位置参数值 */
        for (; i &lt; defcount; i++) {
            if (GETLOCAL(m+i) == NULL) {
                PyObject *def = defs[i];
                Py_INCREF(def);
                SETLOCAL(m+i, def);
            }
        }
    }

    /* 对缺失的关键字参数，使用默认关键字参数值 */
    if (co-&gt;co_kwonlyargcount &gt; 0) {
        Py_ssize_t missing = 0;
        for (i = co-&gt;co_argcount; i &lt; total_args; i++) {
            PyObject *name;
            if (GETLOCAL(i) != NULL)
                continue;
            name = PyTuple_GET_ITEM(co-&gt;co_varnames, i);
            if (kwdefs != NULL) {
                PyObject *def = PyDict_GetItem(kwdefs, name);
                if (def) {
                    Py_INCREF(def);
                    SETLOCAL(i, def);
                    continue;
                }
            }
            missing++;
        }
        if (missing) {
            missing_arguments(co, missing, -1, fastlocals);
            goto fail;
        }
    }

    /* Allocate and initialize storage for cell vars, and copy free
       vars into frame. */
    for (i = 0; i &lt; PyTuple_GET_SIZE(co-&gt;co_cellvars); ++i) {
        PyObject *c;
        int arg;
        /* Possibly account for the cell variable being an argument. */
        if (co-&gt;co_cell2arg != NULL &amp;&amp;
            (arg = co-&gt;co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) {
            c = PyCell_New(GETLOCAL(arg));
            /* Clear the local copy. */
            SETLOCAL(arg, NULL);
        }
        else {
            c = PyCell_New(NULL);
        }
        if (c == NULL)
            goto fail;
        SETLOCAL(co-&gt;co_nlocals + i, c);
    }

    /* Copy closure variables to free variables */
    for (i = 0; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) {
        PyObject *o = PyTuple_GET_ITEM(closure, i);
        Py_INCREF(o);
        freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o;
    }

    /* Handle generator/coroutine/asynchronous generator */
    if (co-&gt;co_flags &amp; (CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR)) {
        PyObject *gen;
        PyObject *coro_wrapper = tstate-&gt;coroutine_wrapper;
        int is_coro = co-&gt;co_flags &amp; CO_COROUTINE;

        if (is_coro &amp;&amp; tstate-&gt;in_coroutine_wrapper) {
            assert(coro_wrapper != NULL);
            PyErr_Format(PyExc_RuntimeError,
                         &quot;coroutine wrapper %.200R attempted &quot;
                         &quot;to recursively wrap %.200R&quot;,
                         coro_wrapper,
                         co);
            goto fail;
        }

        /* Don&#39;t need to keep the reference to f_back, it will be set
         * when the generator is resumed. */
        Py_CLEAR(f-&gt;f_back);

        PCALL(PCALL_GENERATOR);

        /* Create a new generator that owns the ready to run frame
         * and return that as the value. */
        if (is_coro) {
            gen = PyCoro_New(f, name, qualname);
        } else if (co-&gt;co_flags &amp; CO_ASYNC_GENERATOR) {
            gen = PyAsyncGen_New(f, name, qualname);
        } else {
            gen = PyGen_NewWithQualName(f, name, qualname);
        }
        if (gen == NULL)
            return NULL;

        if (is_coro &amp;&amp; coro_wrapper != NULL) {
            PyObject *wrapped;
            tstate-&gt;in_coroutine_wrapper = 1;
            wrapped = PyObject_CallFunction(coro_wrapper, &quot;N&quot;, gen);
            tstate-&gt;in_coroutine_wrapper = 0;
            return wrapped;
        }

        return gen;
    }

    retval = PyEval_EvalFrameEx(f,0);

fail: /* Jump here from prelude on failure */

    /* decref&#39;ing the frame can cause __del__ methods to get invoked,
       which can call back into Python.  While we&#39;re done with the
       current Python frame (f), the associated C stack is still in use,
       so recursion_depth must be boosted for the duration.
    */
    assert(tstate != NULL);
    ++tstate-&gt;recursion_depth;
    Py_DECREF(f);
    --tstate-&gt;recursion_depth;
    return retval;
}
</code></pre>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>名字空间与函数捆绑后的结果被称为一个闭包(closure)。</p>
<p>Python闭包的实现和<code>PyCodeObject</code>的两个属性有关：</p>
<ul>
<li><code>co_cellvars</code>：通常是一个元组，保存嵌套作用域中使用的变量名集合；</li>
<li><code>co_freevars</code>：通常是一个元组，保存使用了的外层作用域中的变量名集合。</li>
</ul>
<p>另外在创建栈桢对象<code>PyFrameObject</code>时也有一个属性和闭包相关，<code>f_localsplus</code>维护的那块内存大小：<br><br><code>extras=code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees</code><br><br>对应着：运行时栈，局部变量，cell对象和free对象。</p>
<p>我们来看一个简单的例子：</p>
<pre><code class="python">def get_func():
# 0 LOAD_CONST               0 (&lt;code object get_func&gt;)
# 2 LOAD_CONST               1 (&#39;get_func&#39;)
# 4 MAKE_FUNCTION            0
# 6 STORE_NAME               0 (get_func)

    value = &quot;value&quot;
    # 0 LOAD_CONST               1 (&#39;value&#39;)
    # 2 STORE_DEREF              0 (value)
    def inner_func():
    # 4 LOAD_CLOSURE             0 (value)
    # 6 BUILD_TUPLE              1
    # 8 LOAD_CONST               2 (&lt;code object inner_func&gt;)
    # 10 LOAD_CONST               3 (&#39;get_func.&lt;locals&gt;.inner_func&#39;)
    # 12 MAKE_FUNCTION            8
    # 14 STORE_FAST               0 (inner_func)
        print(value)
        # 0 LOAD_GLOBAL              0 (print)
        # 2 LOAD_DEREF               0 (value)
        # 4 CALL_FUNCTION            1
        # 6 POP_TOP
        # 8 LOAD_CONST               0 (None)
        # 10 RETURN_VALUE

    return inner_func
    # 16 LOAD_FAST                0 (inner_func)
    # 18 RETURN_VALUE

show_value = get_func()
show_value()
# 14 LOAD_NAME                1 (show_value)
# 16 CALL_FUNCTION            0
# 18 POP_TOP
# 20 LOAD_CONST               2 (None)
# 22 RETURN_VALUE
</code></pre>
<p>我们从<code>CALL_FUNCTION</code>指令开始，闭包就是从这里还是处理的：</p>
<pre><code class="c">for (i = 0; i &lt; PyTuple_GET_SIZE(co-&gt;co_cellvars); ++i) {
    PyObject *c;
    int arg;
    /* Possibly account for the cell variable being an argument. */
    if (co-&gt;co_cell2arg != NULL &amp;&amp;
        (arg = co-&gt;co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) {
        c = PyCell_New(GETLOCAL(arg));
        SETLOCAL(arg, NULL);
    }
    else {
        c = PyCell_New(NULL);
    }
    if (c == NULL)
        goto fail;
    SETLOCAL(co-&gt;co_nlocals + i, c); /* 存放cell对象在locals后 */
}
</code></pre>
<p>对于闭包的静态信息，经过编译后存放在<code>PyCodeObject</code>的<code>co_cellvars</code>和<code>co_freevars</code>中，而在创建新的栈桢的时候需要通过这些静态信息，创建<code>cell</code>保存到<code>f_localsplus</code>域中。要注意的是<code>cell</code>的在<code>localsplus</code>域中的位置位于局部变量后。</p>
<p>这些<code>PyCellObject</code>对象十分简单，只有一个<code>ob_ref</code>指向一个<code>object</code>：</p>
<pre><code class="c">typedef struct {
    PyObject_HEAD
    PyObject *ob_ref;
} PyCellObject;
</code></pre>
<p>这里我们创建的<code>PyCellObject</code>对象的<code>ob_ref</code>指针指向<code>NULL</code>：</p>
<pre><code class="c">PyObject *
PyCell_New(PyObject *obj)
{
    PyCellObject *op;
    op = (PyCellObject *)PyObject_GC_New(PyCellObject, &amp;PyCell_Type);
    op-&gt;ob_ref = obj;
    return (PyObject *)op;
}
</code></pre>
<p>上面我们可以看到，在创建完新的栈桢对象后，<code>f_localsplus</code>区域内的这些<code>cell</code>对象的<code>ob_ref</code>依然指向一个空地址，那么是在什么时候初始化的呢？</p>
<p>答案是在调用<code>PyEval_EvalFrameEx(f, 0)</code>执行栈桢的时候，我们可以看到在<code>get_func</code>函数执行过程中，有个字节码就是<code>2 STORE_DEREF 0</code>，这是这个字节码，将：</p>
<pre><code class="c">freevars = f-&gt;f_localsplus + co-&gt;co_nlocals; /* 指向f_localsplus中ncells第一个位置 */

TARGET(STORE_DEREF) {
    PyObject *v = POP(); /* 这里pop弹出的就是在STORE_DEREF前入栈的value */
    PyObject *cell = freevars[oparg]; /* 从f_localsplus中获取cell对象设置ob_ref */
    PyObject *oldobj = PyCell_GET(cell);
    PyCell_SET(cell, v);
}
</code></pre>
<p><code>STORE_DEREF</code>从运行时栈中弹出<code>value</code>符号对应的对象值，并将这个变量值和<code>cell</code>对象绑定，通过<code>cell</code>对象我们可以使用这些约束了。</p>
<p><img src="/images/pyfunctionobject-3.png" alt=""></p>
<p>我们再来看看，<code>inner_func</code>函数中是怎么使用这些“冻结”的<code>cell</code>的：在创建<code>inner_func</code>函数对象之前，有个字节码<code>4 LOAD_CLOSURE  0 (value)</code>，这个字节码的定义如下</p>
<pre><code class="c">TARGET(LOAD_CLOSURE) {
    PyObject *cell = freevars[oparg];
    PUSH(cell);
}
</code></pre>
<p>作用很明显，从<code>f_localsplus</code>中获取指令参数指定位置的<code>cell</code>对象，并将它压入运行时栈中。</p>
<p>而在<code>MAKE_FUNCTION</code>创建<code>inner_function</code>函数对象是指令参数为<code>8</code>，那么：</p>
<pre><code class="c">if (oparg &amp; 0x08) {
    func -&gt;func_closure = POP(); /* 可以是一个包含多个cell对象的元组，这个例子中元组里只有一个cell */
}
</code></pre>
<p>这到了”搬运工“发挥作用的时刻了，虚拟机将压入栈中的<code>cell</code>对象绑定在了新创建的函数对象<code>func_closure</code>域，现在内部函数就可以使用外部函数”冻结“的变量值了。最后这个新创建的<code>functionobject</code>被放置在栈桢对象的<code>f_localsplus</code>域。</p>
<p><img src="/images/pyfunctionobject-4.png" alt=""></p>
<p>既然内部函数的<code>func_clousre</code>域有了<code>cell</code>对象元组，那么我就可以在执行<code>inner_func</code>的时候，使用外部函数的局部变量了。还是熟悉的配方，在<code>_PyEval_EvalCodeWithName</code>创建栈桢对象过程中，由于内部函数的<code>PyCodeObject</code>有<code>co_freevars</code>，所以我们需要进行处理：</p>
<pre><code class="c">for (i = 0; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) {
    PyObject *o = PyTuple_GET_ITEM(closure, i); /* 这个closure就是从func对象中获取的func_closure */
    freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o; /* 设置co_cellvars区域后面 */
}
</code></pre>
<p>所以，在将<code>PyFunctionObject</code>携带的<code>func_closure</code>中的<code>PyCellObject</code>，绑定在新的栈桢的<code>f_localsplus</code>域中的<code>free</code>变量区后，就可以引用外部函数的符号了。</p>
<p><img src="/images/pyfunctionobject-5.png" alt=""></p>
<p>和<code>STORE_DEREF</code>指令将运行时栈中的值存放在<code>cell</code>变量区相似，Python也有一个指令<code>LOAD_DEREF</code>从<code>free</code>变量区加载到运行时栈中：</p>
<pre><code class="c">TARGET(LOAD_DEREF) {
    PyObject *cell = freevars[oparg];
    PyObject *value = PyCell_GET(cell);
    PUSH(value);
}
</code></pre>
<p>总结一下“闭包”的处理，几个关键的变量和属性：</p>
<ul>
<li>在<code>PyCodeObject</code>中的<code>co_cellvars</code>和<code>co_freevars</code>；</li>
<li><code>FunctionObject</code>中的<code>func_closure</code>，传递<code>PyCellObject</code>给内部函数；</li>
<li><code>PyFrameObject</code>中的<code>f_localsplus</code>的<code>cell</code>变量区和<code>free</code>变量区；</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器就是”闭包“的一种运用，然后Python在加上装饰器<code>语法糖</code>。</p>
<pre><code class="python">@decorator
def func():
    pass
# 等价于
decorator(func)
</code></pre>
<h2 id="未完，待续。。。"><a href="#未完，待续。。。" class="headerlink" title="未完，待续。。。"></a>未完，待续。。。</h2><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2>
    
  </div>

  
      <div class="git"></div>
  

</article>

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持作者</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/posts/eab2cd72/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/posts/75b3e8d4/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

  <div id="gitment-comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
    (function () {
      var gitment = new Gitment({
        owner: 'zhongshangwu',
        repo: 'zhongshangwu.github.io',
        oauth: {
          client_id: 'ecb8413d71a24ae7e38a',
          client_secret: '6aacbb72400e02734e754fce4b6204ae07ec9dc2'
        },
        
        
        
        
        
        
        
        
      })
      gitment.render('gitment-comments')
    })()
  </script>



    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
