<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shawn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shawnz.me/"/>
  <updated>2018-03-11T02:06:19.093Z</updated>
  <id>http://shawnz.me/</id>
  
  <author>
    <name>Shawn Zhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 工作流</title>
    <link href="http://shawnz.me/posts/6e627ce8/"/>
    <id>http://shawnz.me/posts/6e627ce8/</id>
    <published>2018-03-11T02:03:43.000Z</published>
    <updated>2018-03-11T02:06:19.093Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序员的自我修养" scheme="http://shawnz.me/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="Git" scheme="http://shawnz.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-线性代数篇</title>
    <link href="http://shawnz.me/posts/178a40c8/"/>
    <id>http://shawnz.me/posts/178a40c8/</id>
    <published>2018-03-11T01:27:14.000Z</published>
    <updated>2018-03-11T01:33:38.765Z</updated>
    
    <content type="html"><![CDATA[<p>$f(x)=x_2$</p><p>$$<br>\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$f(x)=x_2$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} 
      
    
    </summary>
    
      <category term="机器学习" scheme="http://shawnz.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://shawnz.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="http://shawnz.me/posts/5e21c553/"/>
    <id>http://shawnz.me/posts/5e21c553/</id>
    <published>2018-03-10T09:36:51.000Z</published>
    <updated>2018-03-11T01:28:59.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间安排模板"><a href="#时间安排模板" class="headerlink" title="时间安排模板"></a>时间安排模板</h2><table><thead><tr><th style="text-align:center">第N周</th><th style="text-align:center">周一</th><th style="text-align:center">周二</th><th style="text-align:center">周三</th><th style="text-align:center">周四</th><th style="text-align:center">周五</th><th style="text-align:center">周六</th><th style="text-align:center">周日</th></tr></thead><tbody><tr><td style="text-align:center">06:30~07:00</td><td style="text-align:center">洗漱</td><td style="text-align:center">洗漱</td><td style="text-align:center">洗漱</td><td style="text-align:center">洗漱</td><td style="text-align:center">洗漱</td><td style="text-align:center">洗漱</td><td style="text-align:center">洗漱</td></tr><tr><td style="text-align:center">07:00~09:00</td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td></tr><tr><td style="text-align:center">10:00~12:00</td><td style="text-align:center">工作</td><td style="text-align:center">工作</td><td style="text-align:center">工作</td><td style="text-align:center">工作</td><td style="text-align:center">工作</td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td></tr><tr><td style="text-align:center">13:30~19:30</td><td style="text-align:center">工作</td><td style="text-align:center">工作</td><td style="text-align:center">工作</td><td style="text-align:center">工作</td><td style="text-align:center">工作</td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td></tr><tr><td style="text-align:center">21:00~:24:00</td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td><td style="text-align:center"><code>学习</code></td></tr></tbody></table><p><strong>2018-03-10总结与反思: </strong></p><ul><li style="list-style: none"><input type="checkbox" checked> 完成了哪些任务?</li><li style="list-style: none"><input type="checkbox"> 还有哪些人物没有完成?</li></ul><h2 id="任务概览"><a href="#任务概览" class="headerlink" title="任务概览"></a>任务概览</h2><ol><li>英语</li><li>Python开发</li><li>程序员基本修养: 网络/数据库/算法/操作系统…</li><li>系统设计/软件工程</li><li>其他语言: Java/前端/Go</li><li>机器学习/大数据处理</li><li>开源项目</li><li>业余爱好: 看书/健身</li></ol><h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><table><thead><tr><th style="text-align:center">第2周</th><th>周一</th><th>周二</th><th>周三</th><th>周四</th><th>周五</th><th>周六</th><th>周日</th></tr></thead><tbody><tr><td style="text-align:center">06:30~07:00</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:center">07:00~09:00</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:center">10:00~12:00</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:center">13:30~19:30</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:center">21:00~:24:00</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时间安排模板&quot;&gt;&lt;a href=&quot;#时间安排模板&quot; class=&quot;headerlink&quot; title=&quot;时间安排模板&quot;&gt;&lt;/a&gt;时间安排模板&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;第N周&lt;/t
      
    
    </summary>
    
    
      <category term="计划" scheme="http://shawnz.me/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>理解 asyncio</title>
    <link href="http://shawnz.me/posts/cc755aee/"/>
    <id>http://shawnz.me/posts/cc755aee/</id>
    <published>2018-01-30T15:26:24.000Z</published>
    <updated>2018-03-11T02:41:17.594Z</updated>
    
    <content type="html"><![CDATA[<p>在本篇文章, 我试图从三个方面: 协程, Python对协程的语法支持以及<code>asyncio</code>库, 来理解事件驱动的异步编程.</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们先给协程一个正式的定义: <strong>“协程是为非抢占式多任务产生子程序的计算机程序组件, 协程允许不同入口点在不同位置暂停或开始执行程序”</strong>(来自维基百科).</p><h3 id="协程和线程"><a href="#协程和线程" class="headerlink" title="协程和线程"></a>协程和线程</h3><p>从协程的定义, 我们可以很好的区分协程和线程行为上的区别: 协程由应用程序提供机制提供, 属于”协作式多任务”; 而线程一般由操作系统提供, CPU负责调度, 属于”抢占式多任务”. </p><p>尽管协程和线程都能用来”并发”编程, 但需要考虑到使用多线程会有以下几个问题:</p><ul><li>线程在计算和资源消耗的角度是较为昂贵的;</li><li>在使用线程进行”并发”编程时, 需要考虑访问共享资源时, “竞态条件”和”锁机制”带来的复杂性和安全性问题;</li><li>由于<code>GIL</code>的存在, Python的多线程无法发挥多核CPU的计算能力, 只有在遇到I/O阻塞的时, 才会释放<code>GIL</code>锁.</li><li>既然Python的多线程更适用于”I/O”密集的场景, 那么在这种情形下, 使用协程替代线程应该能得到更好的性能.</li></ul><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>在继续学习协程之前, 我们弄明白什么是事件循环?</p><p>比如大部分的网络服务器框架, 诸如<code>werkzeug</code>,<code>Django</code>等实现的<code>HTTPServer</code>, 在底层都是使用I/O多路复用机制处理客户端连接的:</p><pre><code class="python">def loop():    while not QUIT:        events = selector.select(events_to_listen, timeout)        for event in events:            process_request(events)</code></pre><p>这里的<code>loop</code>就相当于是一个事件循环, 它等待操作系统的事件通知, 并执行相应请求处理函数(回调函数).</p><p>这里的<code>select</code>会阻塞直到请求的到来(或超时), 其实<code>select</code>底层的实现也是一个事件循环, 轮询监听的文件描述符<code>fd</code>, 在<code>fd</code>数据准备好时, 返回文件描述符, 不过我们先不关心这些. 尽管这里会发生阻塞, 但是其好处是在有大量并发连接的情况下, 使用IO多路复用不会造成: 阻塞在单个IO下, 而导致无法处理其他请求. 它会在有任何连接准备好的时候, 返回文件描述符.</p><p>(PS: 不知道我这里理解的事件循环有没有问题…)</p><p>事件循环: “是一种等待程序分配事件或消息的编程架构”(来自wiki). 简单来讲, 事件循环是一种循环机制, 监听哪些事件发生了, 并关心事件发生时做什么处理, 让你可以在”A发生时, 执行B”. </p><p>然而, 要想设计健壮的WEB 服务框架, 单单这点还不够, 目前请求的处理都发生在单个线程中, 像<code>socket.recv()</code>、访问数据库以及读写文件等都会发生阻塞, 导致阻塞整个事件循环. 所以, 一般的WEB服务器还提供了多线程/多进程的选项, 能够以线程或进程的方式处理请求. 另外一种思路是, 将事件循环放在一个单独的子线程里, 事件的处理都放在主线程中.</p><p>事件循环机制是理解异步编程的核心之一, 另一个核心就是协程.</p><h3 id="协程和回调"><a href="#协程和回调" class="headerlink" title="协程和回调"></a>协程和回调</h3><p>回到事件驱动的主题上来, 当事件发生时, 事件循环机制需要找到相应的处理函数, 尽管WEB框架的处理函数一般就一个, 然后再做分派. 但是更一般的, 像<code>JS</code>中的事件就很多, 比如<code>OnClick</code>事件, 往往需要将回调函数绑定到相应的事件上, 这样才能在事件发生时执行对应的回调函数. 这就是异步机制.</p><p>当回调发生时, 我们可能会碰到下面这种情况:</p><pre><code class="python">def stage_1(response_1):  # 回调函数1    request_2 = step_1(reponse_1) # 对响应处理, 并生成新的请求2    def stage_2(response_2):        request_3 = step_2(reponse_2)        def stage_3(response_3):            step_3(reponse_3)        api_call_3(request_3, stage_3) # 调用新的API函数3, 注册回调函数3    api_call_2(request_2, stage_2)  # 调用新的API函数2, 注册回调函数2api_call_1(request_1, stage_1)  # 调用API函数1, 注册回调函数1</code></pre><ul><li>代码结构不清晰: 同步的代码结构是从上往下, 而嵌套回调的结构会导致<code>callback hell</code>.</li><li>上下文状态丢失: 执行下一个回调的时候, 无法获取上一步的<code>request_1</code>的信息. 如果需要那个值, 必须通过参数传递, 或者闭包实现.</li><li>异常处理: 当<code>api_call_2</code>发生异常时, 无法在<code>stage_1</code>函数中捕获, 因为是<code>api_call_2</code>异步调用. <code>JS</code>针对这个问题的解决方案是, 注册两个回调函数, 其中有一个用作异常处理, 这样以来就变得更加复杂了.</li></ul><p>同样的代码逻辑, 我们可以用另外一种方式来重构:</p><pre><code class="python">@asyncio.coroutinedef three_stages(request_1):    response_1 = yield from api_call_1(request_1) # 第一步    request_2 = step(response_1) # 第二步    reponse_2 = yield from api_call_2(request_2)    reqeust_3 = step(response_2) # 第三步    response_3 = yield from api_call_3(request_3)loop.create_task(three_stages(request_1)) # 必须显示调用</code></pre><p>使用协程不会存在上面那些问题, 因为整个任务执行是顺序的, 并且在一个上下文中, 如果需要捕捉异常的话, 可以使用<code>try/catch</code>将<code>yield from</code>语句包裹起来.</p><h2 id="Python语法"><a href="#Python语法" class="headerlink" title="Python语法"></a>Python语法</h2><h3 id="yield和yield-from"><a href="#yield和yield-from" class="headerlink" title="yield和yield from"></a>yield和yield from</h3><p>PEP 342 中定义了协程的底层架构, 并在Python2.5中实现了. 至此<code>yield</code>成为表达式, 能够暂停执行产生值.</p><p>PEP 342 中为生成器API添加了<code>send()</code>方法, 可以将数据给暂停的的生成器, 发送的值成为<code>yield</code>表达式的值. 这样以来, 生成器就可以作为协程使用了.</p><p>PEP 380 为Python3.3引入了<code>yield from</code>语法, 以便生成器能够更好地作为协程使用. 在生成器<code>gen</code>中调用<code>yield from subgen()</code>时, <code>subgen</code>会获得控制权, 把产生的值返回给调用方, 即调用方可以直接控制<code>subgen</code>. 与此同时, <code>gen</code>会挂起, 等待<code>subgen</code>返回值(终止). <code>yield from</code>可以把复杂的生成器重构为小型的嵌套生成器. 例如:</p><pre><code class="python">def subgen():    while True:        x = yield &#39;subgen&#39;def gen():    yield from &#39;AB&#39;    yield from range(1, 3)    yield from subgen()</code></pre><p><code>yield from x</code>表达式对<code>x</code>所做的第一件事就是, 调用<code>iter(x)</code>, 从中获得迭代器. </p><p>到现在为止, <code>yield</code>和<code>yield from</code>定义的生成器完全可以作为协程的实现. 仔细一点话, 我们可以发现两者的细微区别:</p><ul><li>生成器更注重保存状态和产生值;</li><li>协程强调协同控制程序流, 是数据的消费者. (尽管使用生成器定义的协程也会<code>yield</code>产生值)</li></ul><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p>现在有个问题是, 在调用<code>yield from gen_or_cor()</code>时, 我们无法确定遍历的是生成器还是协程. </p><p><code>asyncio.coroutine</code>和<code>types.coroutine</code>两个装饰器的作用就是: 为消除语法上的歧义. 前者是<code>asyncio</code>库的实现, 后者是Python3.5新加入的语言实现, 它会给函数的<code>__code__.co_flags</code>添加<code>CO_ITERABLE_COROUTINE</code>标识. </p><p>随后Yury Selivanov提交的 “PEP 492—Coroutines with async and await syntax”, 在 Python3.5 中得以实现, 新加了两个关键字<code>async</code>和<code>await</code>. 使用<code>async def</code>定义的函数称为”原生协程”, 它会设置<code>CO_COROUTINE</code>标识. </p><p>到现在为止, 协程和生成器很明确的区分开来了, 另外还有两个标识:</p><ul><li><code>CO_COROUTINE</code>: 标识的是原生协程, 使用<code>async def</code>定义;</li><li><code>CO_ITERABLE_COROUTINE</code>: 基于迭代器的协程, 使用<code>types.coroutine</code>装饰.</li></ul><p>在定义了协程之后, PEP 492 引入了<code>await</code>来调用协程, 它只能在<code>async def</code>协程函数内部使用:</p><pre><code class="python">async def read_data(db):    data = await db.fetch(&#39;SELECT ...&#39;)    ...</code></pre><p><code>await</code>的用法和<code>yield from</code>相似, 暂停<code>read_data</code>协程的执行, 直到<code>db.fetch</code>完成并返回结果数据.</p><p>实际上, <code>await</code>内部使用<code>yield from</code>实现, 不过它对参数进行了一些额外的验证, 接受一个<code>awaitable</code>对象:</p><ul><li>原生协程. <code>collections.abc.Coroutine</code>继承自<code>Awaitable</code>, 自然没有问题;</li><li>基于迭代器的协程, 因为<code>inspect.isawaitable</code>内部会识别<code>CO_ITERABLE_COROUTINE</code>标识.</li><li>实现了<code>__await__</code>方法(必须返回一个迭代器)的对象, 即<code>collections.abc.Awaitable</code>.</li></ul><p>我们再来看看这个讨论<a href="">《为什么只有基于生成器的协程可以真正的暂停执行并强制性返回给事件循环？》</a>.</p><p>我的理解是真正暂停执行并让步, 将控制权交给事件循环的地方一定发生在<code>yield</code>处. 而<code>await/yield from</code>都没有交出控制权, 它们会进入到里层的协程, 直到碰到一个<code>yield</code>, 又或者是一个实现<code>__await__</code>方法的<code>awaitable</code>, 这个方法返回的也是一个迭代器.<br>而原生协程的语法是不允许使用<code>yield</code>的, 所以就会有上面那种说法.</p><p>不过在实际使用中, 我们使用<code>await asyncio.sleep(1)</code>这些包装过的协程函数就OK了, 框架会帮我们处理底层的逻辑.</p><hr><p>除了协程函数外, PEP 492 还提出了<code>async for</code>和<code>async with</code>的用法:</p><p><strong>异步上下文管理器和”async with”</strong></p><p>异步上下文管理器指的是在<code>enter</code>和<code>exit</code>方法处能够暂停执行的上下文管理器.</p><p>为了实现这样的功能, 需要加入两个新的<code>magic method</code>: <code>__aenter__</code>和<code>__aexit__</code>. 这两个方法都要返回一个<code>awaitable</code>对象.</p><pre><code class="python">class AsyncContextManager: # 定义一个上下文管理器    async def __aenter__(self):        await log(&quot;entering context...&quot;)    async def __aexit__(self, exc_type, exc, tb):        await log(&quot;exiting context...&quot;)async def commit(session, data):  # 实现一个数据库事务管理器    async with session.transaction():        await session.update(data)</code></pre><p>和常规的<code>with</code>表达式一样, 可以在一个<code>async with</code>表达式中指定多个上下文管理器.</p><p>如果向<code>async with</code>表达式传入的上下文管理器中没有<code>__aenter__</code>和<code>__aexit__</code>方法, 这将引起一个错误. 如果在<code>async def</code>函数外面使用<code>async with</code>，将引起一个<code>SyntaxError</code>.</p><p><strong>异步迭代器和”async for”</strong></p><p>一个异步可迭代对象(<code>asynchronous iterable</code>)能够在迭代过程中调用异步代码, 而异步迭代器就是能够在<code>next</code>方法中调用异步代码. 为了支持异步迭代:</p><ol><li>一个对象必须实现<code>__aiter__</code>方法, 该方法返回一个异步迭代器(<code>asynchronous iterator</code>)对象; </li><li>一个异步迭代器对象必须实现<code>__anext__</code>方法，该方法返回一个<code>awaitable</code>对象;</li><li>为了停止迭代, <code>__anext__</code>必须抛出一个<code>StopAsyncIteration</code>异常.</li></ol><pre><code class="python">class AsyncIterable:  ## 定义一个异步迭代器    def __aiter__(self):        return self    async def __anext__(self):        data = await self.fetch_data()        if data:            return data        else:            raise StopAsyncIteration    async def fetch_data(self):        ...async def cor():  # 使用异步迭代器    async for data in AsyncInterable():        await process_data(data)</code></pre><p>把一个没有<code>__aiter__</code>方法的迭代对象传递给<code>async for</code>将引起<code>TypeError</code>. </p><p>和<code>async with</code>, <code>await</code>一样, 在<code>async def</code>函数外部使用<code>async for</code>将引起一个<code>SyntaxError</code>.</p><p>和常规的<code>for</code>表达式一样, <code>async for</code>也有一个可选的<code>else</code>分支.</p><p>和正常的生成器抛出<code>StopIteration</code>异常告知停止迭代一样, 异步迭代器抛出<code>StopAsyncIteration</code>告知外围代码迭代结束.</p><p>另外在 “PEP 497–Change StopIteration handling inside generators” 中规定, 所有协程中抛出的<code>StopIteration</code>异常, 都被包装在<code>RuntimeError</code>中.</p><hr><p>在 PEP 525–Asynchronous Generators 中提出的异步生成器, 在Python3.6中实现了. 在这之前<code>async def</code>内部不允许出现<code>yield</code>表达式, 而在 Python3.6 中, 使用<code>yield</code>表达式可以定义一个异步生成器. 文档中提出: 经过测试, 异步生成器的性能是异步迭代器的2倍.</p><p>文档中给出了一个”每次迭代延迟给定秒数并打印数字”的例子:</p><pre><code class="python">class Ticker:  # 异步迭代器版本    def __init__(self, delay, to):        self.delay = delay        self.i = 0        self.to = to    def __aiter__(self):        return self    async def __anext__(self):        i = self.i        if i &gt;= self.to:            raise StopAsyncIteration        self.i += 1        if i:            await asyncio.sleep(self.delay)        return iasync def ticker(delay, to): # 异步生成器版本    for i in range(to):        yield i        await asyncio.sleep(delay)</code></pre><p>异步生成器也实现了<code>__aiter__</code>和<code>__anext__</code>方法. 在异步生成器里面使用<code>return</code>语句将引起<code>SyntaxError</code>.</p><h2 id="出租车运营仿真"><a href="#出租车运营仿真" class="headerlink" title="出租车运营仿真"></a>出租车运营仿真</h2><p>到这里, 我们已经大致了解了异步编程的一些概念性问题和Python对协程的语法支持. 在真正接触<code>asyncio</code>库之前, 我们从一个出租车运营仿真程序(参考”流畅的Python”的离散仿真)开始, 想想怎么实现一个基于事件的异步编程框架.</p><p>假设有几辆出租车, 每辆车会拉几个乘客, 然后回家. 出租车首先驶离车库, 四处徘徊, 寻找乘客; 拉到乘客后, 行程开始; 行程结束, 乘客下车, 继续四处徘徊…</p><p>开始动手之前, 我们先想想, 都需要实现些什么?</p><ol><li>我们可以协程的方式模拟出租车的生命周期, 这一步应该不难, 利用<code>async/await</code>等可以实现阻塞调用时让步. </li><li>有N辆出租车, 如果不用线程实现并发, 那么我们需要一个事件循环, 来驱动协程执行.</li><li>实现一个<code>sleep</code>函数, 模拟出租车耗时的阻塞操作, 这个函数必须是一个<code>generator-based coroutine</code>, 因为需要<code>yield</code>让步.</li></ol><pre><code class="python">import randomimport asyncioimport timeimport heapq@asyncio.coroutinedef sleep(seconds):    now = time.time()    wait_until = now + seconds    actual = yield wait_until  # 让步, 并产出下次唤醒的时间    return actual - now  # 返回实际等待了多长时间async def taxi_coro(ident, trips, delay=0):    print(&quot;taxt {ident}: waiting {delay} seconds before leave garage...&quot;.          format(ident=ident, delay=delay))    detal = await sleep(delay)  # 每辆车延迟delay秒出发    print(&quot;taxi {ident} leave from garage after {detal}&quot;.          format(ident=ident, detal=int(detal)))    for i in range(trips):        print(&quot;taxi {ident} hover around... &quot;.format(ident=ident))        detal = await sleep(random.randint(0, 10))        print(&quot;taxi {ident} pick up passenger afer {detal}&quot;.format(ident=ident, detal=int(detal)))        detal = await sleep(random.randint(0, 10))        print(&quot;taxi {ident} drop off passenger afer {detal}&quot;.format(ident=ident, detal=int(detal)))    print(&quot;taxi {ident} going to home...&quot;.format(ident=ident))    detal = await sleep(random.randint(0, 10))    print(&quot;taxi {ident} has arrived at home afer {detal}!&quot;.format(ident=ident, detal=int(detal)))class Task():    def __init__(self, wait_until, coro):        self.waiting_until = wait_until        self.coro = coro    def __eq__(self, other):        return self.waiting_until == other.waiting_until    def __lt__(self, other):        return self.waiting_until &lt; other.waiting_untilclass EventLoop:    def __init__(self, *coros):        self._new = coros        self._waiting = []    def run_until_complete(self):        for coro in self._new:            wait_until = coro.send(None)  # 协程预激            heapq.heappush(self._waiting, Task(wait_until, coro))  # Task加入优先队列        while self._waiting:            now = time.time()            task = heapq.heappop(self._waiting)  # 获取最近需要执行的task            if now &lt; task.waiting_until:  # 还没到task的执行时间                detal = task.waiting_until - now  # 还需要等待时间                time.sleep(detal)  # 直接阻塞事件循环            try:                now = time.time()                wait_until = task.coro.send(now)                heapq.heappush(self._waiting, Task(wait_until, task.coro))            except StopIteration as e:                passdef main():    loop = EventLoop(taxi_coro(&#39;A&#39;, 4), taxi_coro(&#39;B&#39;, 3, 3), taxi_coro(&#39;C&#39;, 2, 4))    now = time.time()    loop.run_until_complete()    print(&quot;Total elapsed time is {}&quot;.format(time.time - now))if __name__ == &#39;__main__&#39;:    main()</code></pre><p>下面输出结果:</p><pre><code class="bash">taxt A: waiting 0 seconds before leave garage...taxt B: waiting 3 seconds before leave garage...taxt C: waiting 4 seconds before leave garage...taxi A leave from garage after 0taxi A hover around... taxi B leave from garage after 3taxi B hover around... taxi C leave from garage after 4taxi C hover around... taxi C pick up passenger afer 2taxi A pick up passenger afer 7taxi A drop off passenger afer 1taxi A hover around... taxi B pick up passenger afer 7taxi C drop off passenger afer 8taxi C hover around... taxi C pick up passenger afer 0taxi A pick up passenger afer 7taxi B drop off passenger afer 8taxi B hover around... taxi C drop off passenger afer 8taxi C going to home...taxi A drop off passenger afer 9taxi A hover around... taxi B pick up passenger afer 10taxi A pick up passenger afer 5taxi C has arrived at home, total elapsed 30!taxi B drop off passenger afer 4taxi B hover around... taxi A drop off passenger afer 6taxi A hover around... taxi A pick up passenger afer 5taxi A drop off passenger afer 1taxi A going to home...taxi B pick up passenger afer 10taxi A has arrived at home, total elapsed 43!taxi B drop off passenger afer 7taxi B going to home...taxi B has arrived at home, total elapsed 50!Total elapsed time is 50  # 总耗时等于耗时最长的那辆的行程时间</code></pre><p>从输出结果我们可以发现, 总的耗时时长和耗时最长的出租车的行驶时长相当. 在这个例子里面, 使用了<code>sleep</code>产出一个唤醒时间并作出让步, 来模拟异步的阻塞调用. 然而实际应用中这些阻塞调用, 往往涉及I/O, 网络等, 不可能产生一个唤醒时间给事件循环, 这是就需要引入一个概念”Future”(期物), 能够在任务完成时…</p><h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p><code>asyncio</code>是Python 3.4 引入的异步I/O框架(PEP 3156), 提供了使用协程编写单线程并发代码、通过sockets和其他方式进行多路I/O访问、运行网络客户端和服务端以及其他相关原语的基础设施. 正如文档中提出的, 提供的组件详细列表如下:</p><ul><li>一个包含各种特定系统实现的模块化事件循环(event loop);</li><li>传输和协议抽象(类似于Twisted);</li><li>对TCP、UDP、SSL、子进程管道(subprogress pipes)、延时调用以及其他的具体支持(有些可能是系统相关的);</li><li>模仿concurrent.futures模块但适于事件循环(event loop)使用的Future类;</li><li>基于yield from(PEP 380)的协程和任务，可以让你用顺序的方式编写并发代码;</li><li>可以中止的Future和协程;</li><li>模仿threading模块中的同步原语，可以用在单线程内的协程之间;</li><li>当你不得不去使用一个将产生阻塞I/O的调用时，有接口可以把这个事件转移到线程池(threadpool).</li></ul><p>下面是官方文档中给出的一个例子:</p><pre><code class="python">import asyncioasync def compute(x, y):    print(&quot;Compute %s + %s ...&quot; % (x, y))    await asyncio.sleep(1.0)    return x + yasync def print_sum(x, y):    result = await compute(x, y)    print(&quot;%s + %s = %s&quot; % (x, y, result))loop = asyncio.get_event_loop()loop.run_until_complete(print_sum(1, 2))loop.close()</code></pre><p>上面代码的执行流程如下:</p><p><img src="/images/tulip_coro.png" alt=""></p><p>执行过程概述如下:</p><ul><li>获取当前的事件循环</li><li>加入</li></ul><p>未完待续…</p><h3 id="Coroutine-Future-Task"><a href="#Coroutine-Future-Task" class="headerlink" title="Coroutine, Future, Task"></a>Coroutine, Future, Task</h3><h3 id="Event-Loop-Policy"><a href="#Event-Loop-Policy" class="headerlink" title="Event Loop [Policy]"></a>Event Loop [Policy]</h3><h3 id="Tansport-Protocol"><a href="#Tansport-Protocol" class="headerlink" title="Tansport, Protocol"></a>Tansport, Protocol</h3><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><code>&gt;&gt;&gt;</code> <a href="https://www.python.org/dev/peps/pep-255/" target="_blank" rel="noopener">PEP 255 – Simple Generators</a><br><br><code>&gt;&gt;&gt;</code> <a href="https://www.python.org/dev/peps/pep-342/" target="_blank" rel="noopener">PEP 342 – Coroutines via Enhanced Generators</a><br><br><code>&gt;&gt;&gt;</code> <a href="https://www.python.org/dev/peps/pep-380/" target="_blank" rel="noopener">PEP 380 – Syntax for Delegating to a Subgenerator</a><br><br><code>&gt;&gt;&gt;</code> <a href="https://www.python.org/dev/peps/pep-0492/" target="_blank" rel="noopener">PEP 492 – Coroutines with async and await syntax</a><br><br><code>&gt;&gt;&gt;</code> <a href="https://www.python.org/dev/peps/pep-3156/" target="_blank" rel="noopener">PEP 3156 – Asynchronous IO Support Rebooted: the “asyncio” Module</a><br><br><code>&gt;&gt;&gt;</code> <a href="https://www.youtube.com/watch?v=1coLC-MUCJc" target="_blank" rel="noopener">Tulip: Async I/O for Python 3</a><br><br><code>&gt;&gt;&gt;</code> <a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/" target="_blank" rel="noopener">How the heck does async/await work in Python 3.5?</a><br><br><code>&gt;&gt;&gt;</code> <a href="http://www.aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" target="_blank" rel="noopener">A Web Crawler With asyncio Coroutines</a><br><br><code>&gt;&gt;&gt;</code> <a href="https://www.kancloud.cn/kindjeff/asyncio-zh/217023" target="_blank" rel="noopener">Python3 asyncio官方文档中文版</a><br><br><code>&gt;&gt;&gt;</code> <a href="http://blog.dreamfever.me/the-magic-of-asyncio-1/" target="_blank" rel="noopener">异步的魔法 — asyncio 源码剖析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本篇文章, 我试图从三个方面: 协程, Python对协程的语法支持以及&lt;code&gt;asyncio&lt;/code&gt;库, 来理解事件驱动的异步编程.&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="异步编程" scheme="http://shawnz.me/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Vim 快捷键</title>
    <link href="http://shawnz.me/posts/16764984/"/>
    <id>http://shawnz.me/posts/16764984/</id>
    <published>2018-01-29T18:43:46.000Z</published>
    <updated>2018-03-10T06:20:54.198Z</updated>
    
    <content type="html"><![CDATA[<!--  --><a id="more"></a><p>记录常用的<code>Vim</code>命令…</p><h2 id="光标移动-Cursor-Movement"><a href="#光标移动-Cursor-Movement" class="headerlink" title="光标移动(Cursor Movement)"></a>光标移动(Cursor Movement)</h2><table><thead><tr><th>命令</th><th>作用（解释）</th></tr></thead><tbody><tr><td><code>h</code>,<code>j</code>,<code>k</code>,<code>l</code>,<code>h</code></td><td>表示往左，j表示往下，k表示往右，l表示往上</td></tr><tr><td><code>Ctrl</code>+<code>f</code></td><td>上一页</td></tr><tr><td><code>Ctrl</code>+<code>b</code></td><td>下一页</td></tr><tr><td><code>w</code>, <code>e</code>, <code>W</code>, <code>E</code></td><td>跳到单词的后面，小写包括标点</td></tr><tr><td><code>b</code>, <code>B</code></td><td>以单词为单位往前跳动光标，小写包含标点</td></tr><tr><td><code>O</code></td><td>开启新的一行</td></tr><tr><td><code>^</code></td><td>一行的开始</td></tr><tr><td><code>$</code></td><td>一行的结尾</td></tr><tr><td><code>gg</code></td><td>文档的第一行</td></tr><tr><td><code>[N]G</code></td><td>文档的第N行或者最后一行</td></tr></tbody></table><h2 id="插入模式-Insert-Mode"><a href="#插入模式-Insert-Mode" class="headerlink" title="插入模式(Insert Mode)"></a>插入模式(Insert Mode)</h2><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td><code>i</code></td><td>插入到光标前面</td></tr><tr><td><code>I</code></td><td>插入到行的开始位置</td></tr><tr><td><code>a</code></td><td>插入到光标的后面</td></tr><tr><td><code>A</code></td><td>插入到行的最后位置</td></tr><tr><td><code>o</code>, <code>O</code></td><td>新开一行</td></tr><tr><td><code>Esc</code></td><td>关闭插入模式</td></tr></tbody></table><h2 id="编辑-Editing"><a href="#编辑-Editing" class="headerlink" title="编辑(Editing)"></a>编辑(Editing)</h2><table><thead><tr><th>命令</th><th>作用（解释）</th></tr></thead><tbody><tr><td><code>r</code></td><td>在插入模式替换光标所在的一个字符</td></tr><tr><td><code>J</code></td><td>合并下一行到上一行</td></tr><tr><td><code>s</code></td><td>删除光标所在的一个字符, 光标还在当行</td></tr><tr><td><code>S</code></td><td>删除光标所在的一行，光标还在当行，不同于dd</td></tr><tr><td><code>u</code></td><td>撤销上一步操作</td></tr><tr><td><code>ctrl</code>+<code>r</code></td><td>恢复上一步操作</td></tr><tr><td><code>.</code></td><td>重复最后一个命令</td></tr><tr><td><code>~</code></td><td>变换为大写</td></tr><tr><td><code>[N]&gt;&gt;</code></td><td>一行或N行往右移动一个tab</td></tr><tr><td><code>[N]&lt;&lt;</code></td><td>一行或N行往左移动一个tab</td></tr></tbody></table><h2 id="关闭-Exiting"><a href="#关闭-Exiting" class="headerlink" title="关闭(Exiting)"></a>关闭(Exiting)</h2><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td><code>:w</code></td><td>保存</td></tr><tr><td><code>:wq</code>, <code>:x</code></td><td>保存并关闭</td></tr><tr><td><code>:q</code></td><td>关闭（已保存）</td></tr><tr><td><code>:q!</code></td><td>强制关闭</td></tr></tbody></table><h2 id="搜索-Search"><a href="#搜索-Search" class="headerlink" title="搜索(Search)"></a>搜索(Search)</h2><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td><code>/pattern</code></td><td>搜索（非插入模式)</td></tr><tr><td><code>?pattern</code></td><td>往后搜索</td></tr><tr><td><code>n</code></td><td>光标到达搜索结果的前一个目标</td></tr><tr><td><code>N</code></td><td>光标到达搜索结果的后一个目标</td></tr></tbody></table><h2 id="视觉模式-Visual-Mode"><a href="#视觉模式-Visual-Mode" class="headerlink" title="视觉模式(Visual Mode)"></a>视觉模式(Visual Mode)</h2><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td><code>v</code></td><td>选中一个或多个字符</td></tr><tr><td><code>V</code></td><td>选中一行</td></tr></tbody></table><h2 id="剪切和复制-Cut-and-Paste"><a href="#剪切和复制-Cut-and-Paste" class="headerlink" title="剪切和复制(Cut and Paste)"></a>剪切和复制(Cut and Paste)</h2><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td><code>dd</code></td><td>删除一行</td></tr><tr><td><code>dw</code></td><td>删除一个单词</td></tr><tr><td><code>x</code></td><td>删除后一个字符</td></tr><tr><td><code>X</code></td><td>删除前一个字符</td></tr><tr><td><code>D</code></td><td>删除一行最后一个字符</td></tr><tr><td><code>[N]yy</code></td><td>复制一行或者N行</td></tr><tr><td><code>yw</code></td><td>复制一个单词</td></tr><tr><td><code>p</code></td><td>粘贴</td></tr></tbody></table><h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><table><thead><tr><th>命令</th><th>作用（解释)</th></tr></thead><tbody><tr><td><code>:split</code></td><td>水平方向分割出一个窗口</td></tr><tr><td><code>:vsplit</code></td><td>垂直方向分割出一个窗口</td></tr><tr><td><code>:close</code></td><td>关闭窗口</td></tr><tr><td><code>Ctrl</code>+<code>W</code></td><td>切换窗口, h到左边窗口，j到下方窗口，k到上方窗口，l到右边窗口</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;!--  --&gt;
    
    </summary>
    
      <category term="工具" scheme="http://shawnz.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://shawnz.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="快捷键" scheme="http://shawnz.me/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构与应用</title>
    <link href="http://shawnz.me/posts/85682d75/"/>
    <id>http://shawnz.me/posts/85682d75/</id>
    <published>2018-01-27T13:39:01.000Z</published>
    <updated>2018-03-10T06:20:54.198Z</updated>
    
    <content type="html"><![CDATA[<p><code>Redis</code>可以存储键与5种不同数据结构类型之间的映射, 这五种数据结构类型分别为: <code>STRING</code>,<code>LIST</code>,<code>SET</code>,<code>ZSET</code>和<code>HASH</code>.</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><code>Redis</code>没有采用C语言传统的字符串表示(以空字符结尾的字符数组), 而是自己构建了一种名为”简单动态字符串”(simple dynamic string, SDS)的抽象结构来表示字符串.</p><p>C字符串只会作为字符串字面量, 用在一些无须对字符串值作修改的地方, 如打印日志.</p><pre><code class="c">redisLog(REDIS_WARNING,&quot;Redis is now ready to exit, bye bye...&quot;);</code></pre><a id="more"></a><p>而在键值存储的时候, <code>Redis</code>会使用<code>SDS</code>来表示字符串, 值的大小不能超过<code>512MB</code>, 其中可以存储以下三种类型值:</p><ul><li>字节串(byte string)</li><li>整数</li><li>浮点数</li></ul><p><code>Redis</code>的字符串有几个特性:</p><ul><li><code>SDS</code>结构会保存字符串长度信息, 所以<code>STRLEN</code>命令的时间复杂度为<code>O(1)</code>;</li><li><code>SDS</code>采用内存预分配和惰性内存释放策略, 来优化减少内存重分配次数;</li><li>二进制安全: 由于<code>Redis</code>不采用空字符作为字符串的结尾标志, 而是记录字符串长度, 所以可以用来保存一系列的二进制数据;</li><li>虽然<code>SDS</code>的字符串是二进制安全的, 但它仍然遵循C字符串以空字符结尾的惯例, 所以可以重用一些C函数来操作字符串.</li></ul><p><strong>应用</strong></p><ul><li>计数器或ID生成器</li><li>将数据打包成位, 需要数据具有连续性质. 优点是存储空间少, 使用位运算速度快. 例如: <code>Bitemap</code>, 定长数据存储.</li><li>分布式锁</li></ul><p><strong>Redis分布式锁</strong></p><p>实现一个<code>Redis</code>分布式锁, 需要注意几点:</p><ul><li><p>Q: 获取的锁需要一个过期时间, 避免在客户端持有锁的途中宕机而导致锁得不到释放.<br><br>  A: <code>Redis</code>可以很容易地给键添加<code>Expire</code>过期时间.</p></li><li><p>Q: 获取锁和设置锁的过期时间必须是原子的, 否则客户端依旧可能在中间过程宕机.<br><br>  A: <code>SET</code>命令, 可以设置过期时间, 并保证原子性.</p></li><li><p>Q: 设置锁的过期时间, 设置多久? 过短的话, 锁会在持有阶段被错误的释放掉, 不安全的访问共享资源; 过长的话, 会导致其他客户端长时间无法正常工作.<br><br>  A: 可选的做法是<code>fencing token</code>机制. 客户端在成功获取锁时, <code>Redis</code>服务器会返回锁和一个单调递增的数字. 如果锁已经失效, 且被其他客户端获取的话, 那么失效的客户端在使用<code>fencing token</code>访问共享资源时就会失败(因为有了一个更大的值). <br><br>  然而关于生成<code>fencing token</code>和资源服务器结构如何处理<code>fencing token</code>又是另外一个难点了.<br>  另外一种做法是资源服务器实现一个<code>Check-and-Set</code>的原子机制来拒绝延迟请求, 不保证请求的有序(因为没有递增的<code>fencing token</code>, 使用无序的<code>identifier</code>), 但是保证处理的互斥.</p></li><li><p>Q: 释放锁, 需要一个随机值<code>identifier</code>, 保证客户端释放的是自己持有的锁?<br><br>  A: 这里使用<code>uuid</code>生成一个随机字符串作为<code>identifier</code>.</p></li><li><p>Q: 释放锁时, 必须保证检查<code>identifier</code>和释放锁是原子的, 锁可能在检查和释放的中间过程中, 被过期释放掉, 导致客户端释放了其他客户端持有的锁.<br><br>  A: 一种做法是使用<code>Redis</code>的”事务”; 另一种做法使用<code>Lua</code>脚本.</p></li><li><p>Q: 还有一个就是单节点<code>Redis</code>无法保证锁的高可用, 需要采用<code>Redis</code>“复制”, 而<code>Redis</code>的主从复制是异步的, 在故障转移的过程中会丧失锁的安全性.<br><br>  A: 采用分布式锁算法<code>RedLock</code>, 基于<code>N</code>个完全独立的<code>Redis</code>节点. 然而<code>RedLock</code>是构建在不安全的系统模型之上, 它对系统的计记时假设(<code>timing assumption</code>)有着比较强的依赖.</p></li></ul><p>这里有一个简单的<code>Redis</code>实现分布式锁实现:</p><pre><code class="python">import timeimport uuidimport threadingimport redisconn = redis.Redis()def acquire_lock(conn, lockname, timeout=10):    identifier = str(uuid.uuid4())    end = time.time() + timeout    while time.time() &lt; end:        if conn.set(name=&quot;lock:&quot; + lockname, value=identifier, nx=True, px=30000):            print(&quot;acquire_lock...&quot;)            return identifier        time.sleep(1)    return Falsedef release_lock(conn, lockname, identifier):    if not lockname:        return False    lockname = &quot;lock:&quot; + lockname    while True:        try:            pipeline = conn.pipeline(True)            pipeline.watch(lockname)            if pipeline.get(lockname) == identifier.encode(&#39;utf-8&#39;):                pipeline.multi()                pipeline.delete(lockname)                pipeline.execute()                print(&quot;release_lock...&quot;)                return True            pipeline.unwatch()            break        except redis.exceptions.WatchError as e:            raise eclass Resource:    def __init__(self):        self.identifier = &quot;&quot;        self.value = 0        self.mutex = threading.Lock()    def check_and_set(self, identifier, value):        with self.mutex:            if self.identifier == identifier:                self.value = valueif __name__ == &quot;__main__&quot;:    resource = Resource()    thread_nums = 5    threads = []    def incr():        identifier = acquire_lock(conn, &#39;test&#39;)        if identifier:            resource.identifier = identifier            for i in range(100):                value = resource.value + 1                resource.check_and_set(identifier, value)            release_lock(conn, &#39;test&#39;, identifier)    for i in range(thread_nums):        thread = threading.Thread(target=incr)        threads.append(thread)    for thread in threads:        thread.start()    for thread in threads:        thread.join()    print(resource.value)</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表的底层是双向链表实现的, 并且通过几个属性保存了链表的头部, 尾部以及长度信息, 所以一些操作, 例如: <code>LLEN</code>, <code>LPOP</code>和<code>RPOP</code>都是<code>O(1)</code>的时间复杂度.</p><p><code>Redis</code>的列表允许用户从两端推入或弹出元素, 以及各种常见的列表操作. 利用列表的特性, 我们可以实现许多实用的功能, 例如:</p><ul><li>消息队列(通知类, 延迟更新类)</li><li>自动补全最近联系人</li><li>时间轴(很容易截断)</li></ul><p><strong>自动补全</strong></p><p>下面是一个保存最近100名联系人的”自动补全”实现的例子:</p><pre><code class="python">import redisconn = redis.Redis()def add_update_contacts(conn, user, contact):    ac_list = &#39;recent:&#39; + user    pipe = conn.pipeline(True)    pipe.lrem(ac_list, contact)    pipe.lpush(ac_list, contact)    pipe.ltrim(ac_list, 0, 99)    pipe.execute()def fetch_autocomplete_list(conn, user, prefix):    candidates = conn.lrange(&#39;recent:&#39; + user, 0, -1)    suggestions = []    for candidate in candidates:        if candidate.lower().decode(&#39;utf8&#39;).startswith(prefix):            suggestions.append(candidate)    return suggestionsif __name__ == &quot;__main__&quot;:    add_update_contacts(conn, &#39;user&#39;, &#39;zhongshangwu&#39;)    print(fetch_autocomplete_list(conn, &#39;user&#39;, &#39;zh&#39;))</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><code>Redis</code>集合以无序的方式存储各个不相同的元素, 用户可以快速的进行各种集合操作, 比如检测某个元素是否存在, 以及实现交集, 并集, 差集等.</p><p>集合的特性可以应用在社交网络的关注列表上, 可以非常方便的实现如共同关注、共同喜好、二度好友等功能. 不过社交网站数据一般十分庞大, 采用这种方案往往是不切实际的.</p><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>使用<code>Redis</code>开发应用程序组件的一个强大数据结构就是有序集合. 和散列存储着键与值之间的映射类似, 有序集合提供了分值的处理命令, 以及根据分值大小有序地获取或扫描成员和分值的命令.</p><p>有序集合的底层实现是散列和跳跃表. 跳跃表按分值从小到大的顺序保存了所有元素, 每个跳跃表节点代表一个集合元素, <code>object</code>属性指向了元素的成员, 而<code>double</code>类型的<code>score</code>属性则保存成员的分值. 通过一个持有跳跃表节点的结构, 有序集合能够很好的进行遍历, 取某一分值范围的元素. 另外使用一个字典保存了成员和分值的映射, 键指向元素成员, 而值则保存了元素的分值, 所以能够以<code>O(1)</code>时间复杂度的查找给定成员的分值, 例如<code>ZSCORE</code>命令. 需要注意的是使用散列和跳跃表来保存集合元素不会产生重复的成员或分值, 也不会浪费额外的内存.</p><p><strong>应用</strong></p><ul><li>延迟任务队列</li><li>排行榜</li></ul><p><strong>延迟任务优先队列</strong></p><p>这里采用多个队列区分优先级, 有序集合存储延迟任务, 并把时间戳作为分值.</p><pre><code class="python">import jsonimport timeimport uuidimport threadingimport redisfrom redis_lock import acquire_lock, release_lockconn = redis.Redis()QUIT = Falsedef execute_delay(conn, queue, *args, priority=0, delay=0, **kwargs):    identifier = str(uuid.uuid4())    if delay &gt; 0:        conn.zadd(&#39;delayed:&#39;,                  json.dumps((identifier, queue, priority, args, kwargs)),                  time.time() + delay)    else:        conn.rpush(&#39;queue:&#39; + queue + &#39;:%d&#39; % priority, json.dumps((args, kwargs)))    return identifierdef worker_watch_delayed(conn):    while not QUIT:        item = conn.zrange(&#39;delayed:&#39;, 0, 0, withscores=True)        if not item or item[0][1] &gt; time.time():            time.sleep(1)            continue        item = item[0][0]        identifier, queue, priority, args, kwargs = json.loads(item)        lock = acquire_lock(conn, identifier)        if not lock:            continue        if conn.zrem(&#39;delayed:&#39;, item):            conn.rpush(&#39;queue:&#39; + queue + &#39;:%d&#39; % priority, json.dumps((args, kwargs)))        release_lock(conn, identifier, lock)def worker_watch_queue(conn, queue, callback):    if not callback:        return    while not QUIT:        queues = conn.keys(&#39;queue:&#39; + queue + &#39;:*&#39;)        queues = sorted(queues, key=lambda x: x.decode(&#39;utf8&#39;).split(&#39;:&#39;)[-1])        if queues:            item = conn.blpop(queues, 10)            if not item:                continue            args, kwargs = json.loads(item[1])            callback(*args, **kwargs)if __name__ == &quot;__main__&quot;:    def producer_0():        count = 0        while True:            count += 1            execute_delay(conn, &#39;echo&#39;, &#39;producer_0&#39;, priority=0, msg=count)            time.sleep(4)    def producer_0_delay():        count = 0        while True:            count += 1            execute_delay(conn, &#39;echo&#39;, &#39;producer_0_delay&#39;, priority=1, delay=4, msg=count)            time.sleep(2)    def producer_1():        count = 0        while True:            count += 1            execute_delay(conn, &#39;echo&#39;, &#39;producer_1&#39;, priority=2, msg=count)            time.sleep(1)    def callback(producer, msg):        print(&#39;%s&#39; % producer + &#39; echo: &#39; + &#39;%d&#39; % msg)    thread_0 = threading.Thread(target=producer_0)    thread_1 = threading.Thread(target=producer_0_delay)    thread_2 = threading.Thread(target=producer_1)    thread_3 = threading.Thread(target=worker_watch_delayed, args=(conn,))    thread_4 = threading.Thread(target=worker_watch_queue, args=(conn, &#39;echo&#39;, callback))    thread_0.start()    thread_1.start()    thread_2.start()    thread_3.start()    thread_4.start()    thread_0.join()    thread_1.join()    thread_2.join()    thread_3.join()    thread_4.join()</code></pre><p>输出如下:</p><pre><code class="code">producer_0 echo: 1producer_1 echo: 1producer_1 echo: 2producer_1 echo: 3producer_1 echo: 4producer_0 echo: 2acquire_lock...release_lock...producer_0_delay echo: 1producer_1 echo: 5producer_1 echo: 6producer_1 echo: 7acquire_lock...producer_0_delay echo: 2release_lock...producer_1 echo: 8producer_0 echo: 3producer_1 echo: 9acquire_lock...producer_0_delay echo: 3release_lock...producer_1 echo: 10producer_1 echo: 11acquire_lock...producer_0_delay echo: 4release_lock...producer_1 echo: 12producer_0 echo: 4producer_1 echo: 13acquire_lock...producer_0_delay echo: 5release_lock...producer_1 echo: 14producer_1 echo: 15acquire_lock...producer_0_delay echo: 6release_lock...producer_1 echo: 16</code></pre><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p><code>Redis</code>的散列可以存储多个键值对之间的映射. 和字符串一样, 散列存储的值即可以是字节串, 也可以是整数值, 并且用户可以使用<code>HINCR</code>和<code>HDECR</code>对整数值执行自增或自减操作.</p><p>散列除了作为普通的键值映射外, 还可以将散列键看作文档数据库中的”文档”.</p><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表是列表键,哈希键以及有序集合的底层实现之一.</p><p>当一个列表键只包含少量列表项, 并且每个列表项要么就是小整数值, 要么就是长度比较短的字符串, 那么<code>Redis</code>就会使用压缩列表来做列表键的底层实现.</p><p>每个压缩列表的节点都包括三个部分:</p><ul><li><code>previous_entry_length</code>: 上一个节点的长度;</li><li><code>encoding</code>: 包括节点保存的数据类型(字节数组/整数值)以及当前节点的长度;</li><li><code>content</code>: 被存储的字符串值;</li></ul><p>压缩列表是一种为节约内存而开发的顺序型数据结构. 添加新节点到压缩列表， 或者从压缩列表中删除节点， 由于<code>previous_entry_length</code>属性占据的字节数会发生变化, 可能会引发连锁更新操作, 但这种操作出现的几率并不高.</p><p>在<code>Redis</code>配置选项中, 能够配置列表, 散列和有序集合什么时候使用压缩列表节省内存:</p><pre><code class="ini">list-max-ziplist-entries 512list-max-ziplist-value 64hash-max-ziplist-entries 512hash-max-ziplist-value 64zset-max-ziplist-entries 128zset-max-ziplist-value 64</code></pre><p><code>entries</code>选项表示编码为压缩列表时, 最多能包含的元素数量; <code>value</code>选项说明了压缩列表每个节点的最大体积是多少字节. 当突破这些限制时, <code>Redis</code>将压缩列表会转码成正常的数据结构.</p><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构, 支持<code>int16_t</code>、<code>int32_t</code>或者<code>int64_t</code>类型, 整数集合会根据添加的元素类型, 进行”升级”操作.</p><p>整数集合不光能节省内存, 还可以提升所有标准集合操作的执行速度. 下面是定义整数集合最大元素数量的配置选项:</p><pre><code class="ini">set-max-ziplist-entries 512</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><code>&gt;&gt;&gt;</code> <a href="http://redisbook.com/" target="_blank" rel="noopener">Redis设计与实现</a><br><br><code>&gt;&gt;&gt;</code> <a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis命令参考</a><br><br><code>&gt;&gt;&gt;</code> <a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html" target="_blank" rel="noopener">基于Redis的分布式锁到底安全吗?</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;可以存储键与5种不同数据结构类型之间的映射, 这五种数据结构类型分别为: &lt;code&gt;STRING&lt;/code&gt;,&lt;code&gt;LIST&lt;/code&gt;,&lt;code&gt;SET&lt;/code&gt;,&lt;code&gt;ZSET&lt;/code&gt;和&lt;code&gt;HASH&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;没有采用C语言传统的字符串表示(以空字符结尾的字符数组), 而是自己构建了一种名为”简单动态字符串”(simple dynamic string, SDS)的抽象结构来表示字符串.&lt;/p&gt;
&lt;p&gt;C字符串只会作为字符串字面量, 用在一些无须对字符串值作修改的地方, 如打印日志.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;redisLog(REDIS_WARNING,&amp;quot;Redis is now ready to exit, bye bye...&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://shawnz.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://shawnz.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Redis" scheme="http://shawnz.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入Django ORM</title>
    <link href="http://shawnz.me/posts/83dc4fd4/"/>
    <id>http://shawnz.me/posts/83dc4fd4/</id>
    <published>2018-01-24T05:56:25.000Z</published>
    <updated>2018-03-10T06:20:54.198Z</updated>
    
    <content type="html"><![CDATA[<!--  --><a id="more"></a><p>大多数人对<code>ORM</code>褒贬不一, 一方面<code>ORM</code>能够以编码面向对象的设计方式和关系数据库关联, 从底层的数据库操作中解脱出来. 但是另一方面, <code>ORM</code>框架也导致了程序员对底层的控制力明显减弱, 而且使用<code>ORM</code>很难有针对的进行优化.</p><p>Django ORM框架</p><h2 id="源码组织"><a href="#源码组织" class="headerlink" title="源码组织"></a>源码组织</h2><p>Django ORM实现的源码都在<code>django.db</code>包中, 先来看一下它的代码组织结构:</p><pre><code class="python">├── db│   ├── models  # 以面向对象的方式和数据库关联│   │   ├── aggregates.py  # 聚合查询│   │   ├── base.py  # Model类定义│   │   ├── constants.py  # 常量│   │   ├── deletion.py  # 数据库表项删除的实现│   │   ├── expressions.py  # 表达式│   │   ├── fields  # 字段以及关联me│   │   ├── functions  # 数据库函数│   │   ├── indexes.py  # 索引│   │   ├── __init__.py  │   │   ├── lookups.py  # 属性查找器│   │   ├── manager.py  # 对象管理器│   │   ├── options.py  # 数据库属性│   │   ├── query.py  # 查询集│   │   ├── query_utils.py  # 查询工具│   │   ├── signals.py  # 信号│   │   ├── sql # sql语句│   │   └── utils.py </code></pre><p>本篇文章主要针对<code>db.models</code>的各个模块分析<code>Django ORM</code>是怎么实现对象关系映射的以及有哪些地方是可以优化.</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>官方文档中的一个例子:</p><pre><code class="python">from django.db import modelsclass Person(models.Model):    first_name = models.CharField(max_length=30)    last_name = models.CharField(max_length=30)    class Meta:        pass</code></pre><h2 id="运行时创建模型类"><a href="#运行时创建模型类" class="headerlink" title="运行时创建模型类"></a>运行时创建模型类</h2><p><code>Django</code>用到了<code>Python</code>许多强大的特性, 而<code>Django ORM</code>部分就使用<code>元类(metaclass)</code>编程技术, 在运行时动态创建模型类.</p><p><code>ModelBase</code>正是创建模型类的元类. 它实现了<code>__new__(cls, name, bases, attrs)</code>方法, 接收四个参数:</p><ul><li><code>cls</code>: 元类类对象;</li><li><code>name</code>: 模型类名称;</li><li><code>bases</code>: 模型类的基类列表, <code>ModelBase</code>只能创建继承自<code>Model</code>的模型类;</li><li><code>attrs</code>: 模型类的命名空间, 模型的<code>Field</code>字段申明以及元信息<code>Meta</code>都在这个字典里面;</li></ul><p><code>ModelBase</code>中创建模型类对象的过程: 是通过基本<code>type</code>先创建一个简单的Python类对象, 然后使用<code>ModelBase</code>中定义的类方法<code>add_to_class</code>动态地设置模型类对象. <code>__new__</code>创建并初始化一个类对象分为一下几个步骤:</p><ol><li>生成一个模型类, 保留原始模型定义所在的模块;</li><li>从原始模型类的定义中获取<code>Meta</code>元信息, <code>Django</code>会尝试从中获取一些模型类的相关属性, 例如: <code>abstract</code>,<code>ordering by</code>等;</li><li>查找<code>model</code>所在的应用程序的<code>app_config</code>, 如果原始模型类没有提供自定义<code>app_label</code>, 那么它将被声明为模块所在<code>app</code>的标志;</li><li>原始模型的元信息类<code>Meta</code>会别包装成一个特殊<code>Options</code>对象, 并设置在新创建的模型类对象的属性<code>_meta</code>上;</li><li>为新创建模型类对象添加两个模型相关的异常类<code>DoesNotExist</code>和<code>MultipleObjectsReturned</code>;</li><li>如果是一个代理模型类, 必须确保它的基类没有被<code>swapped out</code>;</li><li>添加原始模型类中定义的所有属性和字段到新创建的模型类对象上;</li><li>设置代理模型类;</li><li>从父类继承部分属性和字段;</li><li>如果是一个抽象模型类则直接返回;</li><li>如果模型类没有提供一个对象管理器, 那么就设置一个名为<code>objects</code>的<code>Manager</code>默认对象管理器;</li><li>新的模型类会被缓存在应用程序中;</li><li>返回新创建的模型类, 供以后创建类的实例使用;</li></ol><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2>]]></content>
    
    <summary type="html">
    
      &lt;!--  --&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="Django" scheme="http://shawnz.me/tags/Django/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="http://shawnz.me/posts/f75280fd/"/>
    <id>http://shawnz.me/posts/f75280fd/</id>
    <published>2018-01-20T15:08:55.000Z</published>
    <updated>2018-03-10T06:20:54.198Z</updated>
    
    <content type="html"><![CDATA[<!--  --><a id="more"></a><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><p>MySQL的逻辑架构大致分为三层:</p><p><img src="/images/mysql-0.png" alt=""></p><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>sysbench</p><h2 id="性能剖析"><a href="#性能剖析" class="headerlink" title="性能剖析"></a>性能剖析</h2><p>性能定义: 完成某件任务所需要的时间度量, 以响应时间作为性能指标, 吞吐量作为性能优化的副产品.</p><p>性能剖析的手段:</p><ul><li><code>SHOW STATUS</code>: 返回一些计数器, 既有基于连接的会话级别计数器, 也有服务器级别全局计数器;</li><li><code>SHOW PROLIE</code>: 默认关闭, 通过<code>SET PROFILING=1</code>开启后, 在服务器上执行的所有语句, 都会测量其耗费的时间和其他一些查询执行状态变更相关的数据;</li><li><code>慢查询日志</code>: 默认关闭, 用来记录在MySQL中响应时间超过阀值的语句, 通过<code>long_query_time</code>参数设置阀值(默认10s). 另外日志分析工具有<code>pt-query-digst</code>和<code>mysqldumpslow</code>;</li><li><code>Performance Schema</code>: 以存储引擎的方式实现, 用于收集数据库服务器性能参数;</li><li><code>Information Schema</code>: 提供了访问数据库元数据的方式, 可以<code>STATISTICS</code>表查看一些索引信息;</li><li><code>EXPLAIN</code>: 查看一些SQL语句的执行计划.<!-- more --><h2 id="Schema优化"><a href="#Schema优化" class="headerlink" title="Schema优化"></a>Schema优化</h2></li></ul><h3 id="几个简单原则"><a href="#几个简单原则" class="headerlink" title="几个简单原则"></a>几个简单原则</h3><ul><li>更小的通常更好: 尽量使用可以正确存储数据的最小数据类型但是要确保没有低估需要存储的值的范围;</li><li>简单就好: 尽量使用简单的数据类型, 比如整型优于字符类型, 字符类型有字符集和校对规则, 因此更加复杂; 使用内建日期类型而不是字符串保存日期和时间, 用整型存储Ip地址而不是字符串.</li><li>尽量避免NULL：让一个列为可以NULL的会导致耗费很多的存储空间, 尤其是那些预计会建立索引的列, 可NULL的列会导致索引的统计和值比较更加复杂. </li><li>选择类型的时候, 先确定合适的大类型: 整形/字符串/日期等, 然后在确定具体类型.</li></ul><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><ul><li><code>TINYINT</code>,<code>SMALLINT</code>,<code>MEDIUMINT</code>,<code>INT</code>,<code>BIGINT</code>分别对应<code>8</code>,<code>16</code>,<code>24</code>,<code>32</code>,<code>64</code>位存储空间, 以及提供<code>UNSIGNED</code>属性, 表示不允许负值;</li><li><code>FLOAT\DOUBLE</code>类型支持单精度浮点运算和双精度浮点运算, 这种计算是近似的, 不精确的, 这是现行计算机架构的通病, 是由底层决定的, 不是MySQL导致的;</li><li><code>DECIMAL</code>类型支持精确的计算, 存储精确的小数. 但是这是有代价的, 这种类型的运算比浮点运算慢, 占用空间更多;</li><li>推荐使用<code>BIGINT</code>来存储精确数字, 比如要精确到<code>0.0001</code>, 那么存储数字的时候乘以一万, 而取出数字后再除以一万. 这样可以避免浮点运算的精度问题, 又不用付出<code>DECIMAL</code>高昂的代价;</li><li>注意MySQL的存储类型, 运算类型和客户端显示格式的区别;</li></ul><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul><li><code>CHAR/VARCHAR</code><ul><li><code>VARCHAR</code>变长, 需要1到2个额外的字节记录长度, 存储和检索时会保留末尾的空格;</li><li><code>CHAR</code>定长, 存储时会删除末尾空格, 采用空格填充以方便比较;</li><li>填充和截取空格的行为发生在服务器层, 与存储引擎无关;</li><li><code>CHAR(n)</code>和<code>VARCHAR(n)</code>中的<code>n</code>代表的是字符而不是字节;</li></ul></li><li><code>BINARY/VARBINNARY</code>: 存储的二进制字符串, 填充<code>BINARY</code>采用的是零字节<code>\0</code>, 检索不会去掉填充值.</li><li><code>BLOB/TEXT</code>:<ul><li>存储很大的数据时使用这两种类型</li><li>当<code>BLOB/TEXT</code>太大时, <code>InnoDB</code>会使用额外的存储区进行存储, 在行内使用1-4个字节存储指针;</li><li>针对<code>BLOB/TEXT</code>, 排序和索引只会使用前面的小部分字符</li></ul></li></ul><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><ul><li><code>DATETIME</code>: 保存<code>1001</code>年至<code>9999</code>年范围的日期, 精度为秒, 存储到格式为<code>YYYYMMDDHHMMSS</code>的整数中, 占8字节, 以一种直观的方式显示;</li><li><code>TIMESTAMP</code>: 保存格林尼治标准时间以来的秒数, 只能表示<code>1970</code>年至<code>2038</code>年, 占4个字节, 按时区显示;</li></ul><h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><ul><li><code>ENUM</code>:</li></ul><h3 id="标识列选择"><a href="#标识列选择" class="headerlink" title="标识列选择"></a>标识列选择</h3><ul><li>确保某一种标识一旦选定了类型, 就在所有关联的表中使用同一类型, 包括<code>UNSIGNED</code>这样的属性;</li><li>在满足值的要求, 并充分考虑到未来扩展性的情况下, 应使用尽可能小的数据类型, 比如存储美国各州的名字(另一张表)的<code>id</code>列, 不需要<code>INT</code>, <code>TINYINT</code>就够了;</li><li><code>整数 &gt; ENUM/SET &gt; 字符串</code>, 整数的性能和扩展性最好, 字符串最糟糕, 占用很多空间, 性能也差的多;</li><li>对于<code>MD5()</code>, <code>SHA1()</code>, <code>UUID()</code>这种产生随机字符串的函数要特别注意, 这些函数生成的值会导致插入和查询变得很慢, 而对于写非常多的大表, 使用”伪随机”值可以消除热点;</li><li>存储<code>UUID</code>值, 要去掉’-‘号, 或者用<code>UNHEX()</code>函数转换<code>UUID</code>为<code>16</code>字节的数字, 存储在<code>BINATY(16)</code>中, 检索时再通过<code>HEX()</code>格式化成十六进制形式;</li></ul><h3 id="应该避免的情况"><a href="#应该避免的情况" class="headerlink" title="应该避免的情况"></a>应该避免的情况</h3><ul><li>太多的列: 因为MySQL会在工作时, 从存储引擎层和服务器层之间通过行缓冲格式拷贝数据, 然后从行缓冲将编码过的列在服务器端解码成各个列, 转换的代价依赖于列的数量。<code>MyISAM</code>定长行结构与服务器层的行结构不需要转换, 而<code>InnoDB</code>和<code>MyISAM</code>的变长行结构总是需要转换;</li><li>太多关联: MySQL限制每个关联操作最多只有61张表. 避免<code>实体-属性-值(EAV)</code>设计模式. 为追求查询速度和并发性, 单个查询最好是12个表以内关联. </li><li>注意防止过度使用枚举: 一个好的建议是使用整数关联到字典表或查找表, 找到具体指;</li><li>变相的枚举: 避免在应该使用<code>ENUM</code>的情况下使用<code>SET</code>, 比如存储是<code>Y</code>还是<code>N</code>的列。如果不会同时出现<code>YN</code>，就不需要<code>SET</code>类型;</li><li>在避免使用<code>NULL</code>的原则下不要走极端, 使用特殊常数可能造成代码的<code>BUG</code>.</li></ul><h3 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h3><p>三大范式这里不做叙述了, 总结一下范式和反范式的区别:</p><ul><li>反范式会存储一些冗余数据, 所以通常查询会更快, 另一方面为了保持数据的一致性, 更新操作通常比范式化的数据表慢;</li><li>范式化意味着没有冗余数据, 所以一般不需要<code>DISTINCT</code>和<code>GROUP BY</code>语句;</li></ul><p>在数据库<code>Schema</code>优化中, 大部分的工作都在衡量范式化和反范式上, 实际情况通常需要两者的结合.</p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li>缓存表/汇总表: 在满足检索需求时, 经常使用这种技巧. 需要权衡的问题是实时维护还是定期重建(一般来讲这是更好的选择);</li><li>计数表: 在维护计数器的时候, 有时考虑到并发的影响, 可以将计数器切分到不同槽上, 再汇总起来;</li><li>物化试图: 需要借助外部工具.</li><li>加快<code>ALTER TABLE</code>的速度: 对于大表来讲<code>ALTER TABLE</code>的性能是一个大问题, 有两种方法可以加快<code>ALTER TABLE</code>的速度:<ul><li>通过<code>ALTER COLUMN</code>操作来改变列的默认值, 这不会导致表的重建;</li><li>采用替换<code>.frm</code>文件的方式: 创建一张结构相同的空表, 修改表结构, 锁定原表, 替换<code>.frm</code>文件, 解锁原表.</li></ul></li><li>快速创建<code>MyISAM</code>索引: 先引用索引, 载入数据, 在重启索引. 这会索引的构建延迟到数据完全载入后, 这个时候可以使用排序创建索引;</li></ul><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p><strong>一定要先看<code>B-Tree</code>和<code>B+Tree</code>数据结构和磁盘的存取原理.</strong></p><p>简单说一下:</p><ul><li><code>B-Tree</code>可以利用磁盘存储的局部性原理和磁盘预读, 减少读取磁盘的次数;</li><li>一个<code>B-Tree</code>节点一般对应”系统页”的整数倍, 连续的地址, 使用的时候加载到内存中(页分裂/碎片等会导致”随机I/O”); 而从磁盘读取索引节点, 一般是”随机I/O”(可以重建索引优化为”顺序I/O”). <code>MyISAM</code>索引的数据行读取是”随机I/O”. (可能理解的有问题…)</li><li><code>B+Tree</code>根节点内存常驻, 内部节点只保存键值, 数据保存在叶子节点上, 相邻的叶子节点之间有指针相连, 能够提高区间查询的效率;</li><li>因为<code>B-Tree</code>按顺序存储索引键值, 所以<code>ORDER BY</code>和<code>GROUP BY</code>十分高效;</li></ul><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB引擎的主键索引, 如下图(这里索引是整数值):</p><p><img src="/images/mysql-3.png" alt=""></p><p>可以看到<code>InnoDB</code>的主索引结构有一个明显的特点: 叶节点包含了完整的数据记录, 这也就是说<code>InnoDB</code>表数据文件本身就是主索引. 这种索引称为<code>簇族索引</code>, 每个叶子节点都包含了主键值, 事务ID, 用于事务和<code>MVCC</code>的回滚指针以及剩余的列, 如果主键是一个列前缀索引, <code>InnoDB</code>也会包含完整的主键列和剩余列. </p><p><code>InnoDB</code>表有且仅能有一个”簇族索引”, 如果没有显示指定主键, 存储引擎会从唯一非空索引中选择一个替代, 如果无法选择, 则生成一个隐藏字段作为主键, 6个字节的长整型.</p><p>由于”簇族索引”的特性, 所以一个优化建议是: 对于<code>InnoDB</code>表, 最好采用数字类型, 且具有自增规律的列作为主键. 如果是主键具有自增规律, 那么就可以通过避免插入的过程中<code>B+Tree</code>子树的重建, 来减少开销, 另外针对磁盘存储, 还可能有效地减少由于”页分裂”产生的碎片.</p><p>再来看看<code>InnoDB</code>的二级索引(这里的索引是字符串):</p><p><img src="/images/mysql-4.png" alt=""></p><p>对于<code>InnoDB</code>的二级索引, 叶子节点里保存的不再是完整数据, 而是主键值, 所以<code>InnoDB</code>的二级索引需要两次索引查找. 这里不存”地址指针”的原因是: 这种策略减少了当行移动或者数据页分裂时导致的二级索引维护工作(存储”主键”不需要变动). </p><p>知道了<code>InnoDB</code>的二级索引原理, 我们也就能理解为什么建议<code>InnoDB</code>主键索引采用数值类型而不是字符串了, 因为字符串会在二级索引上占据更多的存储空间.</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p><code>MyISAM</code>的索引结构如下:</p><p><img src="/images/mysql-1.png" alt=""></p><p>和<code>InnoDB</code>的不同之处在于: <code>MyISAM</code>索引的叶子节点中存储的数据的物理地址, 这一点对于主键索引和二级索引没有区别. 两者之间的唯一区别是主键索引要求必须非空唯一.</p><p>另外<code>MyISAM</code>还采用一种”压缩索引”(“前缀索引”)的技术: 先保存索引块的第一个值, 然后将后面的值和第一个值进行比较, 得到相同的前缀的字节数和剩下不同的后缀部分. 例如: 假设索引的第一个值是”perform”, 第二个值是”performmance”的话, 那么第二个值前缀压缩后存储的是类似”7,ance”这样的形式.</p><p>前缀压缩技术能够大幅度的减少磁盘存储空间, 以及降低<code>I/O</code>压力, 但是在查找索引块的时候, 只能退化到顺序查找, 无法利用二分查找.</p><h3 id="最左前缀原理"><a href="#最左前缀原理" class="headerlink" title="最左前缀原理"></a>最左前缀原理</h3><p>在进行索引优化前, 必须先弄明白什么样的查询会使用索引, 这和<code>B-Tree</code>索引限制有关.</p><p>假设我们有如下数据表<code>People</code>:</p><pre><code class="sql">CREATE TABLE `People` (  `last_name` varchar(45) NOT NULL,  `first_name` varchar(45) NOT NULL,  `dob` date NOT NULL,  `gender` enum(&#39;m&#39;, &#39;f&#39;) NOT NULL,  KEY(`last_name`,`first_name`,`dob`))ENGINE=InnoDB DEFAULT CHARSET=latin1;</code></pre><p>索引由<code>last_name</code>,<code>first_name</code>和<code>dob</code>组成. 考虑如下几种情况:</p><ul><li><p>全值匹配<br><br>  指的是和索引中的所有列进行匹配. 例如查找姓名为<code>Cuba Allen</code>, 出生于<code>1960-01-10</code>的人;</p></li><li><p>匹配最左前缀值<br><br>  可以只使用索引的最左侧列, 例如查找所有姓氏为<code>Allen</code>的人;</p></li><li><p>匹配范围值<br><br>  也可以只是用列的前缀部分, 例如查找所有姓氏以<code>J</code>开头的人;</p></li><li><p>精确匹配某一列并范围匹配另一列<br><br>  也可以匹配姓氏为<code>Allen</code>, 名字以<code>K</code>开头的人, 即第一列全匹配, 第二列范围匹配;</p></li></ul><p>也有些情况不会使用索引:</p><ul><li><p>查询条件中含有函数或表达式<br><br>  例如使用<code>left</code>函数查找姓氏前4个字符为<code>Alle</code>的人;</p></li><li><p><code>like</code>关键字<br><br>  如果使用以<code>like %llen</code>形式匹配姓氏, 则不会使用索引, 如果通配符<code>%</code>不出现在开头, 则可以使用索引;</p></li><li><p>不符合最左前缀原则<br><br>  例如跳过第一列姓氏匹配名字, 或者范围匹配不在最右侧;</p></li></ul><h3 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h3><p>先前介绍了索引的原理和相关特性, 现在我们来看看怎么建立高效地选择和使用索引.</p><h4 id="索引选择性"><a href="#索引选择性" class="headerlink" title="索引选择性"></a>索引选择性</h4><p>索引的选择性: 不重复的索引值(也称为”基数”)/数据表的记录总数. 选择性越高的索引查询效率越高, 因为高的选择性在查找时能过滤更多的行. 唯一索引的选择性为<code>1</code>, 性能最好.</p><p>定义好了索引选择性, 就不得不提”前缀索引”: 通过只取字符串(通常是字符串)的合适前缀来建立索引, 从而缩小索引的体积. 另外MySQL强制规定在<code>BLOB/TEXT</code>或更长的<code>VARCHAR</code>类型上只能建立前缀索引.</p><p>在选择多长的前缀这个问题上, 我们可以通过索引选择性来找到答案: 先计算完整列的索引选择性, 然后慢慢增加前缀, 逼近完整列的索引选择性. 这个过程可以利用<code>COUNT</code>和<code>LEFT</code>函数.</p><p>另外在多列索引的选择问题上, 也可以参考索引选择性(但不是绝对).</p><p>另外前缀索引也有缺点: 无法用来排序和分组, 也无法用来作为”覆盖索引”.</p><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>在选择索引上, 我们经常面临两个问题:</p><ul><li>是使用多个单独的一列作为索引, 还是建立一个多列的索引?</li><li>如果使用多列索引, 那么这些列之间以什么样的顺序定义呢?</li></ul><p>我们先来解决第一个问题, 在多个单独的列上定以索引大部分情况下并不能提高MySQL性能.</p><p>在MySQL5.0后, 引入了一种叫”索引合并”的策略, 在查询是能够同时使用多个单独的索引进行扫描, 并将结果合并. 这个算法有三个变种: <code>OR</code>联合, <code>AND</code>相交以及组合前两种情况的相交和联合. 不过这会耗费大量的CPU和内存资源在算法的缓存, 排序和合并操作上, 而且查询优化器不会把这部分的损耗计算在内.</p><p>所以一种更健壮的索引设计是多列索引, 这就要求我们结合用到的查询, 定义好合适的索引列顺序.</p><p>当你定义好一个索引列的顺序后, 索引首先会按照最左列排序, 在后续的查询语句要求遵循”最左前缀原理”, 以正确的使用索引.</p><p>对于如何选择索引列顺序的一个经验法则是: 索引列选择性高的放在前面. 这在优化<code>WHERE</code>条件查询时, 无疑是最快的, 然而实际情况中还需要考虑具体值的分布, 以及排序, 分组和范围查找等情况.</p><h4 id="按主键顺序插入行"><a href="#按主键顺序插入行" class="headerlink" title="按主键顺序插入行"></a>按主键顺序插入行</h4><p>最好避免随机的(不连续且值的分布范围十分广)簇族索引.</p><p>如果是按主键顺序插入的话, 那么存储引擎就会顺序的添加到当前索引节点的后面, 当一页写满(“填充因子”: 减少在数据移动或追加的时候的页分裂可能), 就自动开辟一个新的页.</p><p>如果插入的是随机值, 那么每次插入新的记录, 都需要寻找合适的位置—通常是已有位置的中间. 如果写入的目标页已经写入磁盘, 还需要重新读取, 由于是乱序的会造成”随机I/O”, 页分裂操作和磁盘碎片.</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含所有要查询的列的值, 就称为”覆盖索引”. 覆盖索引可以使存储引擎不需要从数据行获取数据, 而是直接使用扫面索引获取数据. </p><p>这对I/O密集型的应用十分有帮助, 因为索引更小, 更容易放在内存中, 而且<code>B-Tree</code>索引是顺序存储的, 至少在单个页上是顺序I/O. 另外对于<code>InnoDB</code>的二级索引, 省去了第二次查找主键索引的消耗. </p><p>另外有一个小技巧叫”延迟关联”, 它可以在需要所有列的情况下, 充分利用覆盖索引.</p><h4 id="使用索引排序"><a href="#使用索引排序" class="headerlink" title="使用索引排序"></a>使用索引排序</h4><p>MySQL有两种排序方式: 排序操作, 按索引顺序扫描排序.</p><p>使用索引做排序和使用索引查找一样遵循”最左前缀原理”(列的顺序相同), 而且多个<code>ORDER BY</code>的排序方向必须一致(都是正序或倒序), 如果关联多张表, 那么<code>ORDER BY</code>子句引用的字段都必须是第一张表.</p><p>有一种情况可以不满足”最左前缀原理”: 那就是一个前导列被赋予了常量值, 例如索引(birth, last_name):</p><pre><code class="sql">select * from people where birth=&#39;1996-10-14&#39; order by last_name desc;</code></pre><h4 id="重复索引"><a href="#重复索引" class="headerlink" title="重复索引"></a>重复索引</h4><p>MySQL允许在相同的列上创建多个索引, 大多数情况下, 这些索引都是多余的, 会浪费存储空间, 并且插入记录时维护这些索引需要耗费时间. 应该避免创建重复索引, 发现后也要立即移除.</p><p>不过也有些情况下, 考虑到性能需求需要创建重复索引, 扩展原有的索引会导致其变大, 影响其他使用该索引的查询的性能.</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引给予哈希表实现, 只有在精确匹配所有列的情况下才能使用, MySQL中只有<code>Memory</code>存储引擎支持哈希索引.</p><p>哈希索引只存储哈希值和行地址, 不过这一点影响不大, 因为在内存中的读取速度不是问题.</p><p>哈希索引在满足查找速度的时候, 牺牲了许多<code>B-Tree</code>索引的特性, 比如: 不支持部分索引列匹配, 排序, 范围匹配和比较计算等. </p><p><code>InnoDB</code>有个特性”自适应哈希索引(Adaptive Hash Index, AHI)”: <code>InnoDB</code>会注意某些<code>索引列</code>用得非常频繁时, 它会为<code>缓冲池</code>中的<code>B-Tree</code>树<code>页</code>建立哈希索引. 据官方文档显示, 在启用<code>AHI</code>后, 读取和写入速度会提升两倍, 辅助索引(存储了主键值)的连接操作性能可以提升五倍. AHI是一种数据库<code>自优化</code>手段, 无需人为干涉.</p><p>另外, 利用哈希函数和触发器, 我们可以创建”自定义哈希索引”, 其思想是: 使用哈希值替换那些十分长的索引列, 实质还是<code>B-Tree</code>索引. 例如有索引列(url_crc):</p><pre><code class="sql">select * from url where url=&quot;http://www.mysql.com&quot; and url_crc=CRC32(&quot;http://www.mysql.com&quot;)</code></pre><p>在这里, 优化器会使用这个选择性很高而且体积小的<code>url_crc</code>索引列完成查找, 即使发生哈希冲突, 通过简单的几次键值比较就可以找到记录. 使用触发器维护哈希值:</p><pre><code class="sql">DELIMETER //CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON pseudohash FOR EACH ROW BEGINSET NEW.crc_url=crc32(NEW.url);END;//CREATE TRIGGER pseudohash_crc_upd BEFORE UPDATE ON pseudohash FOR EACH ROW BEGINSET NEW.crc_url=crc32(NEW.url);END;//DELEMETER ;</code></pre><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><p>查询优化, 索引优化和库表结构优化需要齐头并进, 一个不落. 客户端发送一条<code>SQL</code>给MySQL服务器的整个查询流程:</p><p><img src="/images/mysql-5.jpg" alt=""></p><h3 id="为何查询如此慢"><a href="#为何查询如此慢" class="headerlink" title="为何查询如此慢?"></a>为何查询如此慢?</h3><p>在进行查询优化之前, 我们先要弄明白一个查询任务是由哪些子任务构成的, 哪些子任务运行的速度很慢?</p><p>在这里没有给出完整的列表, 不过可以按查询的生命周期来进行分析: 客户端, 服务器, 解析, 生成执行计划, 执行, 并返回结果给客户端. 逐步分析问题出在哪, 优化哪部分能得到大幅度的性能提升. </p><p>查询任务的大部分时间会消耗在网络, CPU计算, 生成统计信息和执行计划, 锁等待等操作, 尤其是为了检索数据发起的对存储引擎的调用, 这些调用需要在内存操作, CPU操作以及内存不足引起的I/O操作消耗时间.</p><p>*阿姆达尔定律: 对于一个占总响应时间不超过5%的查询进行优化, 无论如何努力, 收益也不会超过5%</p><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><p>查询效率低下往往是因为访问的数据太多了. 对于低效查询, 我们可以通过下面两点发现问题所在:</p><ul><li><p>是否向数据库请求了不需要的数据: 会给MySQL带来额外的负担, 增加网络开销, 浪费服务器CPU和内存资源. 常见的几种错误案例:</p><ul><li>查询不需要的行: 这种情况往往发生在应用程序编程的时候, 例如: 只取数据库结果集前面部分, 然后关闭结果集.</li><li>获取不需要的列: 我们应该对<code>SELECT *</code>持审视态度, 是否真的需要全部列? 这一点在多表关联的时候尤为严重, 它会返回所有表的所有列.</li><li>重复查询相同的数据: 这种情况, 我们可以在应用程序将数据缓存起来, 减少数据库查询.</li></ul></li><li><p>MySQL是否在扫描额外的记录: 直白来讲就是MySQL需要扫描多少数据, 才能返回我们需要的数据.<br><br>  一个理想的状态是: <code>扫描的行数=返回的行数=需要的行数</code>.<br><br>  为了评估MySQL查询开销, 我们需要理解几个概念: <code>全表扫描</code>,<code>索引扫描</code>,<code>范围查询</code>,<code>唯一索引访问</code>和<code>常数引用</code>. 这里列的这些, 可以通过<code>EXPLAIN</code>中的<code>type</code>看到, 速度由慢到快.<br><br>  如果发现MySQL扫描了大量的额外数据, 通常可以采用下面几种技巧:</p><ul><li>索引: 索引可以让MySQL访问合适的数据;</li><li>覆盖索引: 可以不用回表查询数据行;</li><li>优化库表结构: 例如汇总表;</li><li>重构查询: 让MySQL优化器以更优的方式执行这个查询;</li></ul></li></ul><h3 id="嵌套循环关联"><a href="#嵌套循环关联" class="headerlink" title="嵌套循环关联"></a>嵌套循环关联</h3><p>MySQL没有哈希关联, 合并关联, 所有关联都是”嵌套循环关联”. 如果要写出高效的多表关联查询, 就必须先弄明白什么是”嵌套循环关联”, 如下图:</p><p><img src="/images/mysql-6.jpg" alt=""></p><p>嵌套循环关联: MySQL先在一个表中循环取出单条数据, 然后再嵌套循环到下一个表中寻找匹配的行, 依次下去, 直到知道到所有表中匹配的行.</p><p>既然理解了MySQL的嵌套循环关联, 也就明白为什么提倡使用”小结果集来驱动大结果集, 对被驱动的表的关联列建立索引”(因为外层循环中结果集大的话, 意味着嵌套循环的次数多, 即更多的磁盘I/O).</p><p>MySQL查询优化器最重要的一部分工作就是关联查询优化, 能在多种不同的关联顺序中, 找到成本比较低的关联顺序(“贪婪”搜索). 这一点上, 优化器大多数情况都能做得很好, 如果人为不能很好的分析各种关联顺序, 可以将工作交给优化器完成.</p><p>关于嵌套循环关联, 还有几个相关的问题:</p><ul><li>对于排序, 如果所有<code>ORDER BY</code>都发生在驱动表, 那么MySQL能在驱动表查找过程中就排好序, 否则, 需要在返回的结果集(临时表)上排序.</li><li>对于<code>UNION</code>操作, MySQL无法将限制条件(<code>LIMIT</code>)从”外层”下推到内层, 它会将结果集合并成临时表, 然后在返回前<code>N</code>条. 一个优化建议是, 分别对单独查询加上<code>LIMIT</code>限制. (还有一点就是从临时表中取出的数据的顺序是不一定的, 必要的话, 还需要全局的排序).</li><li><code>GROUP BY</code>和<code>DISITNC</code>通常需要在临时表上进行操作.</li><li>关联子查询</li></ul><h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>MySQL查询优化器使用了非常多的优化策略和算法, 来生成一个较优的执行计划:</p><ul><li>重新定义表的关联顺序: 数据表的关联顺序并不总是查询指定的顺序;</li><li>将外连接转换成内连接: <code>WHERE</code>条件和库表结构可能会让外连接变为内连接;</li><li>使用等价变换规则: 使用等价变换来简化并规范表达式;</li><li>优化<code>COUNT()</code>,<code>MIN()</code>,<code>MAX()</code>: <code>B-Tree</code>索引可以直接找到最小最大值, 而MyISAM存储引擎有记录数据表总行数.</li><li>预估并转化为常数表达式;</li><li>覆盖索引扫描;</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表<code>IN()</code>比较: 先对列表值排序, 再二分查找.(而<code>OR</code>是简单顺序查找).</li></ul><p>另外, MySQL也提供了丰富的查询优化器提示(<code>hint</code>), 例如: <code>HIGH_PRIORITY</code>,<code>USE INDEX</code>,<code>FOR UPDATE</code>…</p><h3 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h3><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h4><p>关于<code>COUNT</code>这个话题, 互联网上有一大堆的信息, 但大多不够准确. 在这里总结一下:</p><ul><li><p>首先, <code>COUNT(*)</code>并不会扩展到所有列, 它只是统计行数(结果集/数据表).</p></li><li><p>然后对于<code>MyISAM</code>引擎, 因为它有记录数据表的行数, 所以<code>COUNT(*)</code>会很快. 例如:</p><pre><code class="sql">  select * from count(*) from tb;</code></pre><p>   但是一旦使用了<code>WHERE</code>条件(并且没有优化掉), 就会退化到全扫描(可能是全表扫描或索引扫描). 假设我们有主键<code>i</code>, 索引<code>val</code>以及字段<code>bar</code>:</p><pre><code class="sql">   select count(*) from tb where i &lt; 10000;  /* 索引扫描 */   select count(*) from tb where val &lt; 10000; /* 全表扫描*/</code></pre><p>  在都退化到索引扫描的时候,　例如：</p><pre><code class="sql">  select count(*) from tb where i &lt; 10000; /* 最快 */  select count(i) from tb where i &lt; 10000; /* 和count(*)等价 */  select count(val) from tb where i &lt; 10000; /* 较慢 */</code></pre><p>  <code>COUNT(*)</code>会快于<code>COUNT(COL)</code>是因为前者只需要统计行数, 而后者要回表查找数据行(除非<code>COUNT(COL)</code>使用了覆盖索引, 即<code>count(i)</code>). 那么可不可以认为在<code>InnoDB</code>引擎中, 如果都走的是簇族索引的话, 是不是<code>COUNT(*)</code>和<code>COUNT(COL)</code>就没有区别了呢? (还没有去实验…)</p></li><li><p>另外, 有个特殊情况就是<a href="https://www.zhihu.com/question/50171821" target="_blank" rel="noopener">MySQL下count(*)比count(id)慢的原因？</a>. <br><br>  <code>MyISAM</code>存储引擎下两个SQL语句, 这个表的主键为<code>id</code>, <code>status</code>列有个索引:</p><pre><code class="sql">  select count(*) from dr_keywords where status=0;  /* [1]. 0.8秒 */  select count(id) from dr_keywords where status=0;  /* [2]. 0.5秒 */</code></pre><p>  以及数据分布情况如下:</p><pre><code class="code">  +--------+----------+  | status | count(*) |  +--------+----------+  |      0 |  1060349 |  |      1 |     2995 |  |      9 |      236 |  +--------+----------+</code></pre><p>  这里分析的原因是: [1]SQL语句走的是<code>status</code>索引扫描, 而语句[2]被优化器优化为全表扫描.<br><br>  先不谈为什么优化器会将语句[2]优化为全表扫描, 单说索引扫描为什么会慢.<br><br>  大部分情况下, 所以扫描会块</p></li><li><p>在5.7版本中，<code>InnoDB</code>实现了新的<code>handler</code>的<code>records</code>接口函数，当你需要表上的精确记录个数时，会直接调用该函数进行计算,</p></li></ul><p>所以总的来说, 大多数情况下<code>COUNT(*)</code>会不慢于<code>COUNT(COL)</code>, 但是也有例外情况. 实际还可能和索引使用情况, 数据分布情况以及数据库版本和存储引擎相关.</p><h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT()"></a>LIMIT()</h4><p>在业务中需要进行”分页”操作时, 我们经常使用数据库层的<code>OFFSET</code>和<code>LIMIT</code>实现, 并在<code>ORDER BY</code>的列上加上索引.</p><p>一个令人头疼的问题是: 在偏移量非常大的时候. 例如<code>LIMIT 10000,20</code>这样的查询, 会造成MySQL查询<code>10020</code>条记录然后返回最后<code>20</code>条, 造成前面<code>10000</code>条记录被丢弃.</p><p>这种问题的优化策略是: 限制分页数量, 另一个是优化查询在大偏移量时的性能.</p><p>优化这类查询最简单的一个做法是, 尽量使用覆盖索引, 可以避免MySQL回表查询数据行. 如果无法做到覆盖索引, 也可以使用前面介绍的”延迟关联”的技巧. 例如:</p><pre><code class="sql">select film.film_id, film.descriptionfrom sakila.filminner join (    select film_id from sakila.film    order by title limit 50,5) as lim using(film_id); </code></pre><p>另外一种思路是尽可能的减少MySQL扫描的记录数, 先确定范围, 然后取N条. 例如:</p><pre><code class="sql">select film_id, description from sakila.film where position between 50 and 54 order by position;</code></pre><p>如果上层应用程序能够记录上一次取数据的位置, 这种范围查找的方式, 在无论偏移量多大的情况下, 都能取得良好的性能.</p><p>“分页”带来的另一个问题是, 需要知道一共能查到多少数据, 以方便应用程序计算”总页数”.</p><p>一个常用的技巧是在<code>LIMIT</code>语句中加上<code>SQL_CALC_FOUND_ROWS</code>提示（<code>hint</code>), 这样做可以获得去掉<code>LIMIT</code>以后满足条件的行数, 因此可以作为分页的总数. 看起来, MySQL做了一些非常高深的优化, 像是通过某种方法预测了总行数. 但实际上MySQL只有在扫描了所有满足条件的行，然后再抛弃掉不需要的行，而不是在满足<code>LIMIT</code>的行数后就终止扫描. 所以该提示的代价非常高, 在数据量大的时候性能很差.</p><p>一个更好的设计方案是将具体的页面换成“下一页”按钮, 假设每页显示<code>20</code>条记录, 那么我们每次查询都是用<code>LIMIT</code>返回<code>21</code>条记录并只显示<code>20</code>条, 如果第<code>21</code>条存在, 那么我们就显示“下一页”按钮, 否则就说明没有更多的数据, 也就无需显示“下一页”按钮了.</p><p>还有一种做法, 那就是在应用程序层做”分页”, 例如, 我们一次加载<code>1000</code>条数据, 缓存下来, 以后的分页都从这个缓存中取. 如果结果集小于<code>1000</code>, 就可以显示所有的页面链接, 否则, 增加一个发现大于<code>1000</code>条数据提示.</p><h4 id="IN"><a href="#IN" class="headerlink" title="IN()"></a>IN()</h4><h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p><code>&gt;&gt;&gt;</code><a href="http://keithlan.github.io/2015/07/17/22_performance_schema/" target="_blank" rel="noopener">Mysql5.6 Performance_schema 深入浅出</a><br><br><code>&gt;&gt;&gt;</code><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a><br><br><code>&gt;&gt;&gt;</code><a href="http://blog.jobbole.com/100349/" target="_blank" rel="noopener">如果有人问你数据库的原理, 叫他看这篇文章</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;!--  --&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://shawnz.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://shawnz.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://shawnz.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Python源码阅读-垃圾回收机制</title>
    <link href="http://shawnz.me/posts/19171030/"/>
    <id>http://shawnz.me/posts/19171030/</id>
    <published>2018-01-19T19:22:40.000Z</published>
    <updated>2018-03-10T06:20:54.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python中的垃圾回收"><a href="#Python中的垃圾回收" class="headerlink" title="Python中的垃圾回收"></a>Python中的垃圾回收</h2><p>在Python中, 主要的内存管理手段是引用计数, 而标记-清除算法和分代收集机制是为了打破循环引用而补充的技术.</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>经过前面的探索, 我们知道在所有Python对象头部都有着一个计数器, 如果对象的引用增加, 则计数器加一, 反之减一. 所以在Python中, 有两个宏定义来操作这个计数器:</p><a id="more"></a><pre><code class="c">#define Py_INCREF(op) (                         \ /* 增量计数 */    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \    ((PyObject *)(op))-&gt;ob_refcnt++)#define Py_DECREF(op)                                   \ /* 减量计数 */    do {                                                \        PyObject *_py_decref_tmp = (PyObject *)(op);    \        if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \        --(_py_decref_tmp)-&gt;ob_refcnt != 0)             \            _Py_CHECK_REFCNT(_py_decref_tmp)            \        else                                            \            _Py_Dealloc(_py_decref_tmp);                \    } while (0)</code></pre><p>此外, 还提供了针对<code>NULL</code>检查的宏:</p><pre><code class="c">#define Py_XINCREF(op)                                \    do {                                              \        PyObject *_py_xincref_tmp = (PyObject *)(op); \        if (_py_xincref_tmp != NULL)                  \            Py_INCREF(_py_xincref_tmp);               \    } while (0)#define Py_XDECREF(op)                                \    do {                                              \        PyObject *_py_xdecref_tmp = (PyObject *)(op); \        if (_py_xdecref_tmp != NULL)                  \            Py_DECREF(_py_xdecref_tmp);               \    } while (0)</code></pre><p>另外, 在减少引用计数器的时候, 我们发现有一个宏<code>_Py_Dealloc</code>, 这个宏负责调用对象的<code>tp_dealloc</code>函数释放对象:</p><pre><code class="c">#define _Py_Dealloc(op) (                               \    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</code></pre><p>而在<code>tp_dealloc</code>中又会调用<code>tp_free</code>, 这个函数指针一般都是<code>PyObject_GC_Del</code>函数:</p><pre><code class="c">voidPyObject_GC_Del(void *op){    PyGC_Head *g = AS_GC(op);    /* ... 省略部分释放前的处理 */    PyObject_FREE(g);}</code></pre><p>最终, 回到了我们在上一节中讲到的<code>PyObject_FREE</code>, 释放分配的内存.</p><p>所以引用计数的减量操作是这么一个流程:</p><blockquote><p><code>Py_DECREF -&gt; _PyDealloc -&gt; tp_dealloc -&gt; tp_free -&gt; PyObject_GC_Del -&gt; PyObject_FREE -&gt; PyObject_Free</code></p></blockquote><!-- 对于计数器, 我们还需要关注的一个问题是: 计数器溢出. --><h2 id="容器对象"><a href="#容器对象" class="headerlink" title="容器对象"></a>容器对象</h2><p>并不是所有Python对象会发生循环引用, 只有那些可能保留了其它对象引用的对象, 才可能发生循环引用, 关于这类对象我们称之为”容器对象”.</p><p>循环引用垃圾回收的对象只有这些容器对象. Python对于这些容器对象都分配了用于循环引用垃圾回收的结构体头, 这个头部包含一下信息:</p><ul><li>用于容器对象的双向链表的成员;</li><li>用于复制引用计数器的成员;</li></ul><p>其定义如下:</p><pre><code class="c">[objimpl.h]typedef union _gc_head {    struct {        union _gc_head *gc_next; /* 用于双向链表 */        union _gc_head *gc_prev; /* 用于双向链表 */        Py_ssize_t gc_refs; /* 用于复制 */    } gc;    double dummy;  /* force worst-case alignment */} PyGC_Head;</code></pre><p>其中<code>dummy</code>的作用是: 即使结构体<code>gc</code>的大小为<code>9</code>字节这样不上不下的数值, <code>dummy</code>也可以将整个结构体<code>PyGC_Head</code>对齐为<code>long double</code>型.</p><p>在Python中, 创建容器对象和创建普通对象的内存分布是不一样的:</p><pre><code class="c">[gcmodule.c]PyObject *_PyObject_GC_New(PyTypeObject *tp){    PyObject *op = _PyObject_GC_Malloc(_PyObject_SIZE(tp));    if (op != NULL)        op = PyObject_INIT(op, tp);    return op;}</code></pre><p>在生成容器对象的时候, 必须通过<code>_PyObject_GC_Malloc</code>分配用于循环引用垃圾回收的头:</p><pre><code class="c">#define _PyGC_REFS_UNTRACKED                    (-2)#define GC_UNTRACKED                    _PyGC_REFS_UNTRACKEDPyObject *_PyObject_GC_Malloc(size_t basicsize){    return _PyObject_GC_Alloc(0, basicsize);}static PyObject *_PyObject_GC_Alloc(int use_calloc, size_t basicsize){    PyObject *op;    PyGC_Head *g;    size_t size;    size = sizeof(PyGC_Head) + basicsize; /* 为PyGC_Head和对象本身分配内存 */    g = (PyGC_Head *)PyObject_Malloc(size);    g-&gt;gc.gc_refs = 0;    _PyGCHead_SET_REFS(g, GC_UNTRACKED);     /* 开始进行循环引用垃圾回收 */    generations[0].count++; /* number of allocated GC objects */    if (generations[0].count &gt; generations[0].threshold &amp;&amp;        enabled &amp;&amp;        generations[0].threshold &amp;&amp;        !collecting &amp;&amp;        !PyErr_Occurred()) {        collecting = 1;        collect_generations();        collecting = 0;    }    op = FROM_GC(g);    return op;}</code></pre><p>从上面的<code>_PyObject_GC_Malloc</code>可以看到, 对于容器对象, 在分配内存的时, 也为<code>PyGC_Head</code>分配了内存, 其位置位于容器对象之前.</p><p>在<code>GC_Head</code>部分, 除了用于构建双向链表的两个指针, 还通过<code>_PyGCHead_SET_REFS(g, GC_UNTRACKED);</code>将<code>GC_UNTRACKED</code>设置到了<code>gc_refs</code>域上. 这个标志(<code>-2</code>)的意思是”这个容器对象还没有被追踪”, 当出现这个标志<code>GC</code>会认为这个容器对象还没有被连接到容器对象链表上. 关于这部分在后面还会讲到.</p><p>所以经过这些后, 容器对象的内存分布应该如下:</p><p><img src="/images/pygc-1.png" alt=""></p><p>从图中, 我们可以发现一个问题, 那就是这些容器对象的头部有单独的一部分<code>PyGC_Head</code>, 但是在Python内部, 传递的是<code>*PyObject</code>指针. 这也就意味着需要我们在<code>PyGC_Head</code>和<code>PyObject_Head</code>之间进行地址转换, 而<code>FROM_GC</code>恰恰是将<code>PyGC_Head</code>转换成<code>PyObject_Head</code>的宏定义:</p><pre><code class="c">/* Get an object&#39;s GC head */#define AS_GC(o) ((PyGC_Head *)(o)-1)/* Get the object given the GC head */#define FROM_GC(g) ((PyObject *)(((PyGC_Head *)g)+1))</code></pre><p>上面两个转换算法, 隐性要求<code>PyGC_Head</code>大小对齐, 如果<code>PyGC_Head</code>的大小没有对齐, 那么<code>FROM_GC</code>返回的地址也是对齐不上的.</p><h2 id="追踪容器对象"><a href="#追踪容器对象" class="headerlink" title="追踪容器对象"></a>追踪容器对象</h2><p>为了释放循环引用, 需要将容器对象用双向链表连接起来. 不过在上面的内存分配过程中, 我们讲到<code>GC_UNTRACKED</code>标识着这个容器对象还没有被追踪, 那么就需要有个地方将容器对象加入双向链表中. 我们可以以列表对象的创建, 来看看容器对象是什么时候开始被追踪的:</p><pre><code class="c">PyObject *PyList_New(Py_ssize_t size){    PyListObject *op;    ...    op = PyObject_GC_New(PyListObject, &amp;PyList_Type);    ...    _PyObject_GC_TRACK(op);    return (PyObject *) op;}</code></pre><p>在创建<code>list</code>对象的最后, 会通过<code>_PyObject_GC_TRACK</code>宏连接容器对象链表:</p><pre><code class="c">#define _PyObject_GC_TRACK(o) do { \    PyGC_Head *g = _Py_AS_GC(o); \    if (_PyGCHead_REFS(g) != _PyGC_REFS_UNTRACKED) \        Py_FatalError(&quot;GC object already tracked&quot;); \    _PyGCHead_SET_REFS(g, _PyGC_REFS_REACHABLE); \    g-&gt;gc.gc_next = _PyGC_generation0; \    g-&gt;gc.gc_prev = _PyGC_generation0-&gt;gc.gc_prev; \    g-&gt;gc.gc_prev-&gt;gc.gc_next = g; \    _PyGC_generation0-&gt;gc.gc_prev = g; \    } while (0);</code></pre><p>这个宏有一点需要注意的是<code>do while</code>结构不是为了循环, 只是写宏的小技巧. 这个宏的过程可以概述为:</p><ul><li>首先从对象取出<code>PyGC_Head</code>的头地址;</li><li>接下来将标识<code>_PyGC_REFS_REACHABLE</code>设置到<code>PyGC_Head</code>的<code>gc_refs</code>域, 表示”程序可能达到的对象”;</li><li>最后拿出了连接所有容器对象的全局链表, 把这个对象加入到了链表中.</li></ul><p>循环引用垃圾回收正是利用这个全局链表来释放循环引用的对象.</p><p>和追踪容器对象对应的, 有一个宏用于结束追踪容器对象: <code>_PyObject_GC_UNTRACK</code>.</p><pre><code class="c">#define _PyObject_GC_UNTRACK(o) do { \    PyGC_Head *g = _Py_AS_GC(o); \    _PyGCHead_SET_REFS(g, _PyGC_REFS_UNTRACKED); \    g-&gt;gc.gc_prev-&gt;gc.gc_next = g-&gt;gc.gc_next; \    g-&gt;gc.gc_next-&gt;gc.gc_prev = g-&gt;gc.gc_prev; \    g-&gt;gc.gc_next = NULL; \    } while (0);#define _PyObject_GC_IS_TRACKED(o) \    (_PyGC_REFS(o) != _PyGC_REFS_UNTRACKED)</code></pre><p>如果理解了上面的追踪容器对象, 那么这个宏也会十分容易理解: 标识容器对象未被追踪, 并将它从全局的容器对象链表中移除.</p><p>另外, Python还提供了一个宏<code>_PyObject_GC_IS_TRACKED</code>, 用于检查容器对象是否被追踪.</p><p>对于这个全局的容器对象链表, 我们可以画个图表示:</p><p><img src="/images/pygc-2.png" alt=""></p><h2 id="分代容器对象链表"><a href="#分代容器对象链表" class="headerlink" title="分代容器对象链表"></a>分代容器对象链表</h2><p>Python的容器对象链表被分为3代, 每一代都代表前面提到的一条容器对象链表. 为了引入分代机制, 需要增加一个额外的表头:</p><pre><code class="c">[gcmodule.c]struct gc_generation {    PyGC_Head head;    int threshold; /* 开始GC的阀值 */    int count; /* 该代的对象数量 */};</code></pre><p>容器对象将被连接到成员<code>head</code>, 当<code>count</code>成员数量超过<code>threshold</code>阀值时, Python就对这一代开启<code>GC</code>. Python通过一个全局变量来初始化各代的容器链表:</p><pre><code class="c">#define NUM_GENERATIONS 3#define GEN_HEAD(n) (&amp;generations[n].head)static struct gc_generation generations[NUM_GENERATIONS] = {    /* PyGC_Head,                               threshold,      count */    {{{GEN_HEAD(0), GEN_HEAD(0), 0}},           700,            0},    {{{GEN_HEAD(1), GEN_HEAD(1), 0}},           10,             0},    {{{GEN_HEAD(2), GEN_HEAD(2), 0}},           10,             0},};PyGC_Head *_PyGC_generation0 = GEN_HEAD(0);</code></pre><p>各代的<code>PyGC_Head</code>, 双向链表都是以引用自身的形式初始化的, <code>_PyGC_generation0</code>指向0代容器对象链表.</p><p><img src="/images/pygc-3.png" alt=""></p><p>一开始所有刚创建的容器对象都被连接到0代链表上, 在<code>_PyObject_GC_Malloc</code>分配内存中, 会通过<code>generations[0].count++;</code>增加第0代所维护的链表的元素数量(这个<code>count</code>的增加被提前到追踪容器对象之前), 一旦这个<code>count</code>超过了<code>threshold</code>阀值, 就会触发<code>GC</code>. 从新生代到老生代, 只有经过循环引用垃圾回收存活下来的对象, 才能晋升.</p><p>当第0代的对象数量超过阀值后(没有禁用<code>GC</code>/没有正在<code>GC</code>/没有发生<code>GC</code>错误), 就会触发<code>collect_generations</code>: </p><pre><code class="c">static Py_ssize_tcollect_generations(void){    int i;    Py_ssize_t n = 0;    for (i = NUM_GENERATIONS-1; i &gt;= 0; i--) {        if (generations[i].count &gt; generations[i].threshold) {            if (i == NUM_GENERATIONS - 1                &amp;&amp; long_lived_pending &lt; long_lived_total / 4)                continue;            n = collect_with_callback(i);            break;        }    }    return n;}</code></pre><p>通过这个函数我们可以看出来, Python的GC是通过第0代容器对象链表触发的. 在<code>collect_generations</code>中, 会找到超过阀值的”最老”的一代, 然后开始回收这一代的内存.</p><p>需要注意关于<code>long-lived objects</code>, 这在注释中有解释:</p><p>pass</p><h2 id="标记–清除算法"><a href="#标记–清除算法" class="headerlink" title="标记–清除算法"></a>标记–清除算法</h2><p>这是正式进入到Python的垃圾回收, 位于<code>collect_with_callback</code>:</p><pre><code class="c">static Py_ssize_tcollect_with_callback(int generation){    Py_ssize_t result, collected, uncollectable;    invoke_gc_callback(&quot;start&quot;, generation, 0, 0);    result = collect(generation, &amp;collected, &amp;uncollectable, 0);    invoke_gc_callback(&quot;stop&quot;, generation, collected, uncollectable);    return result;}</code></pre><p>真正进行垃圾回收的是<code>collect</code>, 而<code>collect_with_callback</code>的作用是: 在之前和之后调用<code>callback</code>通知客户端垃圾回收开始或停止.</p><pre><code class="c">static Py_ssize_tcollect(int generation, Py_ssize_t *n_collected, Py_ssize_t *n_uncollectable,        int nofail){    int i;    Py_ssize_t m = 0; /* # objects collected */    Py_ssize_t n = 0; /* # unreachable objects that couldn&#39;t be collected */    PyGC_Head *young; /* 即将查找的一代 */    PyGC_Head *old; /* 下一代 */    PyGC_Head unreachable; /* 无异样不能到达对象的链表 */    PyGC_Head finalizers;  /* objects with, &amp; reachable from, __del__ */    PyGC_Head *gc;    _PyTime_t t1 = 0;   /* initialize to prevent a compiler warning */    struct gc_generation_stats *stats = &amp;generation_stats[generation];    /* 更新计数器 */    if (generation+1 &lt; NUM_GENERATIONS)        generations[generation+1].count += 1;    for (i = 0; i &lt;= generation; i++)        generations[i].count = 0;    /* 合并我们正在处理的代及其以下的代的链表 */    for (i = 0; i &lt; generation; i++) {        gc_list_merge(GEN_HEAD(i), GEN_HEAD(generation));    }    /* 给old变量赋值 */    young = GEN_HEAD(generation);    if (generation &lt; NUM_GENERATIONS-1)        old = GEN_HEAD(generation+1);    else        old = young;    update_refs(young); /* 把引用计数器复制到用于循环引用垃圾回收的头里 */    subtract_refs(young); /* 删除实际引用 */    /* 将计数器值为0的对象移动的unreachable对象链表中 */    gc_list_init(&amp;unreachable);     move_unreachable(young, &amp;unreachable);    /* 将循环引用垃圾回收中幸存的对象移到下一代 */    if (young != old) {        if (generation == NUM_GENERATIONS - 2) {            long_lived_pending += gc_list_size(young);        }        gc_list_merge(young, old);    }    else {        untrack_dicts(young);        long_lived_pending = 0;        long_lived_total = gc_list_size(young);    }    /* 移出unreachable对象链表中有终结器的对象 */    gc_list_init(&amp;finalizers);    move_legacy_finalizers(&amp;unreachable, &amp;finalizers);    move_legacy_finalizer_reachable(&amp;finalizers);    /* 处理弱引用, 如果可能, 调用弱引用中注册的callback操作 */    m += handle_weakrefs(&amp;unreachable, old);    /* 尝试调用unreachable中的容器对象tp_finalize操作, 如果有的话 */    finalize_garbage(&amp;unreachable);    if (check_garbage(&amp;unreachable)) {        revive_garbage(&amp;unreachable);        gc_list_merge(&amp;unreachable, old);    }    else {        /* F. 调用tp_clear回收&quot;不可达&quot;容器对象        delete_garbage(&amp;unreachable, old);    }      /* E.处理finalizers链表 */    (void)handle_legacy_finalizers(&amp;finalizers, old);    /* 如果第3代超过了阀值, 则会清理freelists */    if (generation == NUM_GENERATIONS-1) {        clear_freelists();    }    if (PyErr_Occurred()) { /* 发生了GC异常 */        if (nofail) {            PyErr_Clear();        }        else {            if (gc_str == NULL)                gc_str = PyUnicode_FromString(&quot;garbage collection&quot;);            PyErr_WriteUnraisable(gc_str);            Py_FatalError(&quot;unexpected exception during garbage collection&quot;);        }    }    /* 更新统计信息 */    if (n_collected)        *n_collected = m;    if (n_uncollectable)        *n_uncollectable = n;    stats-&gt;collections++;    stats-&gt;collected += m;    stats-&gt;uncollectable += n;    return n+m;}</code></pre><p>我们将这一过程分为几个小过程来一步步分析:</p><ul><li><p>(A). get_list_merge(): 将<code>from</code>链表连接到<code>to</code>链表的末尾:</p><pre><code class="c">  [gcmodule.c]  static void gc_list_merge(PyGC_Head *from, PyGC_Head *to)  {      PyGC_Head *tail;      assert(from != to);      if (!gc_list_is_empty(from)) {          tail = to-&gt;gc.gc_prev;          tail-&gt;gc.gc_next = from-&gt;gc.gc_next;          tail-&gt;gc.gc_next-&gt;gc.gc_prev = tail;          to-&gt;gc.gc_prev = from-&gt;gc.gc_prev;          to-&gt;gc.gc_prev-&gt;gc.gc_next = to;      }      gc_list_init(from);  }  static void gc_list_init(PyGC_Head *list)  {      list-&gt;gc.gc_prev = list;      list-&gt;gc.gc_next = list;  }</code></pre><p>  这也是<code>collect_generations</code>找到的是超过阀值”最老”的一代, 而<code>GC</code>能够处理它以及比它”年轻”的代的原因. 之后的标记—清楚算法将在这条合并后的链表上进行.</p></li><li><p>(B). update_refs()和subtract_refs(): 在这个阶段我们需要找到”Root Object”(不能被删除的对象)对象的集合. 这个过程中关键点在于怎么处理循环引用, 例如<code>A</code>引用<code>B</code>, 而<code>B</code>又引用<code>A</code>的情况.</p><ul><li>一种可选的方法是, 对于<code>A</code>引用<code>B</code>, 则将<code>B</code>的引用计数减一; 反之, 则将<code>A</code>的引用计数减一. 如果两个对象互相引用, 那么它的引用计数将变为<code>0</code>, 表示”不可达”.<br><br>这种方法有个问题是, 如果<code>A</code>引用<code>C</code>, 而<code>C</code>不在这个链表中, 如果将<code>C</code>的引用计数减一, 而最终<code>A</code>没有被回收, 那么将会造成对<code>C</code>的悬空引用, 这就需要对<code>C</code>的引用进行恢复.</li><li><p>针对循环引用, Python采用更好的做法: 复制原始引用, 只改动副本计数器, 即<code>gc_refs</code>.</p><pre><code class="c">static voidupdate_refs(PyGC_Head *containers){  PyGC_Head *gc = containers-&gt;gc.gc_next;  for (; gc != containers; gc = gc-&gt;gc.gc_next) {      _PyGCHead_SET_REFS(gc, Py_REFCNT(FROM_GC(gc)));  }}</code></pre><p><code>update_refs</code>遍历容器对象链表, 复制容器对象的真实引用计数到<code>PyGC_Head-&gt;gc_refs</code>中. 而<code>subtract_refs</code>负责清除容链表器对象之间的循环引用.</p><pre><code class="c">static voidsubtract_refs(PyGC_Head *containers){  traverseproc traverse;  PyGC_Head *gc = containers-&gt;gc.gc_next;  for (; gc != containers; gc=gc-&gt;gc.gc_next) {      traverse = Py_TYPE(FROM_GC(gc))-&gt;tp_traverse;      (void) traverse(FROM_GC(gc),                     (visitproc)visit_decref,                     NULL);  }}</code></pre><p><code>subtract_refs</code>中会遍历所有容器对象, 然后获得容器对象上的<code>tp_traverse</code>函数指针, 这个函数的会遍历容器对象里的元素, 并且调用函数参数<code>visit</code>传递进去的函数来访问元素. 这样一来, <code>subtract_refs</code>中就能通过传递进去函数<code>visit_decref</code>访问容器对象里的元素.<br><br>*NOTE: <code>traverse</code>实现了访问者模式, 这里访问用的函数为<code>visit_decref</code>.</p><p>下面是<code>visit_decref</code>的定义:</p><pre><code class="c">static intvisit_decref(PyObject *op, void *data){  if (PyObject_IS_GC(op)) {      PyGC_Head *gc = AS_GC(op);      if (_PyGCHead_REFS(gc) &gt; 0)          _PyGCHead_DECREF(gc);  }  return 0;}</code></pre><p>在完成了<code>subtract_refs</code>之后, 容器对象链表中所有容器对象之间的循环引用都已被摘除. 如果还有容器对象的<code>gc_ref!=0</code>, 就意味着存在这些对象的外部引用, 也就是作为后面”标记—清楚”算法的”Root Object”集合.</p></li></ul></li><li>(C). move_unreachable(): 将原始链表划分为两个链表.<pre><code class="c">  static void  move_unreachable(PyGC_Head *young, PyGC_Head *unreachable)  {      PyGC_Head *gc = young-&gt;gc.gc_next;      while (gc != young) {          PyGC_Head *next;          if (_PyGCHead_REFS(gc)) {              PyObject *op = FROM_GC(gc);              traverseproc traverse = Py_TYPE(op)-&gt;tp_traverse;              _PyGCHead_SET_REFS(gc, GC_REACHABLE);              (void) traverse(op, (visitproc)visit_reachable, (void *)young);              next = gc-&gt;gc.gc_next;          }          else {              next = gc-&gt;gc.gc_next;              gc_list_move(gc, unreachable);              _PyGCHead_SET_REFS(gc, GC_TENTATIVELY_UNREACHABLE);          }          gc = next;      }  }</code></pre>  这一过程分为两种情况:<ul><li>gc_refs为0的容器对象: 对于这类容器对象, 我们将它标记为<code>GC_TENTATIVELY_UNREACHABLE</code>, 意思是”暂且认为她是不可达的”;</li><li>gc_refs不为0的容器对象: 对于这些有外部引用的对象, 即<code>Root Object</code>, 我们会将它标记为<code>GC_REACHABLE</code>, 意思是”可达”的. 而且我们使用<code>visit_reachable</code>去访问容器对象里面的元素:<pre><code class="c">static intvisit_reachable(PyObject *op, PyGC_Head *reachable){  if (PyObject_IS_GC(op)) {       PyGC_Head *gc = AS_GC(op);      const Py_ssize_t gc_refs = _PyGCHead_REFS(gc);      if (gc_refs == 0) { /* 对于还没有处理的对象, 恢复其gc_refs */          _PyGCHead_SET_REFS(gc, 1);      }/* 对于已经被挪到unreachable链表的对象, 再将其移到young链表中 */      else if (gc_refs == GC_TENTATIVELY_UNREACHABLE) {           gc_list_move(gc, reachable);          _PyGCHead_SET_REFS(gc, 1);      }  }  return 0;}</code></pre>对于”可达”的容器对象里的容器对象, 如果, <code>gc_refs</code>为0, 则将其设定为1, 以表示准确的引用关系; 如果<code>gc_refs</code>为<code>GC_TENTATIVELY_UNREACHABLE</code>, 说明里面存了非活动对象, 需要从里面救出来, 移动到<code>reachable</code>链表(即<code>young</code>容器对象链表), 将<code>gc_refs</code>设为1.</li></ul></li><li>(D). move_legacy_finalizers(): 移出<code>unreachable</code>容器链表中那些有终结器的容器对象, 并加入<code>finalizers</code>链表, 标识为<code>GC_REACHABLE</code>.<pre><code class="c">  static void  move_legacy_finalizers(PyGC_Head *unreachable, PyGC_Head *finalizers)  {      PyGC_Head *gc;      PyGC_Head *next;      for (gc = unreachable-&gt;gc.gc_next; gc != unreachable; gc = next) {          PyObject *op = FROM_GC(gc);          next = gc-&gt;gc.gc_next;          if (has_legacy_finalizer(op)) {              gc_list_move(gc, finalizers);              _PyGCHead_SET_REFS(gc, GC_REACHABLE);          }      }  }</code></pre></li><li>(E). <code>move_legacy_finalizer_reachable()</code>: 从已经移出的<code>finalizers</code>链表中容器对象开始查找, 移出该对象引用的对象, 这些被引用的对象也不应该被释放.<pre><code class="c">  static void  move_legacy_finalizer_reachable(PyGC_Head *finalizers)  {      traverseproc traverse;      PyGC_Head *gc = finalizers-&gt;gc.gc_next;      for (; gc != finalizers; gc = gc-&gt;gc.gc_next) {          traverse = Py_TYPE(FROM_GC(gc))-&gt;tp_traverse;          (void) traverse(FROM_GC(gc), visitproc)visit_move, (void *)finalizers);      }  }</code></pre><pre><code class="c">  static int  visit_move(PyObject *op, PyGC_Head *tolist)  {      if (PyObject_IS_GC(op)) {          if (IS_TENTATIVELY_UNREACHABLE(op)) {              PyGC_Head *gc = AS_GC(op);              gc_list_move(gc, tolist);              _PyGCHead_SET_REFS(gc, GC_REACHABLE);          }      }      return 0;  }</code></pre></li><li><p>(F). delete_garbage(): 打破容器对象的循环引用, 这就需要对对象的实际ob_ref做修改, 是它变为0, 触发对象的销毁.</p><pre><code class="c">  static void  delete_garbage(PyGC_Head *collectable, PyGC_Head *old)  {      inquiry clear;      while (!gc_list_is_empty(collectable)) {          PyGC_Head *gc = collectable-&gt;gc.gc_next;          PyObject *op = FROM_GC(gc);          if ((clear = Py_TYPE(op)-&gt;tp_clear) != NULL) {              Py_INCREF(op);              clear(op);              Py_DECREF(op);          }          if (collectable-&gt;gc.gc_next == gc) {              gc_list_move(gc, old);              _PyGCHead_SET_REFS(gc, GC_REACHABLE);          }      }  }</code></pre><p>  在其中会调用容器对象的<code>tp_clear</code>操作, 调整容器对象中引用的每个对象的引用计数值, 从而打破循环引用安全回收.</p><p>  现在我们假设两个列表<code>list_1</code>和<code>list_2</code>互相引用, 我们看看是怎么回收这两个对象的. 假设先调用<code>list_1</code>的<code>tp_clear</code>操作:</p><pre><code class="c">  static int  list_clear(PyListObject *a)  {      Py_ssize_t i;      PyObject **item = a-&gt;ob_item;      if (item != NULL) {          i = Py_SIZE(a);          Py_SIZE(a) = 0;          a-&gt;ob_item = NULL;          a-&gt;allocated = 0;          while (--i &gt;= 0) {              Py_XDECREF(item[i]);          }          PyMem_FREE(item);      }      return 0;  }</code></pre><p>  它会先减少<code>list_1</code>中引用的每一个对象的引用计数, 即<code>list_2</code>的引用计数会减少到0, 引发对象销毁工作, 调用<code>list_2</code>的<code>tp_dealloc</code>操作, :</p><pre><code class="c">  static void  list_dealloc(PyListObject *op)  {      Py_ssize_t i;      PyObject_GC_UnTrack(op);      if (op-&gt;ob_item != NULL) {          i = Py_SIZE(op);          while (--i &gt;= 0) {              Py_XDECREF(op-&gt;ob_item[i]);          }          PyMem_FREE(op-&gt;ob_item);      }      ......  }</code></pre><p>  <code>list_2</code>的<code>tp_dealloc</code>首先会将自己从<code>GC</code>容器对象链表中移出, 同样它也会调整引用的对象的计数值, 使得<code>list_1</code>的引用计数减少到0, 触发<code>list_1</code>的销毁.</p></li><li><p>(G). handle_legacy_finalizers(): 对全局变量<code>garbage</code>注册之前保存的<code>finalizers</code>链表.</p><pre><code class="c">  static int  handle_legacy_finalizers(PyGC_Head *finalizers, PyGC_Head *old)  {      PyGC_Head *gc = finalizers-&gt;gc.gc_next;      if (garbage == NULL) {          garbage = PyList_New(0);      }      for (; gc != finalizers; gc = gc-&gt;gc.gc_next) {          PyObject *op = FROM_GC(gc);          if ((debug &amp; DEBUG_SAVEALL) || has_legacy_finalizer(op)) {              if (PyList_Append(garbage, op) &lt; 0)                  return -1;          }      }      gc_list_merge(finalizers, old);      return 0;  }</code></pre><p>  全局变量<code>garbage</code>是一个<code>PyList_Object</code>, 它保存了那些注册了<code>__del__</code>操作的实例对象, 而且这些对象会晋升到”老一代”.</p><p>  为了能处理这些变量, Python提供了<code>gc</code>模块, 来处理全局变量<code>garbage</code>:</p><pre><code class="python">  &gt;&gt;&gt; import gc  &gt;&gt;&gt; gc.garbage</code></pre></li></ul><p>另外, 关于Python的垃圾回收有几点需要注意的:</p><ul><li>在垃圾回收中有对弱引用(<code>weakref</code>)的处理, 因为它们能够注册<code>callback</code>, 能被正确的清理;</li><li>而有终结器<code>__del__</code>的实例对象不同, 在Python3之前它们是不能够自动清理的, 原因是假设两个对象<code>A`</code>B<code>循环引用, 各自有自己的终结器, 如果先终结化了第一个对象</code>A<code>, 而终结第二个对象</code>B<code>的时候, 如果需要用到</code>A`, 那么就会陷入矛盾. 而在Python3中是通过一个临时可见的链表保存着这些容器对象, 使得垃圾回收能够清理这些有终结器的实例对象.</li><li>虽然大部分对象创建的时候通过<code>PyGC_New</code>添加到了容器对象链表中, 但是并非垃圾收集机制才能回收, 正常的引用计数就可以完成对象的销毁.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Python中的垃圾回收&quot;&gt;&lt;a href=&quot;#Python中的垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;Python中的垃圾回收&quot;&gt;&lt;/a&gt;Python中的垃圾回收&lt;/h2&gt;&lt;p&gt;在Python中, 主要的内存管理手段是引用计数, 而标记-清除算法和分代收集机制是为了打破循环引用而补充的技术.&lt;/p&gt;
&lt;h2 id=&quot;引用计数法&quot;&gt;&lt;a href=&quot;#引用计数法&quot; class=&quot;headerlink&quot; title=&quot;引用计数法&quot;&gt;&lt;/a&gt;引用计数法&lt;/h2&gt;&lt;p&gt;经过前面的探索, 我们知道在所有Python对象头部都有着一个计数器, 如果对象的引用增加, 则计数器加一, 反之减一. 所以在Python中, 有两个宏定义来操作这个计数器:&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Sublime快捷键</title>
    <link href="http://shawnz.me/posts/691b6e2d/"/>
    <id>http://shawnz.me/posts/691b6e2d/</id>
    <published>2018-01-18T15:50:13.000Z</published>
    <updated>2018-03-10T06:20:54.194Z</updated>
    
    <content type="html"><![CDATA[<!--  --><a id="more"></a><h2 id="精华版"><a href="#精华版" class="headerlink" title="精华版"></a>精华版</h2><table><thead><tr><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td><strong>Ctrl+Shift+P</strong></td><td>打开命令面板</td></tr><tr><td>Ctrl+P</td><td>搜索项目中的文件</td></tr><tr><td>Ctrl+G</td><td>跳转到第几行</td></tr><tr><td><strong>Ctrl+W</strong></td><td>关闭<strong>当前</strong>打开文件</td></tr><tr><td><strong>Ctrl+Shift+W</strong></td><td>关闭<strong>所有</strong>打开文件</td></tr><tr><td>Ctrl+Shift+V</td><td>粘贴并格式化</td></tr><tr><td><strong>Ctrl+D</strong></td><td>选择单词，重复可增加选择下一个相同的单词</td></tr><tr><td><strong>Ctrl+L</strong></td><td>选择行，重复可依次增加选择下一行</td></tr><tr><td>Ctrl+Shift+L</td><td>选择多行</td></tr><tr><td><strong>Ctrl+Enter</strong></td><td>在当前行<strong>后</strong>插入新行</td></tr><tr><td><strong>Ctrl+Shift+Enter</strong></td><td>在当<strong>前</strong>行前插入新行</td></tr><tr><td>Ctrl+X</td><td>删除当前行</td></tr><tr><td>Ctrl+M</td><td>跳转到对应括号</td></tr><tr><td>Ctrl+U</td><td>软撤销，撤销光标位置</td></tr><tr><td><strong>Ctrl+J</strong></td><td><strong>合并行（==下一行移上来==）</strong></td></tr><tr><td><strong>Ctrl+F</strong></td><td>查找内容</td></tr><tr><td>Ctrl+Shift+F</td><td>查找并替换</td></tr><tr><td><strong>Ctrl+H</strong></td><td><strong>替换</strong>（可以全部也可以部分替换）(也可以查找)</td></tr><tr><td>Ctrl+R</td><td>前往 method</td></tr><tr><td>Ctrl+N</td><td>新建窗口</td></tr><tr><td><strong>Ctrl+K+B</strong></td><td>（<strong>要先按Ctrl+K再按B</strong>）==开关侧栏==</td></tr><tr><td>Ctrl+Shift+M</td><td>？选中当前括号内容，重复可选着括号本身</td></tr><tr><td>Ctrl+F2</td><td>设置/删除标记</td></tr><tr><td>Ctrl+/</td><td>注释当前行</td></tr><tr><td>Ctrl+Shift+/</td><td>当前位置插入注释</td></tr><tr><td>Ctrl+Alt+/</td><td>？块注释，并Focus到首行，写注释说明用的</td></tr><tr><td>Ctrl+Shift+A</td><td>选择当前标签前后，修改标签用的</td></tr><tr><td>F11</td><td>全屏</td></tr><tr><td>Shift+F11</td><td>全屏免打扰模式，只编辑当前文件</td></tr><tr><td><strong>Alt+F3</strong></td><td>选择所有相同的词</td></tr><tr><td><strong>Alt+.</strong></td><td>闭合标签</td></tr><tr><td><strong>Alt+Shift+数字</strong></td><td><strong>分屏显示</strong></td></tr><tr><td><strong>Alt+数字</strong></td><td>切换打开第N个文件</td></tr><tr><td>Shift+右键拖动(或中键拖动）</td><td>光标多不，用来更改或插入列内容</td></tr><tr><td>鼠标的前进后退键</td><td>可切换Tab文件</td></tr><tr><td>按Ctrl,依次点击或选取</td><td>可需要编辑的多个位置</td></tr><tr><td>按Ctrl+Shift+上下键</td><td>可替换行</td></tr></tbody></table><h2 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a>选择类</h2><table><thead><tr><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td>Ctrl+D</td><td>选中光标所占的文本，继续操作则会选中下一个相同的文本。</td></tr><tr><td><strong>Alt+F3</strong></td><td>选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个例子：快速选中并更改所有相同的变量名、函数名等。</td></tr><tr><td><strong>Ctrl+L</strong></td><td><strong>选中整行，继续操作则继续选择下一行</strong>，++继续操作的效果和 Shift+↓效果类似++。</td></tr><tr><td><strong>Ctrl+Shift+L</strong></td><td>++先选中多行，再按下快捷键，会在==每行行尾插入光标==，即可同时编辑这些行++</td></tr><tr><td>Ctrl+Shift+M</td><td>选择括号内的内容（继续选择父括号）。举个例子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。</td></tr><tr><td>Ctrl+M</td><td>？光标移动至括号内结束或开始的位置。</td></tr><tr><td><strong>Ctrl+Enter</strong></td><td>在下一行插入新行。举个例子：即使光标不在行尾，也能快速向下插入一行。</td></tr><tr><td><strong>Ctrl+Shift+Enter</strong></td><td>在上一行插入新行。举个例子：即使光标不在行首，也能快速向上插入一行。</td></tr><tr><td>Ctrl+Shift+[</td><td>选中代码，按下快捷键，折叠代码。</td></tr><tr><td>Ctrl+Shift+]</td><td>选中代码，按下快捷键，展开代码。</td></tr><tr><td><strong>Ctrl+K+0</strong></td><td>展开所有折叠代码。</td></tr><tr><td><strong>Ctrl+←</strong></td><td>向左<strong>单位性地移动光标</strong>，快速移动光标。</td></tr><tr><td>Ctrl+→</td><td>向右单位性地移动光标，快速移动光标。</td></tr><tr><td><strong>shift+↑</strong></td><td>向上选中多行。</td></tr><tr><td>shift+↓</td><td>向下选中多行。</td></tr><tr><td><strong>Shift+←</strong></td><td>向左选中文本。</td></tr><tr><td>Shift+→</td><td>向右选中文本。</td></tr><tr><td><strong>Ctrl+Shift+←</strong></td><td>向左单位性地选中文本。</td></tr><tr><td>Ctrl+Shift+→</td><td>向右单位性地选中文本。</td></tr><tr><td>Ctrl+Shift+↑</td><td>将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。</td></tr><tr><td>Ctrl+Shift+↓</td><td>将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。</td></tr><tr><td>Ctrl+Alt+↑</td><td>向上添加多行光标，可同时编辑多行。</td></tr><tr><td>Ctrl+Alt+↓</td><td>向下添加多行光标，可同时编辑多行。</td></tr></tbody></table><h2 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h2><table><thead><tr><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td>Ctrl+J</td><td>合并选中的多行代码为一行。举个例子：将多行格式的CSS属性合并为一行。</td></tr><tr><td>Ctrl+Shift+D</td><td>复制光标所在整行，插入到下一行。</td></tr><tr><td>Tab / ctrl+]</td><td>向右缩进。</td></tr><tr><td><strong>Shift+Tab / ctrl+[</strong></td><td>向左缩进。</td></tr><tr><td><strong>Ctrl+K+K</strong></td><td>从光标处开始删除代码至行尾。</td></tr><tr><td><strong>Ctrl+Shift+K</strong></td><td>删除整行（<strong>也可以用Ctrl+X</strong>来剪切整行）</td></tr><tr><td>Ctrl+/</td><td>注释单行。</td></tr><tr><td><strong>Ctrl+Shift+/</strong></td><td>注释多行。</td></tr><tr><td>Ctrl+K+U</td><td>转换大写。</td></tr><tr><td>Ctrl+K+L</td><td>转换小写。</td></tr><tr><td>Ctrl+Z</td><td>撤销。</td></tr><tr><td>Ctrl+Y</td><td>恢复撤销。</td></tr><tr><td>Ctrl+U</td><td>软撤销，感觉和 Gtrl+Z 一样。</td></tr><tr><td><strong>Ctrl+F2</strong></td><td><strong>设置书签</strong></td></tr><tr><td>Ctrl+T</td><td>左右字母互换。</td></tr><tr><td><strong>F6</strong></td><td><strong>单词检测拼写</strong></td></tr></tbody></table><h2 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h2><table><thead><tr><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td><strong>Ctrl+F</strong></td><td>打开底部搜索框，查找关键字。</td></tr><tr><td><strong>Ctrl+shift+F</strong></td><td>在<strong>文件夹内查找</strong>，与普通编辑器不同的地方是<strong>sublime允许添加多个文件夹进行查找</strong>，略高端，未研究。</td></tr><tr><td><strong>Ctrl+P</strong></td><td><strong>打开搜索框</strong>。举个例子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。</td></tr><tr><td>Ctrl+G</td><td>打开搜索框，自动带：，输入数字跳转到该行代码。举个例子：在页面代码比较长的文件中快速定位。</td></tr><tr><td>Ctrl+R</td><td>打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个例子：在函数较多的页面快速查找某个函数。</td></tr><tr><td>Ctrl+：</td><td>打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。</td></tr><tr><td><strong>==Ctrl+Shift+P==</strong></td><td><strong>==打开命令框==</strong>。场景例子：打开命名框，输入关键字，调用sublimetext或插件的功能，例如使用package安装插件。</td></tr><tr><td>Esc</td><td>退出光标多行选择，退出搜索框，命令框等。</td></tr></tbody></table><h2 id="显示类"><a href="#显示类" class="headerlink" title="显示类"></a>显示类</h2><table><thead><tr><th>快捷键</th><th>操作</th></tr></thead><tbody><tr><td><strong>Ctrl+Tab</strong></td><td>++按==文件浏览过的顺序==，切换当前窗口的标签页++</td></tr><tr><td><strong>Ctrl+PageDown</strong></td><td>向左切换当前窗口的标签页。</td></tr><tr><td><strong>Ctrl+PageUp</strong></td><td>向右切换当前窗口的标签页。</td></tr><tr><td>Alt+Shift+1</td><td>窗口分屏，恢复默认1屏（非小键盘的数字）</td></tr><tr><td>Alt+Shift+2</td><td>左右分屏-2列</td></tr><tr><td>Alt+Shift+3</td><td>左右分屏-3列</td></tr><tr><td>Alt+Shift+4</td><td>左右分屏-4列</td></tr><tr><td>Alt+Shift+5</td><td>等分4屏</td></tr><tr><td>Alt+Shift+8</td><td>垂直分屏-2屏</td></tr><tr><td>Alt+Shift+9</td><td>垂直分屏-3屏</td></tr><tr><td>Ctrl+K+B</td><td>开启/关闭侧边栏。</td></tr><tr><td><strong>F11</strong></td><td><strong>全屏模式</strong></td></tr><tr><td><strong>Shift+F11</strong></td><td><strong>免打扰模式</strong></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;!--  --&gt;
    
    </summary>
    
      <category term="工具" scheme="http://shawnz.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://shawnz.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="快捷键" scheme="http://shawnz.me/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python源码阅读-运行时环境初始化</title>
    <link href="http://shawnz.me/posts/73bb8543/"/>
    <id>http://shawnz.me/posts/73bb8543/</id>
    <published>2018-01-17T03:32:44.000Z</published>
    <updated>2018-03-10T06:20:54.162Z</updated>
    
    <content type="html"><![CDATA[<p>前面已经接触了许多执行引擎相关的工作，然而关于Python虚拟机还有一大块的是我们没有了解的，那就是运行时环境的初始化。</p><p>Python3启动后真正有意义的初始化动作是从<code>Py_Initialize</code>(位于<code>pylifecycle.c</code>文件)开始的，其内部调用的就是<code>_Py_InitializeEx_Private</code>函数，本节的主要内容就是以这个函数为入口，深入理解Python虚拟机的启动流程。</p><a id="more"></a><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>在接触虚拟机启动之前先了解一下Python的线程模型，我们知道Python的进程和线程是来自于操作系统，这里所说的线程模型是指在Python内部维护的这些操作系统进程和线程状态。下面是进程和线程的结构体定义：</p><pre><code class="c">typedef struct _is {    struct _is *next;    struct _ts *tstate_head;    PyObject *modules;    PyObject *modules_by_index;    PyObject *sysdict;    PyObject *builtins;    ......    _PyFrameEvalFunction eval_frame;} PyInterpreterState;</code></pre><p>以及</p><pre><code class="c">typedef struct _ts {    struct _ts *prev;    struct _ts *next;    PyInterpreterState *interp;    struct _frame *frame;    int recursion_depth;    ......    PyObject *dict;  /* Stores per-thread state */    int gilstate_counter;    long thread_id; /* Thread id where this tstate was created */    ......} PyThreadState;</code></pre><h2 id="线程环境初始化"><a href="#线程环境初始化" class="headerlink" title="线程环境初始化"></a>线程环境初始化</h2><p>在虚拟机启动的时候，首先会初始化线程和进程环境。</p><pre><code class="c">interp = PyInterpreterState_New();tstate = PyThreadState_New(interp);(void) PyThreadState_Swap(tstate);</code></pre><p>可以看到虚拟机首先会通过<code>PyInterpreterState_New</code>创建一个进程对象：</p><pre><code class="c">static PyInterpreterState *interp_head = NULL;PyInterpreterState *PyInterpreterState_New(void){    PyInterpreterState *interp = (PyInterpreterState *)                                 PyMem_RawMalloc(sizeof(PyInterpreterState));    if (interp != NULL) {        HEAD_INIT();        interp-&gt;modules = NULL;        interp-&gt;modules_by_index = NULL;        interp-&gt;sysdict = NULL;        interp-&gt;builtins = NULL;        interp-&gt;builtins_copy = NULL;        interp-&gt;tstate_head = NULL;        ......        interp-&gt;eval_frame = _PyEval_EvalFrameDefault;        HEAD_LOCK();        interp-&gt;next = interp_head;        interp_head = interp;        HEAD_UNLOCK();    }    return interp;}</code></pre><p>在python内部维护着一套全局管理的<code>PyInterpreterState</code>链表，表头为<code>interp_head</code>，通过指针<code>interp-&gt;next</code>指向下一个进程对象。</p><p>在创建完进程对象后，接着又创建了一个全新线程状态对象：</p><pre><code class="c">PyThreadState *PyThreadState_New(PyInterpreterState *interp){    return new_threadstate(interp, 1);}static PyThreadState *new_threadstate(PyInterpreterState *interp, int init){    PyThreadState *tstate = (PyThreadState *)PyMem_RawMalloc(sizeof(PyThreadState));    if (_PyThreadState_GetFrame == NULL) /* 设置全局的函数调用栈获取函数 */        _PyThreadState_GetFrame = threadstate_getframe;    if (tstate != NULL) {        tstate-&gt;interp = interp; /* 和线程对应的进程对象 */        tstate-&gt;frame = NULL;        tstate-&gt;recursion_depth = 0;        tstate-&gt;overflowed = 0;        tstate-&gt;recursion_critical = 0;        tstate-&gt;tracing = 0;        tstate-&gt;use_tracing = 0;        tstate-&gt;gilstate_counter = 0;        tstate-&gt;async_exc = NULL;#ifdef WITH_THREAD        tstate-&gt;thread_id = PyThread_get_thread_ident(); /* 线程标识 */#else        tstate-&gt;thread_id = 0;#endif        tstate-&gt;dict = NULL;        ......        if (init)            _PyThreadState_Init(tstate);        HEAD_LOCK();        tstate-&gt;prev = NULL; /* 线程链 */        tstate-&gt;next = interp-&gt;tstate_head;        if (tstate-&gt;next)            tstate-&gt;next-&gt;prev = tstate;        interp-&gt;tstate_head = tstate; /* 反向关联进程 */        HEAD_UNLOCK();    }    return tstate;}</code></pre><p>在初始化线程对象的时候，Python也设置了从线程中获取函数调用栈的方法，这里说函数调用”栈“而不是“帧”是因为<code>PyFrameObject</code>之间也是一个链表结构。</p><p>在创建完进程和线程对象之后，虚拟机也为它俩建立了联系，这样任何时候都可以很容易的在<code>PyInterpreterState</code>对象和<code>PyThreadState</code>对象之间穿梭。</p><p>并且Python还通过一个全局的变量维护当前线程对象：</p><pre><code class="c">_Py_atomic_address _PyThreadState_Current = {0};</code></pre><p>这里比较有意思的是<code>_Py_atomic_address</code>，在Python内部有一套<code>原子API</code>，使用这些<code>原子操作API</code>操作<code>原子变量</code>时，其它线程是不能访问该变量的。所以对那个全局的当前线程变量的操作是”线程安全“的。</p><pre><code class="c">#define GET_TSTATE() \    ((PyThreadState*)_Py_atomic_load_relaxed(&amp;_PyThreadState_Current))#define SET_TSTATE(value) \    _Py_atomic_store_relaxed(&amp;_PyThreadState_Current, (uintptr_t)(value))PyThreadState *PyThreadState_Swap(PyThreadState *newts){    PyThreadState *oldts = GET_TSTATE();    SET_TSTATE(newts);    return oldts;}</code></pre><p><code>*NOTE：Python中的GIL机制保证的是单条字节码执行的线程安全，不保证Python语句执行的线程安全。</code></p><p>在初始化线程环境后，虚拟机会对Python的类型系统和缓冲池进行初始化。接着就进入了系统模块的初始化工作。</p><h2 id="系统模块初始化"><a href="#系统模块初始化" class="headerlink" title="系统模块初始化"></a>系统模块初始化</h2><p>系统模块的初始，得从<code>__builtin__</code>开始：</p><pre><code class="c">interp-&gt;modules = PyDict_New();bimod = _PyBuiltin_Init();_PyImport_FixupBuiltin(bimod, &quot;builtins&quot;);interp-&gt;builtins = PyModule_GetDict(bimod);</code></pre><p>可以从上面看到，进程对象创建了一个字典<code>modules</code>，维护着当前进程中的所有模块。</p><p>将内置类型对象添加到<code>builtins</code>模块中是在<code>_PyBuiltin_Init</code>中完成的：</p><pre><code class="c">PyObject *_PyBuiltin_Init(void){    PyObject *mod, *dict, *debug;    ...... /* 检查类型系统是否初始化完毕 */    mod = PyModule_Create(&amp;builtinsmodule); /* 创建builtins模块 */    dict = PyModule_GetDict(mod);#define SETBUILTIN(NAME, OBJECT) \ /* 宏定义 */    if (PyDict_SetItemString(dict, NAME, (PyObject *)OBJECT) &lt; 0)       \        return NULL;                                                    \    /* 将内置类型对象添加builtins模块的字典中 */    SETBUILTIN(&quot;None&quot;,                  Py_None);    SETBUILTIN(&quot;Ellipsis&quot;,              Py_Ellipsis);    ......    SETBUILTIN(&quot;zip&quot;,                   &amp;PyZip_Type);    return mod;#undef SETBUILTIN}</code></pre><p><code>_PyBuiltin_Init</code>通过两个步骤完成对<code>builtin</code>的设置：</p><ul><li>创建<code>PyModuleObject</code>对象，这个对象正是Python内部模块的实现；</li><li>填充内置类型对象到新创建的<code>__builtin__</code>模块中；</li></ul><p>第二步的工作十分简单，我们直接来看看<code>__builtin__</code>模块是怎么创建的。</p><h3 id="builtin-模块"><a href="#builtin-模块" class="headerlink" title="builtin 模块"></a><strong>builtin</strong> 模块</h3><p>模块的创建是通过<code>PyModule_Create2</code>函数完成的：</p><pre><code class="c">PyObject *PyModule_Create2(struct PyModuleDef* module, int module_api_version){    const char* name;    PyModuleObject *m;    PyInterpreterState *interp = PyThreadState_Get()-&gt;interp; /* 获取进程对象 */    if (interp-&gt;modules == NULL)        Py_FatalError(&quot;Python import machinery not initialized&quot;);    if (!PyModuleDef_Init(module))        return NULL;    name = module-&gt;m_name;    if ((m = (PyModuleObject*)PyModule_New(name)) == NULL)        return NULL;    ......    if (module-&gt;m_methods != NULL) { /* 添加module函数中的methods */        if (PyModule_AddFunctions((PyObject *) m, module-&gt;m_methods) != 0) {            return NULL;        }    }    if (module-&gt;m_doc != NULL) { /* 添加module文档注释 */        if (PyModule_SetDocString((PyObject *) m, module-&gt;m_doc) != 0) {            return NULL;        }    }    m-&gt;md_def = module;    return (PyObject*)m;}</code></pre><p>我们说<code>PyModuleObject</code>才是Python中模块的实现，那么<code>PyModuleDef</code>又是什么呢？我们来比较一下：</p><pre><code class="c">typedef struct PyModuleDef{  PyModuleDef_Base m_base;  const char* m_name;  const char* m_doc;  Py_ssize_t m_size;  PyMethodDef *m_methods;  struct PyModuleDef_Slot* m_slots;  traverseproc m_traverse;  inquiry m_clear;  freefunc m_free;} PyModuleDef;typedef struct {    PyObject_HEAD    PyObject *md_dict;    struct PyModuleDef *md_def;    void *md_state;    PyObject *md_weaklist;    PyObject *md_name;} PyModuleObject;</code></pre><p>应该可以大致看出来<code>PyModuleDef</code>是创建模块对象的一个模块定义，在这里面定义了模块名、注释以及模块函数等等。这么一来<code>builtinsmodule</code>应该就是<code>builtin</code>模块的定义所在，我来看看这里面都有什么：</p><pre><code class="c">static struct PyModuleDef builtinsmodule = {    PyModuleDef_HEAD_INIT,    &quot;builtins&quot;,    builtin_doc,    -1, /* multiple &quot;initialization&quot; just copies the module dict. */    builtin_methods,    NULL,NULL,NULL,NULL};static PyMethodDef builtin_methods[] = {    {&quot;__build_class__&quot;, (PyCFunction)builtin___build_class__,    METH_VARARGS | METH_KEYWORDS, build_class_doc},    {&quot;__import__&quot;,      (PyCFunction)builtin___import__, METH_VARARGS | METH_KEYWORDS, import_doc},    BUILTIN_ABS_METHODDEF    BUILTIN_ALL_METHODDEF    ......    {&quot;print&quot;,           (PyCFunction)builtin_print,      METH_VARARGS | METH_KEYWORDS, print_doc},    {NULL,              NULL},};</code></pre><p>在<code>builtinsmodule</code>结构体中定义了<code>builtins</code>模块名，另外和模块定义相似，对于函数，Python也有类似的结构<code>PyMethodDef</code>，而<code>builtin_methods</code>结构体数组就维护了一大堆的函数名称到函数指针的映射。</p><p>现在弄懂了<code>PyModuleObject</code>和<code>PyModuleDef</code>后，我们再回到函数<code>PyModule_Create2</code>中，真正的创建模块对象的函数是<code>PyModule_New</code>：</p><pre><code class="c">PyObject *PyModule_NewObject(PyObject *name){    PyModuleObject *m;    m = PyObject_GC_New(PyModuleObject, &amp;PyModule_Type); /* 分配内存 */    m-&gt;md_def = NULL;    m-&gt;md_state = NULL;    m-&gt;md_weaklist = NULL;    m-&gt;md_name = NULL;    m-&gt;md_dict = PyDict_New(); /* 初始化各个域 */    if (module_init_dict(m, m-&gt;md_dict, name, NULL) != 0) /* 填充dict */        goto fail;    return (PyObject *)m;}static intmodule_init_dict(PyModuleObject *mod, PyObject *md_dict,                 PyObject *name, PyObject *doc){    _Py_IDENTIFIER(__name__);    _Py_IDENTIFIER(__doc__);    ......    if (md_dict == NULL)        return -1;    if (doc == NULL)        doc = Py_None;    if (_PyDict_SetItemId(md_dict, &amp;PyId___name__, name) != 0)        return -1;    if (_PyDict_SetItemId(md_dict, &amp;PyId___doc__, doc) != 0)        return -1;    ......    return 0;}</code></pre><p>在上面的函数中，我们通过<code>PyObject_GC_New</code>为模块对象分配内存后，就对各个域进行了初始化，其中<code>md_dict</code>是一个字典，在创建一个模块对象后，虚拟机会通过<code>module_init_dict</code>，在其中填充模块的<code>__name__</code>和<code>__doc__</code>等属性。</p><p>到现在模块对象有了，而且<code>md_dict</code>域中也有了名称和注释，但虚拟机还需要进一步的设置，模块才能正常工作。依旧是<code>PyModule_Create2</code>函数中，虚拟机会根据模块对象的<code>m_methods</code>域设置模块函数。</p><pre><code class="c">intPyModule_AddFunctions(PyObject *m, PyMethodDef *functions){    int res;    PyObject *name = PyModule_GetNameObject(m);    res = _add_methods_to_object(m, name, functions); /* 添加模块函数 */    return res;}static int_add_methods_to_object(PyObject *module, PyObject *name, PyMethodDef *functions){    PyObject *func;    PyMethodDef *fdef;    for (fdef = functions; fdef-&gt;ml_name != NULL; fdef++) {        if ((fdef-&gt;ml_flags &amp; METH_CLASS) ||            (fdef-&gt;ml_flags &amp; METH_STATIC)) { /* 类方法和静态方法不做处理 */            return -1;        }        func = PyCFunction_NewEx(fdef, (PyObject*)module, name); /* 创建函数对象 */        if (PyObject_SetAttrString(module, fdef-&gt;ml_name, func) != 0) { /* 设置属性 */            return -1;        }    }    return 0;}</code></pre><p>针对每个<code>PyMethodDef</code>结构，Python都会创建一个对应的<code>PyCFunctionObject</code>对象(这里面也用到了“缓冲池”机制)，这个对象就是一个函数指针的包装。这些创建的函数对象以属性的方式绑定在模块对象上面。</p><p>最后进程对象的<code>builtins</code>指针也指向了<code>builtins</code>模块的<code>md_dict</code>域。</p><p>和<code>builtins</code>模块相似，<code>sys</code>模块也是这样创建并被设置的。</p><h3 id="sys-模块"><a href="#sys-模块" class="headerlink" title="sys 模块"></a>sys 模块</h3><pre><code class="c">sysmod = _PySys_Init();  /* 创建并初始化sys模块 */interp-&gt;sysdict = PyModule_GetDict(sysmod);_PyImport_FixupBuiltin(sysmod, &quot;sys&quot;);  /* 备份sys模块 */PyDict_SetItemString(interp-&gt;sysdict, &quot;modules&quot;, interp-&gt;modules);</code></pre><p>创建的<code>sys</code>模块对象中主要加入了一些Python的版本信息和操作系统相关的信息，例如<code>version</code>、<code>platform</code>、<code>maxsize</code>和<code>byteorder</code>等。</p><h3 id="模块备份"><a href="#模块备份" class="headerlink" title="模块备份"></a>模块备份</h3><p>在<code>builtins</code>和<code>sys</code>创建完后，都会有一个函数<code>_PyImport_FixupBuiltin();</code>，这个函数是用来备份的。</p><p>因为<code>interp-&gt;modules</code>维护的是一个字典，属于可变对象，所以其中的<code>&lt;模块名，模块对象&gt;</code>很容易被删除。Python为了避免在元素删除时再次初始化模块，会将所有的扩展module通过一个全局的字典对象来进行备份维护，其调用的是<code>_PyImport_FixupExtensionObject</code>函数：</p><pre><code class="c">static PyObject *extensions = NULL; /* 一个全局的字典对象 */int_PyImport_FixupBuiltin(PyObject *mod, const char *name){    int res;    PyObject *nameobj;    nameobj = PyUnicode_InternFromString(name);    res = _PyImport_FixupExtensionObject(mod, nameobj, nameobj);    return res;}int_PyImport_FixupExtensionObject(PyObject *mod, PyObject *name,                               PyObject *filename){    PyObject *modules, *dict, *key;    struct PyModuleDef *def;    int res;    if (extensions == NULL) {        extensions = PyDict_New(); /* 如果没有创建，则创建字典*/    }    def = PyModule_GetDef(mod); /* 抽取module中的PyModuleDef */    modules = PyImport_GetModuleDict(); /* 获取interp-&gt;modules */    if (PyDict_SetItem(modules, name, mod) &lt; 0)        return -1;    if (_PyState_AddModule(mod, def) &lt; 0) {        PyDict_DelItem(modules, name);        return -1;    }    if (def-&gt;m_size == -1) {        if (def-&gt;m_base.m_copy) {            /* Somebody already imported the module,               likely under a different name.               XXX this should really not happen. */            Py_CLEAR(def-&gt;m_base.m_copy);        }        dict = PyModule_GetDict(mod); /* 抽取md_dict */        def-&gt;m_base.m_copy = PyDict_Copy(dict); /* 复制dict */    }    key = PyTuple_Pack(2, filename, name); /* 把名称打包作为键 */    res = PyDict_SetItem(extensions, key, (PyObject *)def); //    return 0;}</code></pre><p>当Python中<code>interp-&gt;modules</code>集合中某个扩展被删除后又被重新加载时, 就不需要再次为其初始化了。只需要用<code>extensions</code>中备份的<code>PyModuleDef</code>来创建一个新的<code>module</code>对象即可。</p><h3 id="设置模块搜索路径"><a href="#设置模块搜索路径" class="headerlink" title="设置模块搜索路径"></a>设置模块搜索路径</h3><p>当我们在Python中尝试导入模块时，就涉及到了一个叫”模块搜索路径“的概念，在虚拟机启动是通过下面的函数进行设置的：</p><pre><code class="c">......PySys_SetPath(Py_GetPath());</code></pre><p>下面是<code>PySys_SetPath</code>的实现：</p><pre><code class="c">voidPySys_SetPath(const wchar_t *path){    PyObject *v;    if ((v = makepathobject(path, DELIM)) == NULL) /* 创建路径对象 */        Py_FatalError(&quot;can&#39;t create sys.path&quot;);    if (_PySys_SetObjectId(&amp;PyId_path, v) != 0) /* 设置路径对象到sysdict中 */        Py_FatalError(&quot;can&#39;t assign sys.path&quot;);}int_PySys_SetObjectId(_Py_Identifier *key, PyObject *v){    PyThreadState *tstate = PyThreadState_GET();    PyObject *sd = tstate-&gt;interp-&gt;sysdict;    return _PyDict_SetItemId(sd, key, v);}</code></pre><p>这里省略了路径的查找和路径对象的构建过程，在设置路径的过程中，Python将通过<code>makepathobject</code>构建的路径对象(一个列表)设置到了<code>interp-&gt;sysdict</code>中，而这个指针恰恰指向<code>sys</code>模块的<code>md_dict</code>域，所以我们在Python中敲入<code>sys.path</code>能够获得那个路径集合。</p><p>在设置好搜索路径之后，虚拟机还进行了许多琐碎的初始化工作，例如：<code>import</code>机制初始化，异常环境初始化，输出环境和编码器等等。</p><h3 id="main模块"><a href="#main模块" class="headerlink" title="main模块"></a>main模块</h3><p>另外，除了上面的<code>builtins</code>模块和<code>sys</code>模块外，虚拟机还有创建了一个特殊的模块：<code>__main__</code>模块。</p><pre><code class="c">static voidinitmain(PyInterpreterState *interp){    PyObject *m, *d, *loader, *ann_dict;    m = PyImport_AddModule(&quot;__main__&quot;); /* 创建名为__main__的模块 */    d = PyModule_GetDict(m); /* 抽取md_dict*/    if (PyDict_GetItemString(d, &quot;__builtins__&quot;) == NULL) {        PyObject *bimod = PyImport_ImportModule(&quot;builtins&quot;);        PyDict_SetItemString(d, &quot;__builtins__&quot;, bimod） /* 将__builtins__模块插入到dict中 */    }}</code></pre><p>在<code>initmain</code>中，虚拟机先是创建了一个名为<code>__mian__</code>的模块，并将<code>__builtins__</code>添加到了该模块的<code>md_dict</code>中了。</p><p>在Python中，我们经常写<code>if __name__ == __main__</code>和这又有什么关系呢？</p><p>实际上，在以<code>python *.py</code>这种方式执行Python文件时，Python会沿着命名空间查找<code>__name__</code>，最后它会在<code>__main__</code>模块中，找到<code>__name__</code>对应的值是<code>__main__</code>。不过奇怪的是为什么会找到<code>__main__</code>模块的命名空间呢，不是还有<code>__builtin__</code>模块吗？这一点在下面的“命名空间”一节中有讲到。</p><h3 id="site-packages"><a href="#site-packages" class="headerlink" title="site-packages"></a>site-packages</h3><p>这是一个特殊的目录，我们的安装的第三方库一般都放置在这个目录里，所以也就要求这个路径需要添加到Python的”搜索路径“中去。</p><pre><code class="c"> if (!Py_NoSiteFlag)    initsite(); /* Module site */</code></pre><p>下面是它的实现：</p><pre><code class="c">static voidinitsite(void){    PyObject *m;    m = PyImport_ImportModule(&quot;site&quot;);}</code></pre><p>这里设计到了Python的<code>import</code>机制，这里先跳过不讲，只需要知道<code>PyImport_ImportModule</code>会导入一个叫<code>site</code>的模块，这个模块位于<code>%PythonHome%\Lib\site.py</code>。</p><p>在<code>site</code>模块中，Python做的事情就是：</p><ul><li>将<code>site-packages</code>路径加入到<code>sys.path</code>中</li><li>另一个就是处理<code>site-packages</code>目录下的所有<code>.pth</code>文件中的所有路径添加到<code>sys.path</code>中</li></ul><p>到现在为止，Python中绝大部分的初始化动作都已经完毕，下面是初始化后的内存分布情况：</p><h2 id="激活虚拟机"><a href="#激活虚拟机" class="headerlink" title="激活虚拟机"></a>激活虚拟机</h2><p>Python有两种运行方式，一是命令行下的交互环境；二是以脚本执行的方式。这两种方式都会在<code>Py_Initialize</code>之后调用<code>PyRun_AnyFileFlags</code>。</p><pre><code class="c">[Modules/main.c]intPy_Main(int argc, wchar_t **argv){    Py_Initialize(); /* 初始化 */    ......    run = PyRun_AnyFileExFlags(fp, filename_str, filename != NULL, p_cf);    ......}</code></pre><p>如果是以脚本方式执行，那么<code>fp</code>就是脚本文件，<code>filename_str</code>就是文件名，而<code>p_cf</code>是Python的编译参数；<br><br>如果是以交互式环境下执行，那么<code>fp</code>就是<code>stdin</code>输入流，而<code>filename_str</code>就是<code>&lt;stdin&gt;</code>。</p><p>最后在函数<code>PyRun_AnyFileExFlags</code>中会对两种方式进行分流：</p><pre><code class="c">intPyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit,                     PyCompilerFlags *flags){    if (filename == NULL)        filename = &quot;???&quot;;    /* 判断，分流 */    if (Py_FdIsInteractive(fp, filename)) {        int err = PyRun_InteractiveLoopFlags(fp, filename, flags);        if (closeit)            fclose(fp);        return err;    }    else        return PyRun_SimpleFileExFlags(fp, filename, closeit, flags);}</code></pre><p>Python使用<code>Py_FdIsInteractive</code>判断输入是否是标准输入流，如果是，则代表着交互式运行环境，那么进入<code>PyRun_InteractiveLoopFlags</code>，否则使用<code>PyRun_SimpleFileExFlags</code>进行执行处理。</p><h3 id="交互式环境"><a href="#交互式环境" class="headerlink" title="交互式环境"></a>交互式环境</h3><pre><code class="c">intPyRun_InteractiveLoopFlags(FILE *fp, const char *filename_str, PyCompilerFlags *flags){    PyObject *filename, *v;    int ret, err;    PyCompilerFlags local_flags;    int nomem_count = 0;    filename = PyUnicode_DecodeFSDefault(filename_str); /* 文件名 */    ......    /* 创建交互式提示符“&gt;&gt;&gt; ” */    v = _PySys_GetObjectId(&amp;PyId_ps1);    if (v == NULL) {        _PySys_SetObjectId(&amp;PyId_ps1, v = PyUnicode_FromString(&quot;&gt;&gt;&gt; &quot;));    }    /* 创建交互式提示符“... ” */    v = _PySys_GetObjectId(&amp;PyId_ps2);    if (v == NULL) {        _PySys_SetObjectId(&amp;PyId_ps2, v = PyUnicode_FromString(&quot;... &quot;));    }    err = 0;    do {/* 进入交互式环境 */        ret = PyRun_InteractiveOneObjectEx(fp, filename, flags);        ......    } while (ret != E_EOF);    return err;}</code></pre><p>如果是在交互式运行环境下，虚拟机会在一个<code>loop</code>中循环执行。下面是<code>PyRun_InteractiveOneObjectEx</code>函数：</p><pre><code class="c">static intPyRun_InteractiveOneObjectEx(FILE *fp, PyObject *filename,                             PyCompilerFlags *flags){    PyObject *m, *d, *v, *w, *oenc = NULL, *mod_name;    mod_ty mod;    PyArena *arena;    char *ps1 = &quot;&quot;, *ps2 = &quot;&quot;, *enc = NULL;    int errcode = 0;    _Py_IDENTIFIER(__main__);    mod_name = _PyUnicode_FromId(&amp;PyId___main__); /* borrowed */    ......    v = _PySys_GetObjectId(&amp;PyId_ps1);    if (v != NULL) {        v = PyObject_Str(v);        ps1 = PyUnicode_AsUTF8(v);    }    w = _PySys_GetObjectId(&amp;PyId_ps2);    if (w != NULL) {        w = PyObject_Str(w);        ps2 = PyUnicode_AsUTF8(w);    }    arena = PyArena_New();    mod = PyParser_ASTFromFileObject(fp, filename, enc,                                     Py_single_input, ps1, ps2,                                     flags, &amp;errcode, arena); /* 构造抽象语法树AST */    m = PyImport_AddModuleObject(mod_name); /* 导入__main__模块 */    d = PyModule_GetDict(m); /* 抽取main模块的md_dict */    v = run_mod(mod, filename, d, d, flags, arena); /* 执行用户输入的Python语句 */    PyArena_Free(arena);    flush_io();    return 0;}</code></pre><p>在<code>PyRun_InteractiveOneObjectEx</code>中调用<code>PyParser_ASTFromFileObject</code>对交互式环境下的用户输入Python语句进行编译， 其结果是结构与Python语句一样的抽象语法树<code>AST</code>。调用<code>run_mod</code>将最终完成对输入语句的执行。这里的参数<code>d</code>就将作为当前活动的<code>frame</code>对象的<code>locals</code>名字空间和<code>globals</code>名字空间。</p><h3 id="脚本方式执行"><a href="#脚本方式执行" class="headerlink" title="脚本方式执行"></a>脚本方式执行</h3><pre><code class="c">intPyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit,                        PyCompilerFlags *flags){    PyObject *m, *d, *v;    const char *ext;    int set_file_name = 0, ret = -1;    size_t len;    m = PyImport_AddModule(&quot;__main__&quot;); /* 导入main模块 */    d = PyModule_GetDict(m);    if (PyDict_GetItemString(d, &quot;__file__&quot;) == NULL) { ./* 设置”__file__“属性 */        PyObject *f;        f = PyUnicode_DecodeFSDefault(filename);        yDict_SetItemString(d, &quot;__file__&quot;, f)        set_file_name = 1;    }    len = strlen(filename);    ext = filename + len - (len &gt; 4 ? 4 : 0);    if (maybe_pyc_file(fp, filename, ext, closeit)) { /* 尝试从pyc文件执行 */        ......        v = run_pyc_file(pyc_fp, filename, d, d, flags);        fclose(pyc_fp);    } else { /* 如果是py文件 */        ......        v = PyRun_FileExFlags(fp, filename, Py_file_input, d, d,                              closeit, flags);    }    ......}PyObject *PyRun_FileExFlags(FILE *fp, const char *filename_str, int start, PyObject *globals,                  PyObject *locals, int closeit, PyCompilerFlags *flags){    PyObject *ret = NULL;    mod_ty mod;    PyArena *arena = NULL;    PyObject *filename;    filename = PyUnicode_DecodeFSDefault(filename_str);    mod = PyParser_ASTFromFileObject(fp, filename, NULL, start, 0, 0, /* 构造抽象语法树AST */                                     flags, NULL, arena);     ret = run_mod(mod, filename, globals, locals, flags, arena); /* 执行 */}</code></pre><p>以脚本的方式和交互式运行环境相似，输入都会经过编译后，传入<code>run_mod</code>执行，将<code>main</code>模块的<code>md_dict</code>作为<code>locals</code>命名空间和<code>globals</code>命名空间传入。</p><h3 id="run-mod"><a href="#run-mod" class="headerlink" title="run_mod"></a>run_mod</h3><pre><code class="c">static PyObject *run_mod(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,            PyCompilerFlags *flags, PyArena *arena){    PyCodeObject *co;    PyObject *v;    co = PyAST_CompileObject(mod, filename, flags, -1, arena); /* 编译 */    v = PyEval_EvalCode((PyObject*)co, globals, locals); /* 执行 */    return v;}</code></pre><p>从<code>run_mod</code>开始，虚拟机会通过传入的抽象语法树<code>AST</code>编译字节码指令序列，创建<code>PyCodeObject</code>，最后调用<code>PyEval_EvalCode</code>创建新的栈桢执行字节码对象。又回到了熟悉的地方。。。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>虚拟机在执行字节码的过程中，创建了<code>PyFrameObject</code>设置了三个命名空间：<code>locals</code>，<code>globals</code>和<code>builtins</code>。</p><pre><code class="c">PyFrameObject *PyFrame_New(PyThreadState *tstate, PyCodeObject *code, PyObject *globals,            PyObject *locals){    PyFrameObject *back = tstate-&gt;frame;    PyFrameObject *f;    PyObject *builtins;    Py_ssize_t i;    /* builtins命名空间 */    if (back == NULL || back-&gt;f_globals != globals) {/* 尝试从main模块的dict中获取__builtin__模块 */        builtins = _PyDict_GetItemId(globals, &amp;PyId___builtins__);         builtins = PyModule_GetDict(builtins); /* builtins命名空间就是builtin模块的md_dict */        }    }    else {        builtins = back-&gt;f_builtins; /* 继承上一个栈桢的builtis命名空间 */    }    f-&gt;f_builtins = builtins;     f-&gt;f_back = back;    /* globals命名空间 */    f-&gt;f_globals = globals;    /* locals命名空间 */    if ((code-&gt;co_flags &amp; (CO_NEWLOCALS | CO_OPTIMIZED)) ==        (CO_NEWLOCALS | CO_OPTIMIZED))        ; /* f_locals = NULL; 函数调用，不需要locals命名空间 */    else if (code-&gt;co_flags &amp; CO_NEWLOCALS) {        locals = PyDict_New();        f-&gt;f_locals = locals;    }    else {        if (locals == NULL)            locals = globals; /* 一般情况，locals和globals指向同一dict */        f-&gt;f_locals = locals;    }    return f;}</code></pre><p>以主模块的方式运行的化，虚拟机传入的<code>locals</code>和<code>globals</code>命名空间都是<code>main</code>模块的<code>md_dict</code>，所以<code>__name__</code>直接就会在<code>locals</code>命名空间找到，不会命中<code>builtins</code>命名空间。</p><p>在新创建的栈桢对象，它的builtins命名空间就是<code>__builtin__</code>模块的<code>md_dict</code>，所以我们能够直接在Python中使用这些内置的对象。同时也意味着：Python的所有线程共享同样的builtin名字空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面已经接触了许多执行引擎相关的工作，然而关于Python虚拟机还有一大块的是我们没有了解的，那就是运行时环境的初始化。&lt;/p&gt;
&lt;p&gt;Python3启动后真正有意义的初始化动作是从&lt;code&gt;Py_Initialize&lt;/code&gt;(位于&lt;code&gt;pylifecycle.c&lt;/code&gt;文件)开始的，其内部调用的就是&lt;code&gt;_Py_InitializeEx_Private&lt;/code&gt;函数，本节的主要内容就是以这个函数为入口，深入理解Python虚拟机的启动流程。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python源码阅读-内存管理机制</title>
    <link href="http://shawnz.me/posts/89298142/"/>
    <id>http://shawnz.me/posts/89298142/</id>
    <published>2018-01-11T12:41:10.000Z</published>
    <updated>2018-03-10T06:20:54.150Z</updated>
    
    <content type="html"><![CDATA[<p>终于来到了最后一部分: 内存管理.</p><a id="more"></a><h2 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h2><p>在Python中, 当要分配内存时, 不单纯要用<code>malloc/free</code>, 而是在其基础上堆放三个独立的分层, 有效地进行分配.</p><div style="width: 70%"><img src="/images/pymemobject-1.jpg" alt=""></div><p>第<code>0</code>层往下是<code>OS</code>的功能, 我们要讲的内存管理不涉及这一部分.</p><p>第<code>0</code>层是操作系统的内存管理接口, 比如<code>C</code>运行时提供的<code>mallocl</code>和<code>free</code>接口, Python并不干涉这一层的行为.</p><p>第<code>1</code>层是基于第<code>0</code>层操作系统的内存管接口包装而成的, 这一层主要是为Python提供统一的<code>raw memory</code>管理接口, 处理平台相关的内存分配. 在Python中, 第<code>1</code>的实现是一组<code>PyMem_</code>为前缀的函数族.</p><pre><code class="c">[obmalloc.c]/* 函数接口 */static void * _PyMem_RawMalloc(void *ctx, size_t size){    if (size == 0)        size = 1;    return malloc(size);}......static void *_PyMem_RawRealloc(void *ctx, void *ptr, size_t size){    if (size == 0)        size = 1;    return realloc(ptr, size);}static void_PyMem_RawFree(void *ctx, void *ptr) { free(ptr); }/* 宏定义 */[pymem.h]#define PyMem_MALLOC(n)         PyMem_Malloc(n)#define PyMem_REALLOC(p, n)     PyMem_Realloc(p, n)#define PyMem_FREE(p)           PyMem_Free(p)</code></pre><p>可以看到Python只是对C中<code>malloc/realloc/free</code>等进行了一次包装. 不过由于不同操作系统针对<code>malloc(0)</code>表现不同, 有的会返回<code>NULL</code>, 有的会返回一个没有指向内存的空指针, 所以Python不允许申请大小为<code>0</code>的内存空间, 将会强制转换成申请大小为<code>1</code>字节的内存空间.</p><p>Python同时提供了函数和宏两套接口, 使用宏可以提高运行效率, 不过在编写<code>C</code>扩展模块的时候, 建议使用函数接口.</p><p>其实在第<code>1</code>层, Python还提供了面向Python中类型的内存分配接口:</p><pre><code class="c">#define PyMem_New(type, n) \  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :    \    ( (type *) PyMem_Malloc((n) * sizeof(type)) ) )#define PyMem_NEW(type, n) \  ( ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :    \    ( (type *) PyMem_MALLOC((n) * sizeof(type)) ) )#define PyMem_Resize(p, type, n) \  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :    \    (type *) PyMem_Realloc((p), (n) * sizeof(type)) )#define PyMem_RESIZE(p, type, n) \  ( (p) = ((size_t)(n) &gt; PY_SSIZE_T_MAX / sizeof(type)) ? NULL :    \    (type *) PyMem_REALLOC((p), (n) * sizeof(type)) )</code></pre><p>第<code>1</code>层只是进行内存分配的工作, 然而对于内存分配还有许多额外工作, 例如: 计数引用和<code>GC</code>, 都将在第<code>2</code>层内存管理机制中. 这一层, 是一组以<code>PyObject_</code>为前缀的函数族, 主要作为Python的对象分配器, 这些函数族又被唤作<code>Pymalloc</code>机制.</p><p>而第<code>3</code>层, 则是对于Python中的常用对象, 例如: 整数对象, 字符串对象等, 提供了更高层次的内存管理策略, 主要就是缓冲池技术, 这一部分的具体分析我们在Python的内置对象时有讲过.</p><h2 id="第1层低级内存分配器"><a href="#第1层低级内存分配器" class="headerlink" title="第1层低级内存分配器"></a>第1层低级内存分配器</h2><p>先看一个简单的例子:</p><pre><code class="python">for x in range(100):    print(x)</code></pre><p>在上述脚本中, Python会把从0-99的整数对象转换成字符串对象输出, 这一过程会使用大量的一次性字符串.</p><p>所以为了避免频繁的调用<code>malloc/free</code>, Python引入了一个”内存池机制”, 用于管理小块内存的申请和释放.</p><p>第<code>1</code>层锁管理的内存空间结构可以分为3个层次: <code>arean -&gt; pool -&gt; block</code>, 最小单位是<code>block</code>, 返回给用户的也是<code>block</code>.</p><p><img src="/images/pymemobject-2.png" alt=""></p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>在底层, <code>block</code>是一个确定大小的内存块, Python中, 不同种类的<code>block</code>都有不同的大小, 这个内存大小称为<code>size class</code>. 所有的<code>block</code>块都是8字节对齐的.</p><pre><code class="c">#define ALIGNMENT               8               /* block对齐, must be 2^N */#define ALIGNMENT_SHIFT         3#define SMALL_REQUEST_THRESHOLD 512  /* block上限 */#define NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</code></pre><p>同时, Python为<code>block</code>的大小设定了一个上限, 当申请的内存小于这个上限时, Python就可以使用不同的<code>block</code>满足对内存的要求; 当申请超过这个上限的时候, Python将内存申请的请求转交给第<code>1</code>层的内存分配机制, 即<code>PyMem_</code>函数族.</p><p>根据<code>SMALL_REQUEST_THRESHOLD</code>和<code>ALIGNMENT</code>, 可以得到不同种类的<code>block</code>的<code>size class</code>分别为: 8, 16, 32, …, 512. 每个<code>size class</code>对应一个<code>size class index</code>, 这个<code>index</code>从0开始. 所以对于小于<code>512</code>字节的内存分配, 我们可以得到如下结论:</p><table><thead><tr><th>Request in bytes</th><th>Size of allocated block</th><th>Size class idx</th></tr></thead><tbody><tr><td>1~8</td><td>8</td><td>0</td></tr><tr><td>9~16</td><td>16</td><td>1</td></tr><tr><td>17~24</td><td>24</td><td>2</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>505~512</td><td>512</td><td>63</td></tr></tbody></table><p>也就是说, 当我们申请内存大小为28字节的内存时, 实际上<code>PyObject_Malloc</code>会从内存池中划分一个32字节的<code>block</code>, 这个<code>block</code>将从<code>size class index</code>为3的<code>pool</code>中划出. 下面是<code>size class</code>和<code>size class index</code>之间的相互转换公式:</p><pre><code class="c">/* 从size class index 转换成 size class */#define INDEX2SIZE(I) (((uint)(I) + 1) &lt;&lt; ALIGNMENT_SHIFT)/* 从size class 转换成 size class index*/size = (uint)(nbytes - 1) &gt;&gt; ALIGNMENT_SHIFT;</code></pre><p>不过这里我们说的<code>block</code>并不是一个实际存在的对象, 它只是一个概念, 在Python中, 有一个实体来管理<code>block</code>, 那就是<code>pool</code>.</p><h3 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h3><p>一组<code>block</code>的集合称为<code>pool</code>, 换句话说, 一个<code>pool</code>管理着一堆固定大小的<code>block</code>.</p><p>在Python中, <code>pool</code>的大小通常是一个系统内存页, 一个<code>pool</code>的大小定义为4KB.</p><pre><code class="c">#define SYSTEM_PAGE_SIZE        (4 * 1024)#define SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)#define POOL_SIZE               SYSTEM_PAGE_SIZE        /* must be 2^N */#define POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK</code></pre><p>另外, <code>pool</code>有对应的实体存在:</p><pre><code class="c">typedef uint8_t block;/* Pool for small blocks. */struct pool_header {    union { block *_padding;            uint count; } ref;          /* 分配到pool里的block的数量 */    block *freeblock;                   /* block空闲链表的开头 */    struct pool_header *nextpool;       /* 指向下一个pool(双链表) */    struct pool_header *prevpool;       /* 指向上一个pool(双链表)　*/    uint arenaindex;                    /* 自己所属的arena的索引 */    uint szidx;                         /* 分配的block大小 */    uint nextoffset;                    /* 到下一个block的偏移量 */    uint maxnextoffset;                 /* 到能分配下一个block之前偏移 */};typedef struct pool_header *poolp;</code></pre><p>一个<code>pool</code>内分配的<code>block</code>大小是固定的, 通过<code>szidx</code>可以找到对应的<code>pool</code>.</p><p>假设现在有一个4KB的内存, 来看看Python是怎么将它改造成一个管理32字节<code>block</code>的<code>pool</code>, 并返回一个第一个<code>block</code>:</p><pre><code class="c">[obmalloc.c convert 4k raw memory to pool]typedef struct pool_header *poolp;#define POOL_OVERHEAD   _Py_SIZE_ROUND_UP(sizeof(struct pool_header), ALIGNMENT)block *bp;poolp pool;...... /* pool 指向一块4KB内存 */pool-&gt;ref.count = 1;pool-&gt;szidx = size;  /* 设置pool的size class index */size = INDEX2SIZE(size); /* 转换成size class, 比如3转化为32字节 */bp = (block *)pool + POOL_OVERHEAD; /* 跳过用于pool_head的内存， 并进行地址对齐 *//* 实际就是pool-&gt;nextoffset = POOL_OVERHEAD + size + size */pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; 1); /* 到下一个block的偏移 */pool-&gt;maxnextoffset = POOL_SIZE - size; /* 到能分配下一个block之前的偏移 */pool-&gt;freeblock = bp + size;  /* block的空闲链表开头 */*(block **)(pool-&gt;freeblock) = NULL; /* *freeblock为NULL */return (void *)bp;</code></pre><p>最后返回的<code>bp</code>就是从<code>pool</code>取出的第一块<code>block</code>的地址, 也就是说第一个<code>block</code>已经被分配了. 所以当前已分配的<code>block</code>数量为<code>1</code>, <code>freeblock=bp+size</code>, 下一个空闲<code>block</code>的偏移为<code>POOL_OVERHEAD + size + size</code>, 空闲链表的指向<code>bp+size</code>.</p><p>对于应用程序来说, 尽管<code>bp</code>后面还有将近4k的内存可用, 但是可以肯定的是申请内存的函数只会使用<code>[bp, bp+size]</code>这个区间的内存. 被改造后的4KB内存情况如下:</p><p><img src="/images/pymemobject-3.png" alt=""></p><p>现在假设, 我们需要再申请5块28字节的内存, 由于28字节对应的<code>size class index</code>为<code>3</code>, 所以实际会在刚创建的<code>pool</code>上申请5块32字节的内存.</p><pre><code class="c">[onmalloc.c _PyObject_Alloc] if (pool != pool-&gt;nextpool) {    ++pool-&gt;ref.count;    bp = pool-&gt;freeblock; /* 下一个空闲block */    ......    if (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) { /* 下一次分配还有足够的空间 */        pool-&gt;freeblock = (block*)pool + pool-&gt;nextoffset;        pool-&gt;nextoffset += INDEX2SIZE(size);        *(block **)(pool-&gt;freeblock) = NULL;        return (void *)bp;    }    /* pool已满, 从used_pool中移除 */    next = pool-&gt;nextpool;    pool = pool-&gt;prevpool;    next-&gt;prevpool = pool;    pool-&gt;nextpool = next;    return (void *)bp;}</code></pre><p>可以看到, <code>_PyObject_Alloc</code>申请<code>block</code>的过程是依赖于三个变量: </p><ul><li><code>freeblock</code>: 指向下一个空闲的<code>block</code>地址;</li><li><code>nextoffset</code>和<code>maxnextoffset</code>: 控制着迭代申请<code>block</code>块后, 可用<code>block</code>的偏移量. 当<code>nextoffset &gt; maxnextoffset</code>时, <code>pool</code>在分配完这一次<code>block</code>结束后就已经满了, 需要从<code>used_pools</code>中移除.</li></ul><p>继续假设, 如果我们需要返回第2个<code>block</code>的内存, 来看看Python是怎么释放<code>block</code>的:</p><pre><code class="c">static void_PyObject_Free(void *ctx, void *p){    poolp pool;    block *lastfree;    poolp next, prev;    uint size;    pool = POOL_ADDR(p); /* pool_head */    if (address_in_range(p, pool)) { /* 检查p指向的block是否属于pool  */        *(block **)p = lastfree = pool-&gt;freeblock; /* [1] */        pool-&gt;freeblock = (block *)p;  /* [2] */        ......    }}</code></pre><p>在释放第2块<code>block</code>的时候, 为了更充分的利用<code>pool</code>的内存空间, Python通过设置<code>freeblock</code>指针构造了一个空闲<code>block</code>的离散链表:</p><ul><li>在上面申请<code>block</code>的过程中, 我们知道申请<code>block</code>后, <code>*freeblock</code>为<code>NULL</code>;</li><li>经过[1]后, 先是将指针<code>freeblock</code>的指向的地址, 保存在我们要释放掉的那个<code>block</code>里;</li><li>经过[2]后, 更新当前<code>freeblock</code>指针, 指向我们释放掉的<code>block</code>地址.</li></ul><p>经过这两步, 这时<code>pool</code>的内存使用情况应该如下:</p><p><img src="/images/pymemobject-4.png" alt=""></p><p>既然构造了空闲<code>block</code>的离散链表, 那么在申请<code>block</code>块的时候, 应该优先尝试使用这条离散链表, 当<code>*freeblock==NULL</code>的时候, 可以知道已经不存在这条离散链表了:</p><pre><code class="c">[obmalloc.c _PyObject_Alloc]if (pool != pool-&gt;nextpool) {    ++pool-&gt;ref.count;    bp = pool-&gt;freeblock;    if ((pool-&gt;freeblock = *(block **)bp) != NULL) { /* 优先尝试空闲block链表 */        return (void *)bp;    }    if (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) {        ......    }}    </code></pre><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>多个<code>pool</code>的聚合就是<code>arena</code>. <code>pool</code>的默认大小为<code>4KB</code>, 而<code>arena</code>的默认大小为<code>256KB</code>:</p><pre><code class="c">[obmalloc.c]#define ARENA_SIZE              (256 &lt;&lt; 10)     /* 256KB */</code></pre><p>我们来看看<code>arena</code>的定义:</p><pre><code class="c">[obmalloc.c]struct arena_object {    uintptr_t address; /* malloc后的arena地址 */    block* pool_address; /* 将arena的地址用于给pool使用而对齐的地址 */    uint nfreepools; /* 空闲pool数量 */    uint ntotalpools; /* pool总数 */    struct pool_header* freepools;  /* 连接空闲pool的单链表 */    struct arena_object* nextarena;     struct arena_object* prevarena;};</code></pre><p><code>arena_object</code>结构体中有个域<code>pool_address</code>, 它指向了<code>arena</code>内的开头<code>pool</code>地址. 这里我们说<code>arena</code>的地址和<code>arena</code>内开头的<code>pool</code>地址不同, 是因为<code>pool</code>的开头地址需要按照<code>4K</code>对齐.</p><p>另外还有两个域<code>nextarena</code>和<code>prevarena</code>, 这里需要注意的是, <code>arena_object</code>是被一个<code>arenas</code>数组管理的, 这就是Python通用的内存池.</p><pre><code class="c">[obmalloc.c]static struct arena_object* arenas = NULL;     /* arenes管理着 arena_object的集合 */static uint maxarenas = 0;  /* arenas中的元素数量 */</code></pre><p>既然不是链表, 那么<code>nextarena</code>和<code>prevarena</code>是做什么用的呢?</p><p>这得从<code>arena</code>的内存布局来讲, 我们知道<code>pool</code>在创建的时候, 意味着<code>pool</code>里的<code>block</code>也跟着分配了内存, 然而<code>arena</code>不是这样的, 当<code>arena</code>被创建时, 其内管理的<code>pool</code>可能还没有被创建.</p><p>所以我们将<code>arena</code>分为两种状态: “未使用”状态和”可用”状态. 当一个<code>arena_object</code>没有和<code>pool</code>集合建立联系的时候, 我们称它为”未使用”; 一旦建立联系, <code>arena</code>就变为了”可用”状态.</p><p>对于两种状态, 分别有两个链表管理着: <code>unused_arena_objects</code>和<code>usable_arenas</code>, 这些<code>arena_object</code>之间正是通过上面那两个指针连接.</p><pre><code class="c">static struct arena_object* unused_arena_objects = NULL; /* 单链表 */static struct arena_object* usable_arenas = NULL; /* 双链表 */</code></pre><p>下图展示了某一时刻多个<code>arena</code>可能的状态:</p><p><img src="/images/pymemobject-6.png" alt=""></p><p>接下来, 是<code>arena</code>的创建过程:</p><pre><code class="c">static struct arena_object*new_arena(void){    struct arena_object* arenaobj;    uint excess;        /* number of bytes above pool alignment */    void *address;    static int debug_stats = -1;    if (unused_arena_objects == NULL) { /* 判断是否需要扩充unused_arena_objects链表 */        uint i;        uint numarenas;        size_t nbytes;        /* 确定本次需要申请的arena_objects 数量, 并申请内存*/        numarenas = maxarenas ? maxarenas &lt;&lt; 1 : INITIAL_ARENA_OBJECTS;        if (numarenas &lt;= maxarenas)            return NULL;                /* overflow */        nbytes = numarenas * sizeof(*arenas);        arenaobj = (struct arena_object *)PyMem_RawRealloc(arenas, nbytes);        if (arenaobj == NULL)            return NULL;        arenas = arenaobj;        /* 初始化新申请的arena_object, 并放入unused_arena_objects链表和arenas数组 */        for (i = maxarenas; i &lt; numarenas; ++i) {  /* 注意从maxarenas开始, 不动正在使用的arenas */            arenas[i].address = 0;              /* mark as unassociated */            arenas[i].nextarena = i &lt; numarenas - 1 ?                                   &amp;arenas[i+1] : NULL;        }        unused_arena_objects = &amp;arenas[maxarenas];        maxarenas = numarenas;    }    /* 从unused_arena_objects中取出一个未使用的arena_object*/*/    arenaobj = unused_arena_objects;    unused_arena_objects = arenaobj-&gt;nextarena;    /* 申请arena_object所管理的内存 */    address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);    if (address == NULL) {        arenaobj-&gt;nextarena = unused_arena_objects;        unused_arena_objects = arenaobj;        return NULL;    }    arenaobj-&gt;address = (uintptr_t)address;    ++narenas_currently_allocated;    ++ntimes_arena_allocated;    if (narenas_currently_allocated &gt; narenas_highwater)        narenas_highwater = narenas_currently_allocated;    /* 把arena内部分割成pool  */    arenaobj-&gt;freepools = NULL;    arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;    arenaobj-&gt;nfreepools = ARENA_SIZE / POOL_SIZE;    /* pool地址对齐 */    excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);    if (excess != 0) {        --arenaobj-&gt;nfreepools;        arenaobj-&gt;pool_address += POOL_SIZE - excess;    }    arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;    return arenaobj; /* 返回新的arena_object */}</code></pre><p>在创建新的<code>arena</code>期间, Python首先会检查<code>unused_arena_objects</code>链表中是否还有”未使用”状态的<code>arena</code>.</p><ul><li>如果<code>unused_arena_objects</code>中存在未使用的<code>arena</code>, 那么直接从中取出一个<code>arena</code>, 调整<code>unused_arena_objects</code>指针, 断绝和抽取的<code>arena</code>的联系;</li><li>如果<code>unused_arena_objects</code>为<code>NULL</code>, 那么Python会申请单独用于存放<code>numarenas</code>个<code>arena</code>的内存空间, 这个值在第一次的时候为<code>16</code>, 以后会翻倍. 申请内存后, 每个<code>arena</code>设置地址<code>address</code>都为<code>0</code>, 并通过指针<code>nextarena</code>将它们连接起来.</li></ul><p>无论哪种情况, 在从<code>unused_arena_objects</code>中获取到一个<code>arena</code>后, 会为它所管理的<code>pool</code>集合申请一块内存, <code>address</code>域就是申请的内存地址, 而<code>pool_address</code>是对开头的<code>pool</code>经过系统页对齐的地址. 到现在为止, <code>arena</code>和<code>pool</code>建立了联系, 就等着<code>usable_arenas</code>接收了.</p><h2 id="第2层对象分配器"><a href="#第2层对象分配器" class="headerlink" title="第2层对象分配器"></a>第2层对象分配器</h2><p>尽管我们花了大量篇幅介绍<code>arena</code>, 然而Python申请内存时, 直接打交道的确实<code>pool</code>. 这也无可厚非, 毕竟只有通过<code>pool</code>才能找到保存固定大小的<code>block</code>块的内存.</p><h3 id="usedpools"><a href="#usedpools" class="headerlink" title="usedpools"></a>usedpools</h3><p>在Python中为实现高速搜索<code>pool</code>, 使用了一个全局变量<code>usedpools</code>来保持<code>pool</code>数组. 一个 <code>pool</code>在Python运行期间, 必然处于以下三种状态中的一种:</p><ul><li><code>used</code>状态: <code>pool</code>中至少有一个<code>block</code>已经被使用, 并且至少一个<code>block</code>还未被使用, 这种状态受控于<code>usedpools</code>数组;</li><li><code>full</code>状态: <code>pool</code>中的所有<code>block</code>都已经被使用, 这种状态的<code>pool</code>位于<code>arena</code>中, 但不在<code>arena</code>的<code>freepools</code>链表中;</li><li><code>empty</code>状态: 这种状态的<code>pool</code>中的所有<code>block</code>都未使用, 处于这种状态的<code>pool</code>集合, 通过<code>pool_header</code>的<code>nextpool</code>构成的链表正好形成<code>arena</code>的<code>freepools</code>;</li></ul><p>下面给出了一个<code>arena</code>中包含三种状态的<code>pool</code>集合的一个可能状态:</p><p><img src="/images/pymemobject-7.png" alt=""></p><p>注意, 处于<code>full</code>状态的<code>pool</code>是独立的, 没有和其他<code>pool</code>那样会链接成链表. 所有处于<code>used</code>状态的<code>pool</code>都被受控于<code>usedpools</code>数组. <code>usedpools</code> 与<code>size class index</code>有着密切的联系, 来看一看<code>usedpools</code>的结构:</p><pre><code class="c">[obmalloc.c]typedef struct pool_header *poolp;#define PTA(x)  ((poolp )((uint8_t *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))#define PT(x)   PTA(x), PTA(x)static poolp usedpools[2 * ((NB_SMALL_SIZE_CLASSES + 7) / 8) * 8] = {    PT(0), PT(1), PT(2), PT(3), PT(4), PT(5), PT(6), PT(7)#if NB_SMALL_SIZE_CLASSES &gt; 8    , PT(8), PT(9), PT(10), PT(11), PT(12), PT(13), PT(14), PT(15)#if NB_SMALL_SIZE_CLASSES &gt; 16    , PT(16), PT(17), PT(18), PT(19), PT(20), PT(21), PT(22), PT(23)......#if NB_SMALL_SIZE_CLASSES &gt; 56    , PT(56), PT(57), PT(58), PT(59), PT(60), PT(61), PT(62), PT(63)......#endif /* NB_SMALL_SIZE_CLASSES &gt;  8 */};</code></pre><p>可以看到<code>usedpools</code>是一个<code>pool_header</code>的指针型数组, 将它精简过后的形式是:</p><pre><code class="c">static poolp usedpools[128] = {    PT(0), PT(1), PT(2), PT(3), PT(4), PT(5), PT(6), PT(7)    , PT(8), PT(9), PT(10), PT(11), PT(12), PT(13), PT(14), PT(15)    , PT(16), PT(17), PT(18), PT(19), PT(20), PT(21), PT(22), PT(23)    ......    , PT(56), PT(57), PT(58), PT(59), PT(60), PT(61), PT(62), PT(63)};</code></pre><p>看来<code>usedpools</code>的元素数量是<code>128</code>, 但是我们申请大小的种类类型却只有<code>64</code>种. 呈倍数关系是因为采用了双向链表连接<code>pool</code>, <code>usedpools</code>的元素被两两分为一组.</p><p>而宏定义<code>PT(x)</code>定义了一个指针: 这个指针指向的位置是从一组的开头再往前”两个block指针型的大小”.</p><p>懵逼…还是不太明白, 为什么非要把问题弄这么复杂, 直接将<code>usedpools</code>作为<code>pool_header</code>数组不行吗?</p><p>关于这点在注释中有解释:</p><blockquote><p>It’s unclear why the usedpools setup is so convoluted. <br><br>/<em> usedpools的设置不知为何变得如此复杂 </em>/ <br><br>It could be to<br>minimize the amount of cache required to hold this heavily-referenced table<br>(which only <em>needs</em> the two interpool pointer members of a pool_header).<br><br>/<em> 这可能是最大限度地减少持有这个严重引用的表所需的缓存量（它只需要</em> pool_header的两个池间指针成员）*/</p></blockquote><p>有点懵圈, 讲了一大堆云里雾里的, 关于<code>arena</code>, <code>pool</code>和<code>block</code>也有了一个模糊的概念, 下面就具体针对两个函数<code>_PyObject_Malloc</code>和<code>_PyObject_Free</code>, 分析Python的内存分配和内存释放过程.</p><h3 id="PyObject-Malloc"><a href="#PyObject-Malloc" class="headerlink" title="_PyObject_Malloc"></a>_PyObject_Malloc</h3><p>Python中的对大部分对象的内存分配都是通过这个函数<code>_PyObject_Malloc</code>完成的.</p><p>这个函数有三个作用: “分配block”, “分配pool”和”分配arena”.</p><p>函数的整体流程如下(为了更好的理解, 对源码进行了整理):</p><pre><code class="c">static void *_PyObject_Alloc(int use_calloc, void *ctx, size_t nelem, size_t elsize){    size_t nbytes;    block *bp;    poolp pool;    poolp next;    uint size;    _Py_AllocatedBlocks++;    nbytes = nelem * elsize;  /* 计算需要申请的字节数 */    if (nelem == 0 || elsize == 0)        goto redirect;    /* 申请的字节数是否小于等于512字节? */    if ((nbytes - 1) &lt; SMALL_REQUEST_THRESHOLD) {        LOCK(); /* 线程锁 */        size = (uint)(nbytes - 1) &gt;&gt; ALIGNMENT_SHIFT; /* 转换成索引 */        pool = usedpools[size + size]; /* 从usedpools中取出pool */        /* 检查pool是否连接到了指定索引的usedpool是的元素        如果连接到了那么pool和pool-&gt;nextpool地址应该不同 */        if (pool != pool-&gt;nextpool) { /* 返回pool内的block */            ++pool-&gt;ref.count; /* pool内分配的block数量加一 */            bp = pool-&gt;freeblock;             /* 尝试通过离散链表获取block(使用完毕的block) */            if ((pool-&gt;freeblock = *(block **)bp) != NULL) {                UNLOCK(); /* 解锁线程 */                return (void *)bp; /* 返回block */            }            /* 通过偏移量取出block(未使用的block) */            if (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) {                /* There is room for another block. */                pool-&gt;freeblock = (block*)pool +                                  pool-&gt;nextoffset;                /* 设定下一个空block的偏移量 */                pool-&gt;nextoffset += INDEX2SIZE(size);                *(block **)(pool-&gt;freeblock) = NULL;                UNLOCK();                return (void *)bp; /* 返回block*/            }            /* 该pool已满, 无法再使用, 从usedpools中移除 */            next = pool-&gt;nextpool;            pool = pool-&gt;prevpool;            next-&gt;prevpool = pool;            pool-&gt;nextpool = next;            UNLOCK();            return (void *)bp; /* 返回block */        }        /* 没有可用的arena, 调用new_arena创建新的arenas */        if (usable_arenas == NULL) {            if (narenas_currently_allocated &gt;= MAX_ARENAS) {                UNLOCK();                goto redirect;            }            usable_arenas = new_arena(); /* 分配新的一批arena_objects */            if (usable_arenas == NULL) {                UNLOCK();                goto redirect;            }            usable_arenas-&gt;nextarena =                usable_arenas-&gt;prevarena = NULL;        }        /* 从arean中取出空闲的pool */        pool = usable_arenas-&gt;freepools;        if (pool != NULL) { /* 检查是否存在空闲的pool */            usable_arenas-&gt;freepools = pool-&gt;nextpool; /* 把空闲的pool从链表中取出 */            --usable_arenas-&gt;nfreepools; /* usable_arenas可用pool数减一 */            if (usable_arenas-&gt;nfreepools == 0) {  /* arena中已经没有空闲pool, 将它移除 */                usable_arenas = usable_arenas-&gt;nextarena;                if (usable_arenas != NULL) {                    usable_arenas-&gt;prevarena = NULL;                }            }        init_pool: /* 初始化并返回pool */            /* 连接usedpools的开头 */            next = usedpools[size + size]; /* == prev */            pool-&gt;nextpool = next;            pool-&gt;prevpool = next;            next-&gt;nextpool = pool;            next-&gt;prevpool = pool;            pool-&gt;ref.count = 1;            if (pool-&gt;szidx == size) {                /* 比较申请的大小和pool中block的固定大小*/                /* 如果相同(曾经使用过, 而且size相同), 那么就不用进行初始化也无所谓 */                bp = pool-&gt;freeblock;                pool-&gt;freeblock = *(block **)bp; /* 设定下一个block地址 */                UNLOCK();                return (void *)bp; /* 返回block */            }            /* 初始化pool */            pool-&gt;szidx = size;            size = INDEX2SIZE(size);            bp = (block *)pool + POOL_OVERHEAD;            pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; 1);            pool-&gt;maxnextoffset = POOL_SIZE - size;            pool-&gt;freeblock = bp + size;            *(block **)(pool-&gt;freeblock) = NULL;            UNLOCK();            return (void *)bp; /* 返回block */        }        /* 初始化空的pool */        pool = (poolp)usable_arenas-&gt;pool_address;        pool-&gt;arenaindex = (uint)(usable_arenas - arenas);        pool-&gt;szidx = DUMMY_SIZE_IDX;        usable_arenas-&gt;pool_address += POOL_SIZE;        --usable_arenas-&gt;nfreepools;        if (usable_arenas-&gt;nfreepools == 0) { /* 如果没有可用的pool了, 那么就设定下一个arena */            usable_arenas = usable_arenas-&gt;nextarena;            if (usable_arenas != NULL) {                usable_arenas-&gt;prevarena = NULL;            }        }        goto init_pool;    }redirect: /* 调用原生的malloc分配内存 */    {        void *result;        result = PyMem_RawMalloc(nbytes);        return result;    }}</code></pre><pre><code class="c">static void *_PyObject_Malloc(size_t nbytes){    /* 是否小于等于512字节? */    if ((nbytes - 1) &lt; SMALL_REQUEST_THRESHOLD) {        /* (A)从usedpools中取出pool */        if (pool != pool-&gt;nextpool) {           /* (B)返回pool内的block */        }        /* 是否存在可以使用的arena? */        if (usable_arenas == NULL) {            /* (C)调用new_arena */        }        /* 从arena中取出使用空闲的pool */        pool = usable_arenas-&gt;freepools;        /* 是否存在空闲的pool */        if (pool != NULL) {            /* (D)初始化空闲的pool */                /* (E)初始化pool并返回block */       }    }  redirect:    {        /* 当大于256字节时, 使用原生的malloc申请内存 */        void *result;        result = PyMem_RawMalloc(nbytes);        return result;    }}</code></pre><h3 id="PyObject-Free"><a href="#PyObject-Free" class="headerlink" title="_PyObject_Free"></a>_PyObject_Free</h3><p>和分配内存对应, <code>_PyObject_Free</code>释放用<code>_PyObject_Malloc</code>分配的内存. 这个函数主要三个作用: “释放block”, “释放pool”和”释放arena”.</p><p>下面是整理过的源码和注释:</p><pre><code class="c">static void_PyObject_Free(void *ctx, void *p){    poolp pool;    block *lastfree;    poolp next, prev;    uint size;    if (p == NULL)      /* 为NULL时, 不执行任何动作 */        return;    _Py_AllocatedBlocks--;    pool = POOL_ADDR(p); /* 从作为释放对象的地址取出所属的pool */    if (address_in_range(p, pool)) { /* 检查获得的pool是否正确 */        LOCK(); /* 线程锁 */        *(block **)p = lastfree = pool-&gt;freeblock; /* 构建使用完毕的block的离散链表 */        pool-&gt;freeblock = (block *)p;  /* 将block设置为freeblock头 */        if (lastfree) { /* 这个pool的最后free的block是否为NULL */            struct arena_object* ao;            uint nf;  /* ao-&gt;nfreepools */            if (--pool-&gt;ref.count != 0) { /* pool正在使用used, 不执行任何操作 */                UNLOCK();                return;            }            /* pool变成empty状态, 从usedpools中移除 */            /* prev &lt;-&gt; pool &lt;-&gt; next */            /* prev &lt;-&gt; next */            next = pool-&gt;nextpool;            prev = pool-&gt;prevpool;            next-&gt;prevpool = prev;            prev-&gt;nextpool = next;            /* 将pool返回到arena的freepools */            ao = &amp;arenas[pool-&gt;arenaindex];            pool-&gt;nextpool = ao-&gt;freepools;            ao-&gt;freepools = pool;            nf = ++ao-&gt;nfreepools;             /* 释放arena */            if (nf == ao-&gt;ntotalpools) { /* 当arena内全是空的pool, 就将其释放掉 */                /* 从usable_arenas中移除 */                if (ao-&gt;prevarena == NULL) {                    usable_arenas = ao-&gt;nextarena;                }                else {                    ao-&gt;prevarena-&gt;nextarena =                        ao-&gt;nextarena;                }                if (ao-&gt;nextarena != NULL) {                    ao-&gt;nextarena-&gt;prevarena =                        ao-&gt;prevarena;                }                /* 为了再次利用arena, 将其连接到unused_arena_objects */                ao-&gt;nextarena = unused_arena_objects;                unused_arena_objects = ao;                /* 释放掉arena维护的那块内存 */                _PyObject_Arena.free(_PyObject_Arena.ctx,                                     (void *)ao-&gt;address, ARENA_SIZE);                ao-&gt;address = 0;                        /* mark unassociated */                --narenas_currently_allocated;                UNLOCK();                return;            }            if (nf == 1) { /* arena中只有一个空的pool */                /* 这里只有一个空的pool, 意味着在这次释放pool之前, 所有pool都在使用 */                /* 本来没有连接到usable_arenas中, 现在需要连接到usable_arenas头 */                ao-&gt;nextarena = usable_arenas;                ao-&gt;prevarena = NULL;                if (usable_arenas)                    usable_arenas-&gt;prevarena = ao;                usable_arenas = ao;                UNLOCK();                return;            }            if (ao-&gt;nextarena == NULL || nf &lt;= ao-&gt;nextarena-&gt;nfreepools) {                /* 如果arena是最后一个arena, 或者这个arena_object中空闲的pool数量小于下一个 */                /* 那么不执行任何操作 */                UNLOCK();                return;            }             /* 如果不是上面两种情况, 则需要对arena按从小到大排序 */             /* 首先我们将这个arena从usable_arenas中拿出来 */            if (ao-&gt;prevarena != NULL) {                ao-&gt;prevarena-&gt;nextarena = ao-&gt;nextarena;            }            else {                usable_arenas = ao-&gt;nextarena;            }            ao-&gt;nextarena-&gt;prevarena = ao-&gt;prevarena;            /* 然后从usable_arenas中找到合适位置插入arena_object */            while (ao-&gt;nextarena != NULL &amp;&amp;                            nf &gt; ao-&gt;nextarena-&gt;nfreepools) {                ao-&gt;prevarena = ao-&gt;nextarena;                ao-&gt;nextarena = ao-&gt;nextarena-&gt;nextarena;            }            ao-&gt;prevarena-&gt;nextarena = ao;            if (ao-&gt;nextarena != NULL)                ao-&gt;nextarena-&gt;prevarena = ao;            UNLOCK();            return;        }        /* lastfree为NULL意味着这个pool内的所有block都已经分配完毕 */        /* 需要从usedpools中取出这个大小类型的pool, 并将这个pool连接到usedpools开头 */        --pool-&gt;ref.count;        size = pool-&gt;szidx;        next = usedpools[size + size];        prev = next-&gt;prevpool;        pool-&gt;nextpool = next;        pool-&gt;prevpool = prev;        next-&gt;prevpool = pool;        prev-&gt;nextpool = pool;        UNLOCK();        return;    }redirect:    /* 释放其他空间 */    PyMem_RawFree(p);}</code></pre><h2 id="第3层特殊对象缓冲机制"><a href="#第3层特殊对象缓冲机制" class="headerlink" title="第3层特殊对象缓冲机制"></a>第3层特殊对象缓冲机制</h2><p>这一部分, 我们在前面的Python内置对象讲过, 针对一些常用的类型, Python提供了一系列的缓冲池技术.</p><!-- 当申请一个32字节的`pool`时, 需要将这个`pool`放入`usedpools`. 先得到它的`size class index`, 也就是3. 然后进行`usedpools[3+3]->nextpool = pool`即可.  --><!-- `PyObject_Malloc`中利用了这个技巧来判断某个`class size index`对应的`pool`是否存在于`usedpools`中.```cstatic void *_PyObject_Alloc(int use_calloc, void *ctx, size_t nelem, size_t elsize){    size_t nbytes;    block *bp;    poolp pool;    poolp next;    uint size;    if ((nbytes - 1) < SMALL_REQUEST_THRESHOLD) {        LOCK();        /* 获得size class index */        size = (uint)(nbytes - 1) >> ALIGNMENT_SHIFT;        pool = usedpools[size + size];        if (pool != pool->nextpool) { /* usedpools是否有可用的pool */            ......        }      ......}```### 创建pool当Python启动的时候, `usedpools`这个内存池中并没有可用内存, 当我们开始申请小块内存的时候, Python才开始建立这个内存池. 假设我们申请`32`字节的内存, Python首先得到对应的`class size index=3`,  在`usedpools`对应的位置查找, 发现没有任何可用的`pool`, Python才会从`useable_arenas`链表中第一个可用的`arena`获得一个可用的`pool`. 考虑到, 这个`pool`将是用于分配`32`字节`block`的, 因此在此它需要被重新划分.```c[obmalloc.c]static void * _PyObject_Alloc(int use_calloc, void *ctx, size_t nelem, size_t elsize){    ...  init_pool:  /* 初始化pool */    // 将pool放入usedpools中    next = usedpools[size + size];    pool->nextpool = next;    pool->prevpool = next;    next->nextpool = pool;    next->prevpool = pool;    pool->ref.count = 1;    // pool在之前就具有正确的size结构, 直接返回pool中的一个block    if (pool->szidx == size) {        bp = pool->freeblock;        assert(bp != NULL);        pool->freeblock = *(block **)bp;        UNLOCK();        if (use_calloc)            memset(bp, 0, nbytes);        return (void *)bp;    }    // 初始化pool_header, 将freeblock指向第二个block, 返回第一个block    pool->szidx = size;    size = INDEX2SIZE(size);    bp = (block *)pool + POOL_OVERHEAD;    pool->nextoffset = POOL_OVERHEAD + (size << 1);    pool->maxnextoffset = POOL_SIZE - size;    pool->freeblock = bp + size;    *(block **)(pool->freeblock) = NULL;    UNLOCK();    if (use_calloc)        memset(bp, 0, nbytes);    return (void *)bp;    ...}```Python将得到的pool放入了usedpools中. 那么在什么情况下pool从empty转为used状态呢? 假设申请的内存为size class index 为 i. 字儿usedpools[i + i] 处没有处于used状态的pool. 同时全局变量freepools中海油处于empty的pool, 那么位于freepool维护的链表中头部pool将被取出来, 放入usedpools中, 这时, 这个pool也就从empry状态转为used状态.```c[obmalloc.c _PyObject_Alloc]pool = usable_arenas->freepools;if (pool != NULL) {    usable_arenas->freepools = pool->nextpool;    ...// 调整usable_arenas->nfreepools和usable_arenas自身init_pool:    ...}``` -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于来到了最后一部分: 内存管理.&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python源码阅读-多线程机制</title>
    <link href="http://shawnz.me/posts/8c8f8f97/"/>
    <id>http://shawnz.me/posts/8c8f8f97/</id>
    <published>2018-01-11T12:41:04.000Z</published>
    <updated>2018-03-10T06:20:54.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GIL与线程调度"><a href="#GIL与线程调度" class="headerlink" title="GIL与线程调度"></a>GIL与线程调度</h2><p>GIL(Global Interpreter Lock), 限制线程对共享资源的访问，同一时间只会有一个获得GIL的线程在跑，其他线程则处于等待状态. Python的线程是原生操作系统线程, 它使用的线程的调度模型主要需要解决两个问题:</p><ul><li>在何时挂起当前线程, 选择处理等待状态的线程?</li><li>在众多的等待线程中, 选择激活哪个线程?</li></ul><a id="more"></a><p>Python模拟操作系统上线程的时钟中断机制, 实现了相似的原理:</p><ul><li>在Python2采用<code>ticks</code>计步，当一个线程无中断地运行了粗略<code>100</code>个字节码(可以通过<code>sys.getcheckinterval()</code>查看), 会释放<code>GIL</code>;</li><li>在Python3中，新的GIL实现中用一个固定的超时时间来指示当前的线程放弃全局锁。在当前线程保持这个锁，且其他线程请求这个锁时，当前线程就会在5毫秒后被强制释放该锁(可以通过<code>sys.getswitchinterval</code>查看)。</li></ul><p>至于选择激活哪个线程, 完全由操作系统系统决定. 这一点至关重要, Python的线程就是操作系统的原生线程, 只不过在Python维护着这些线程的状态<code>PyThreadState</code>对象, 以及在这些线程上面实现一层抽象, 提供统一的编程接口, 例如: <code>thread</code>和<code>threading</code>等.</p><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>我们来看一个简单的例子:</p><pre><code class="python"></code></pre><p>在Python中我们可以使用<code>thread</code>模块或<code>threading</code>模块创建线程. <code>threading</code>模块是对<code>_thread</code>模块的封装, <code>_thread</code>是一个內建模块, 它的实现在<code>_threadmodule.c</code>:</p><pre><code class="c">[_threadmodule.c]static PyMethodDef thread_methods[] = {    {&quot;start_new_thread&quot;,        (PyCFunction)thread_PyThread_start_new_thread,     METH_VARARGS, start_new_doc},    {&quot;start_new&quot;,               (PyCFunction)thread_PyThread_start_new_thread,     METH_VARARGS, start_new_doc},    {&quot;allocate_lock&quot;,           (PyCFunction)thread_PyThread_allocate_lock,     METH_NOARGS, allocate_doc},    {&quot;allocate&quot;,                (PyCFunction)thread_PyThread_allocate_lock,     METH_NOARGS, allocate_doc},    {&quot;exit_thread&quot;,             (PyCFunction)thread_PyThread_exit_thread,     METH_NOARGS, exit_doc},    ......    {NULL,                      NULL}           /* sentinel */};</code></pre><p><code>_thread</code>模块为用户提供的多线程编程接口十分少, 也正因如此Python的多线程编程才变得简单灵活.</p><p>创建线程的函数是<code>thread_PyThread_start_new_thread</code>, 下面是它的实现:</p><pre><code class="c">static PyObject *thread_PyThread_start_new_thread(PyObject *self, PyObject *fargs){    PyObject *func, *args, *keyw = NULL;    struct bootstate *boot;    long ident;    PyArg_UnpackTuple(fargs, &quot;start_new_thread&quot;, 2, 3, &amp;func, &amp;args, &amp;keyw))    boot = PyMem_NEW(struct bootstate, 1); /* 创建bootstate结构 */    boot-&gt;interp = PyThreadState_GET()-&gt;interp;    boot-&gt;func = func;    boot-&gt;args = args;    boot-&gt;keyw = keyw;    boot-&gt;tstate = _PyThreadState_Prealloc(boot-&gt;interp);    PyEval_InitThreads(); /* 初始化多线程环境 */    ident = PyThread_start_new_thread(t_bootstrap, (void*) boot); /* 创建线程 */    return PyLong_FromLong(ident); /* 返回线程标识 */}</code></pre><p><strong>Python在多线程机制默认是没有激活的.</strong></p><p>这一点十分有意思, 在虚拟机启动的时候, Python只支持单线程, 支持多线程的数据结构和<code>GIL</code>都没有创建, 只有当用户调用<code>thread.start_new_thread</code>时, Python才会认为用户需要多线程的支持, 自动初始化多线程环境.</p><h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><p>创建多线程环境的主要工作就是<code>GIL</code>的创建.</p><pre><code class="c">[pythread.h]typedef void *PyThread_type_lock;[ceval.c]static PyThread_type_lock pending_lock = 0; /* for pending calls */static long main_thread = 0;voidPyEval_InitThreads(void){    if (gil_created())        return;    create_gil();    take_gil(PyThreadState_GET());    main_thread = PyThread_get_thread_ident();    if (!pending_lock)        pending_lock = PyThread_allocate_lock();}</code></pre><p>Python的<code>GIL</code>是一个<code>void *</code>指针, 可以指向任意类型. Python的多线程机制是平台相关的, 在Linux和Windows下有不同的实现: </p><pre><code class="c">[thread.c]#ifdef _POSIX_THREADS  /* Linux POSIX线程 */#define PYTHREAD_NAME &quot;pthread&quot;#include &quot;thread_pthread.h&quot;#endif#ifdef NT_THREADS /* Windows系统 */#define PYTHREAD_NAME &quot;nt&quot;#include &quot;thread_nt.h&quot;#endif</code></pre><p>在WIN32平台下, <code>GIL</code>是一个<code>NRMUTEX</code>结构体, 利用<code>Event</code>来实现线程的互斥:</p><pre><code class="c">[thread_nt.h]typedef struct NRMUTEX {LONG   owned ;DWORD  thread_id ;HANDLE hevent ;} NRMUTEX, *PNRMUTEX ;</code></pre><p>在Linux系统下, <code>GIL</code>利用条件机制和互斥锁<code>&lt;cond, mutex&gt;</code>保护一个锁变量作为实现(还有其他的实现: “信号量”):</p><pre><code class="c">[thread_pthread.h]typedef struct {    char             locked; /* 0=unlocked, 1=locked */    pthread_cond_t   lock_released;    pthread_mutex_t  mut;  /* 利用&lt;cond, mutex&gt;获得锁, 控制线程的同步 */} pthread_lock;</code></pre><p>在这里不会过多的深入线程机制具体实现, 而是以Linux平台为参考, 重点关注Python的线程调度机制. </p><p>无论创建多少个线程, 多线程环境的初始化动作只执行一次(检查<code>gil_created</code>).</p><p>在经过<code>PyEval_InitThreads -&gt; PyThread_allocate_lock</code>获得了<code>GIL</code>锁后, 线程调度就需要<strong>获取</strong>和<strong>释放</strong><code>GIL</code>锁.</p><ul><li><code>PyThread_acquire_lock()</code></li><li><code>PyThread_release_lock()</code></li></ul><h3 id="GIL创建"><a href="#GIL创建" class="headerlink" title="GIL创建"></a>GIL创建</h3><pre><code class="c">PyThread_type_lockPyThread_allocate_lock(void){    pthread_lock *lock;    int status, error = 0;    if (!initialized)  /* 检查原生线程环境的初始化 */        PyThread_init_thread();    lock = (pthread_lock *) PyMem_RawMalloc(sizeof(pthread_lock));    memset((void *)lock, &#39;\0&#39;, sizeof(pthread_lock)); /* 零值 */    lock-&gt;locked = 0; /* GIL没有被占用 */    status = pthread_mutex_init(&amp;lock-&gt;mut,                                pthread_mutexattr_default);    /* Mark the pthread mutex underlying a Python mutex as pure happens-before.       We can&#39;t simply mark the Python-level mutex as a mutex because it can be       acquired and released in different threads, which will cause errors. */    _Py_ANNOTATE_PURE_HAPPENS_BEFORE_MUTEX(&amp;lock-&gt;mut);    status = pthread_cond_init(&amp;lock-&gt;lock_released,                                pthread_condattr_default);    return (PyThread_type_lock) lock;}</code></pre><p>在<code>GIL</code>的创建中, Python会先通过变量<code>initialized</code>检查原生线程环境是否初始化完毕(没有什么工作, 只是一个标识), 在其后就是<code>PyThread_type_lock</code>各个域的初始化, 可以看到新创建的<code>GIL</code>锁是没有被线程占有的. 这样在虚拟机初始化</p><h3 id="GIL获取"><a href="#GIL获取" class="headerlink" title="GIL获取"></a>GIL获取</h3><pre><code class="c">[thread_pthread.h]PyLockStatusPyThread_acquire_lock_timed(PyThread_type_lock lock, PY_TIMEOUT_T microseconds,                            int intr_flag){    PyLockStatus success = PY_LOCK_FAILURE; /* 上锁成功或失败 */    pthread_lock *thelock = (pthread_lock *)lock;    int status, error = 0;    status = pthread_mutex_lock( &amp;thelock-&gt;mut );  /* 先获取mutex, 获得操作locked变量的权限 */    if (status == 0) {        if (thelock-&gt;locked == 0) { /* GIL可用 */            success = PY_LOCK_ACQUIRED;        }        else if (microseconds != 0) { /* GIL不可用, 尝试等待 */            struct timespec ts;            if (microseconds &gt; 0)  /* 等待microseconds时长 */                MICROSECONDS_TO_TIMESPEC(microseconds, ts);            while (success == PY_LOCK_FAILURE) {                if (microseconds &gt; 0) { /* 超时等待锁变量释放  */                    status = pthread_cond_timedwait(                        &amp;thelock-&gt;lock_released,                        &amp;thelock-&gt;mut, &amp;ts);                    if (status == ETIMEDOUT)                        break;                }                else { /* 无限期的等待锁变量释放 */                    status = pthread_cond_wait(                        &amp;thelock-&gt;lock_released,                        &amp;thelock-&gt;mut);                }                if (intr_flag &amp;&amp; status == 0 &amp;&amp; thelock-&gt;locked) { /* 锁不可用, 允许上层重试 */                    success = PY_LOCK_INTR;                    break;                }                else if (status == 0 &amp;&amp; !thelock-&gt;locked) { /* 成功, 其他线程释放了锁变量 */                    success = PY_LOCK_ACQUIRED;                }            }        }        if (success == PY_LOCK_ACQUIRED) thelock-&gt;locked = 1; /* 获取到mutex锁, 修改锁变量locked */        status = pthread_mutex_unlock(&amp;thelock-&gt;mut); /* 解锁mutex, 让其他线程有机会进入临界区等待GIL */    }    if (error) success = PY_LOCK_FAILURE;  /* 失败 */    return success;}</code></pre><p><code>GIL</code>的获取过程: 线程会先获得<code>mutex</code>锁, 才可以修改锁变量<code>locked</code>. 如果获得mutex锁后, <code>locked</code>不为<code>0</code>则代表其他线程正在占用锁, 必须通过<code>pthread_cond_timedwait</code>等待其他线程将锁变量释放掉. 在获得<code>GIL</code>锁后, 设置<code>thelock-&gt;locked = 1</code>表示正在占中<code>GIL</code>锁, 线程必须释放掉<code>mutex</code>锁, 让其他线程有机会进入临界区等待锁.</p><h3 id="GIL释放"><a href="#GIL释放" class="headerlink" title="GIL释放"></a>GIL释放</h3><pre><code class="c">voidPyThread_release_lock(PyThread_type_lock lock){    pthread_lock *thelock = (pthread_lock *)lock;    int status, error = 0;    status = pthread_mutex_lock( &amp;thelock-&gt;mut ); /* 先获取mutex锁, 获得修改锁变量的权限 */    thelock-&gt;locked = 0; /* 释放GIL锁 */    status = pthread_cond_signal( &amp;thelock-&gt;lock_released ); /* 通知临界区的一个线程, 锁已经释放 */    status = pthread_mutex_unlock( &amp;thelock-&gt;mut ); /* 释放mutex锁 */}</code></pre><p>释放<code>GIL</code>锁, 首先也需要先获取到<code>mutex</code>锁, 修改锁变量后, 还需要通知其他在等待<code>GIL</code>锁的线程, 最后释放掉<code>mutex</code>锁.</p><p>疑问: 不是会造成死锁吗? 一个占有metex锁在等待<code>GIL</code>释放信号, 一个申请<code>mutex</code>锁, 发送<code>GIL</code>释放信号?</p><p>答案: 应该是在进入<code>pthread_cond_wait</code>期间, 会将<code>thelock-&gt;mut</code>释放掉. 条件满足的时候, 又会对<code>metex</code>加锁.</p><h2 id="创建子线程"><a href="#创建子线程" class="headerlink" title="创建子线程"></a>创建子线程</h2><p>现在回到创建线程的<code>thread_PyThread_start_new_thread</code>函数, 我们先来看看在初始化线程环境之前的那个<code>bootstate</code>:</p><pre><code class="c">boot = PyMem_NEW(struct bootstate, 1);boot-&gt;interp = PyThreadState_GET()-&gt;interp; /* 当前进程 */boot-&gt;func = func; /* 线程函数 */boot-&gt;args = args; /* 函数位置参数 */boot-&gt;keyw = keyw; /* 函数关键字参数 */boot-&gt;tstate = _PyThreadState_Prealloc(boot-&gt;interp); /* 创建一个空的threadstate */</code></pre><p>这个<code>boot</code>保存了程序中定义的线程相关的信息, 在构造完<code>boot</code>结构体以及确认初始化多线程环境后, Python就会调用底层的API创建原生线程:<code>PyThread_start_new_thread(t_bootstrap, (void*) boot);</code>. 这里传递的参数是一个<code>t_bootstrap</code>函数和之前构建好的<code>boot</code>结构体.</p><pre><code class="c">[thread_pthread.h]longPyThread_start_new_thread(void (*func)(void *), void *arg){    pthread_t th; /* 线程标识 */    int status;    pthread_attr_t attrs; /* 线程属性 */    size_t      tss;    if (!initialized)  /* 检查原生线程环境的初始化 */        PyThread_init_thread();    pthread_attr_init(&amp;attrs) /* 线程属性初始化 */    tss = (_pythread_stacksize != 0) ? _pythread_stacksize : THREAD_STACK_SIZE;    pthread_attr_setstacksize(&amp;attrs, tss); /* 设置线程堆栈大小 */    pthread_attr_setscope(&amp;attrs, PTHREAD_SCOPE_SYSTEM); /* 设置CPU竞争模式 */    status = pthread_create(&amp;th, &amp;attrs, (pthread_attr_t*)NULL,                            (void* (*)(void *))func, (void *)arg); /* 创建原生线程 */    pthread_attr_destroy(&amp;attrs); /* 线程属性销毁 */    pthread_detach(th); /* 线程运行结束后, 自动释放内存 */    return (long) th;}</code></pre><p>Python会调用一系列的C API来设置和创建一个原生线程, 传给<code>pthread_create</code>用来创建线程的<code>func</code>参数是<code>t_bootstrap</code>, <code>arg</code>参数是包装了线程信息的<code>boot</code>结构, 我们这里还是重点关注那个<code>t_bootstrap</code>函数:</p><pre><code class="c">static voidt_bootstrap(void *boot_raw){    struct bootstate *boot = (struct bootstate *) boot_raw;    PyThreadState *tstate;    PyObject *res;    tstate = boot-&gt;tstate;    tstate-&gt;thread_id = PyThread_get_thread_ident();    _PyThreadState_Init(tstate);    PyEval_AcquireThread(tstate); /* 获取GIL锁 */    nb_threads++;    res = PyEval_CallObjectWithKeywords(        boot-&gt;func, boot-&gt;args, boot-&gt;keyw); /* 执行我们的函数 */    ......    PyMem_DEL(boot_raw);    nb_threads--;    PyThreadState_Clear(tstate);    PyThreadState_DeleteCurrent();    PyThread_exit_thread(); /* 通过pthread_exit(0);退出, 保证线程的子线程不会跟着结束 */}</code></pre><p>子线程和主线程的<code>GIL</code>竞争将发生在这里, <code>PyEval_AcquireThread</code>会尝试获取<code>GIL</code>锁:</p><pre><code class="c">voidPyEval_AcquireThread(PyThreadState *tstate){    assert(gil_created()); /* 检查GIL锁已被初始化 */    take_gil(tstate); /* 获取GIL锁 */    PyThreadState_Swap(tstate) /* 更新线程状态指针_PyThreadState_Current */}</code></pre><p>在子线程通过<code>take_gil</code>获得GIL后, 就会开始执行我们的线程函数, <code>PyEval_CallObjectWithKeywords</code>执行结束后, 会释放GIL, 并完成销毁工作.有一点没有讲到的是关于”让步”的问题, 线程持有<code>GIL</code>后并不是直到结束才释放<code>GIL</code>锁.</p><h2 id="线程状态保护"><a href="#线程状态保护" class="headerlink" title="线程状态保护"></a>线程状态保护</h2><p>我们知道线程状态对象类似线程的上下文, 里面保存着对应线程的信息, 并且有一个全局的<code>PyThreadState_Current</code>保存着当前活跃线程对应的状态对象. 这里有一个问题就是， 如何在调度线程的时候， 激活对应的线程状态对象?</p><p>Python的做法是在内部通过一个单链表的形式管理所有创建的<code>PyThreadState</code>对象, 它们通过<code>next</code>指针链接在在一起.</p><p>对于这个状态对象链表(线程共享的)的访问不需要<code>GIL</code>, 因为单独维护了一个<code>headmutex</code>锁, 它是在创建进程状态对象的时候创建的.</p><pre><code class="c">[pystate.c]static PyThread_type_lock head_mutex = NULL; /* Protects interp-&gt;tstate_head */#define HEAD_INIT() (void)(head_mutex || (head_mutex = PyThread_allocate_lock()))</code></pre><p>在<code>Py_Initialize</code>运行时环境初始化的过程中有这么一步:</p><pre><code class="c">void_Py_InitializeEx_Private(int install_sigs, int install_importlib){    interp = PyInterpreterState_New(); /* 创建进程状态对象, 并初始化headmutex锁 */    tstate = PyThreadState_New(interp); /* 创建线程状态对象 */    (void) PyThreadState_Swap(tstate); /* 更新当前线程指针 */    _PyGILState_Init(interp, tstate);     ....</code></pre><p><code>_Py_InitializeEx_Private</code>里面会调用<code>_PyGILState_Init</code>函数, 创建<code>TLS entry</code>(TLS, Thread Local Storage), 用于存储和恢复线程状态对象.</p><pre><code class="c">[pystate.c]void_PyGILState_Init(PyInterpreterState *i, PyThreadState *t){    assert(i &amp;&amp; t); /* must init with valid states */    autoTLSkey = PyThread_create_key();    if (autoTLSkey == -1)        Py_FatalError(&quot;Could not allocate TLS entry&quot;);    autoInterpreterState = i;    assert(PyThread_get_key_value(autoTLSkey) == NULL);    assert(t-&gt;gilstate_counter == 0);    _PyGILState_NoteThreadState(t);}static void_PyGILState_NoteThreadState(PyThreadState* tstate){    if (!autoInterpreterState)        return;    if (PyThread_get_key_value(autoTLSkey) == NULL) {        PyThread_set_key_value(autoTLSkey, (void *)tstate /* 存储线程状态对象 */    }    tstate-&gt;gilstate_counter = 1;}[thread_pthread.h]intPyThread_create_key(void){    pthread_key_t key;    int fail = pthread_key_create(&amp;key, NULL);    if (fail)        return -1;    if (key &gt; INT_MAX) {        /* Issue #22206: handle integer overflow */        pthread_key_delete(key);        errno = ENOMEM;        return -1;    }    return (int)key;}</code></pre><p><code>PyThread_create_key</code>函数会创建一个<code>TLS entry</code>(线程本地存储), 返回一个整数<code>key</code>, 这个<code>key</code>作为全局共享的<code>autoTLSkey</code>, 所有线程都能访问.</p><p>线程可以通过一系列的<code>API</code>操作和自己线程相关的数据:</p><ul><li><code>PyThread_get_key_value</code></li><li><code>PyThread_set_key_value</code></li><li>……</li></ul><p>不过我看这个<code>thread_pthread.h</code>中关于<code>TLS</code>的实现存储<code>tstate</code>好像也没有什么用, 不是可以通过指针<code>_PyThreadState_Current</code>获得当前线程状态对象吗? 另外也可以对<code>interp-&gt;state_head</code>遍历得到<code>tstate</code>啊.</p><p>不知道是不是因为兼容其他平台的实现, 或者不光用来存储线程状态对象还存储其他东西?…</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>在主线程创建子线程后, <code>t_bootstrap</code>函数是在子线程中执行的, 而在<code>PyEval_AcquireThread</code>竞争<code>GIL</code>之前的线程调度属于操作系统的线程调度, 之后的等待<code>GIL</code>锁以及之后的字节码执行才属于Python的线程调度范畴.</p><p>进入字节码执行阶段, Python会模拟操作系统的时钟机制来实现线程调度:</p><pre><code class="c">PyObject *_PyEval_EvalFrameDefault(PyFrameObject *f, int throwflag){    ......    for (;;) {        ......        if (_Py_atomic_load_relaxed(&amp;gil_drop_request)) {            /* Give another thread a chance */            if (PyThreadState_Swap(NULL) != tstate)                Py_FatalError(&quot;ceval: tstate mix-up&quot;);            drop_gil(tstate); /* 释放GIL */            /* Other threads may run now */            take_gil(tstate); /* 重新尝试GIL */            /* Check if we should make a quick exit. */            if (_Py_Finalizing &amp;&amp; _Py_Finalizing != tstate) {                drop_gil(tstate);                PyThread_exit_thread();            }            if (PyThreadState_Swap(tstate) != NULL)                Py_FatalError(&quot;ceval: orphan tstate&quot;);        }    ......}</code></pre><p>在执行字节码的过程中, 当达到某个条件后, 会尝试释放锁<code>drop_gil(tstate);</code>, 而释放锁可能被其他线程立即获得, 主线程将会等待其他线程释放<code>GIL</code>, 因此需要重新申请<code>GIL</code>.</p><h2 id="阻塞调度"><a href="#阻塞调度" class="headerlink" title="阻塞调度"></a>阻塞调度</h2><p>除了标准的线程调度外, Python还有一种阻塞调度的方式: 当线程执行<code>I/O</code>操作, 或者是睡眠<code>sleep</code>, 那么线程将会挂起, 虚拟机会唤醒正在等待的其他线程.</p><p>我们以<code>time.sleep</code>为例, 分析Python的阻塞调度机制.</p><pre><code class="c">static PyObject *time_sleep(PyObject *self, PyObject *obj){    _PyTime_t secs; /* int64_t 的别名 */    if (_PyTime_FromSecondsObject(&amp;secs, obj, _PyTime_ROUND_TIMEOUT)) /* 转换成timestamp */        return NULL;    if (pysleep(secs) != 0)        return NULL;    return Py_None;}</code></pre><p>下面是<code>pysleep</code>函数的实现:</p><pre><code class="c">static intpysleep(_PyTime_t secs){    _PyTime_t deadline, monotonic;    struct timeval timeout;    int err = 0;    deadline = _PyTime_GetMonotonicClock() + secs; /* 单调时间 */    do {        if (_PyTime_AsTimeval(secs, &amp;timeout, _PyTime_ROUND_CEILING) &lt; 0)            return -1; /* 将timestamp转换成struct timeval结构 */        Py_BEGIN_ALLOW_THREADS        err = select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &amp;timeout);        Py_END_ALLOW_THREADS        if (PyErr_CheckSignals()) /* sleep was interrupted by SIGINT */            return -1;        monotonic = _PyTime_GetMonotonicClock();        secs = deadline - monotonic;        if (secs &lt; 0)            break;    } while (1); /* retry with the recomputed delay */    return 0;}</code></pre><p>Python在这里使用<code>select</code>实现了<code>time.sleep(n)</code>的阻塞形式. 在阻塞的前后, 有两个宏定义:</p><ul><li><code>Py_BEGIN_ALLOW_THREADS</code>: 设置当前线程状态对象为<code>NULL</code>, 释放<code>GIL</code>, 保存线程状态对象;</li><li><code>Py_END_ALLOW_THREADS</code>: 获取<code>GIL</code>锁, 重新设置当前线程对象.</li></ul><p>Python正是利用上面两个宏定义实现了阻塞调度机制, 只要能保证线程安全, 我们就可以使用<code>Py_BEGIN_ALLOW_THREADS</code>和<code>Py_END_ALLOW_THREADS</code>释放<code>GIL</code>.</p><h2 id="子线程销毁"><a href="#子线程销毁" class="headerlink" title="子线程销毁"></a>子线程销毁</h2><p>线程执行占有<code>GIL</code>, 而当线程结束运行的时候就会释放<code>GIL</code>:</p><pre><code class="c">[_threadmodule.c]static voidt_bootstrap(void *boot_raw){    struct bootstate *boot = (struct bootstate *) boot_raw;    PyThreadState *tstate;    ......    PyMem_DEL(boot_raw);    nb_threads--;    PyThreadState_Clear(tstate); /* 线程状态对象清理 */    PyThreadState_DeleteCurrent(); /* GIL释放 */    PyThread_exit_thread(); /* 线程退出 */}</code></pre><p>在<code>t_bootstrap</code>函数的末尾, 我们可以看见Python做了清理线程的工作, 引用计数的维护(这里没有列出)以及<code>GIL</code>的释放和线程的退出. <code>GIL</code>的释放在<code>PyThreadState_DeleteCurrent</code>函数中:</p><pre><code class="c">[pystate.c]voidPyThreadState_DeleteCurrent(){    PyThreadState *tstate = GET_TSTATE(); /* 获取当前线程对象 */    tstate_delete_common(tstate);    if (autoInterpreterState &amp;&amp; PyThread_get_key_value(autoTLSkey) == tstate)        PyThread_delete_key_value(autoTLSkey); /* TLS中的tstate删除 */    SET_TSTATE(NULL); /* 设置当前线程对象为NULL */    PyEval_ReleaseLock(); /* 释放GIL锁 */}</code></pre><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>在Python的<code>GIL</code>机制下, 线程之间对整个Python解释器, 对Python提供的C API的访问都是互斥, 可以看作是Python内核级的互斥机制. 然而这种机制是Python程序员无法控制的, 我们还需要另外一种互斥机制—用户级互斥, 所以Python在这之上有提供了一系列的库, 例如: <code>threading</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GIL与线程调度&quot;&gt;&lt;a href=&quot;#GIL与线程调度&quot; class=&quot;headerlink&quot; title=&quot;GIL与线程调度&quot;&gt;&lt;/a&gt;GIL与线程调度&lt;/h2&gt;&lt;p&gt;GIL(Global Interpreter Lock), 限制线程对共享资源的访问，同一时间只会有一个获得GIL的线程在跑，其他线程则处于等待状态. Python的线程是原生操作系统线程, 它使用的线程的调度模型主要需要解决两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在何时挂起当前线程, 选择处理等待状态的线程?&lt;/li&gt;
&lt;li&gt;在众多的等待线程中, 选择激活哪个线程?&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python源码阅读-import机制</title>
    <link href="http://shawnz.me/posts/5a3f63f9/"/>
    <id>http://shawnz.me/posts/5a3f63f9/</id>
    <published>2018-01-11T12:40:47.000Z</published>
    <updated>2018-03-10T06:20:54.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="import指令"><a href="#import指令" class="headerlink" title="import指令"></a>import指令</h2><p><code>import</code>有两种形式:</p><ul><li><code>import ...</code></li><li><code>from ... import ...</code></li></ul><p>我们从简单的<code>import sys</code>开始，看看背后都发生了什么：</p><a id="more"></a><pre><code class="python">import sys# 0 LOAD_CONST               0 (0)# 2 LOAD_CONST               1 (None)# 4 IMPORT_NAME              0 (sys)# 6 STORE_NAME               0 (sys)</code></pre><p>关键的<code>IMPORT_NAME 0</code>指令：</p><pre><code class="c">names = co-&gt;co_names;TARGET(IMPORT_NAME) {    PyObject *name = GETITEM(names, oparg); /* 从co-&gt;const常量表中获取&quot;sys&quot; */    PyObject *fromlist = POP(); /* None */    PyObject *level = TOP(); /* 0 */    PyObject *res;    res = import_name(f, name, fromlist, level); /* f是frame */    SET_TOP(res);    DISPATCH();}</code></pre><p>在<code>IMPORT_NAME</code>指令中首先获取到了几个参数，然后调用<code>import_name</code>导入模块，并通过<code>SET_TOP</code>将模块对象压入栈顶，最终指令<code>STORE_NAME</code>将把模块对象存入命名空间中。</p><pre><code class="c">static PyObject *import_name(PyFrameObject *f, PyObject *name, PyObject *fromlist, PyObject *level){    _Py_IDENTIFIER(__import__);    PyObject *import_func, *res;    PyObject* stack[5];    /* 获取builtins模块的__import__函数*/    import_func = _PyDict_GetItemId(f-&gt;f_builtins, &amp;PyId___import__);    /* 如果用户没有重写import_func */    if (import_func == PyThreadState_GET()-&gt;interp-&gt;import_func) {        int ilevel = _PyLong_AsInt(level);        res = PyImport_ImportModuleLevelObject(                        name,                        f-&gt;f_globals,                        f-&gt;f_locals == NULL ? Py_None : f-&gt;f_locals,                        fromlist,                        ilevel);        return res;    }}</code></pre><p><code>import_name</code>函数首先从全局命名空间<code>builtins</code>(默认就是<code>builtins</code>模块的<code>md_dict</code>)中获取<code>__import__</code>函数。这个函数是对<code>builtin___import__</code>函数指针的包装，虚拟机会检查程序员是否对这个函数进行了重写, 如果没有重写(这里我们只考虑没有重写的情况), 就调用<code>PyImport_ImportModuleLevelObject</code>导入模块. </p><p><code>PyImport_ImportModuleLevelObject</code>函数的实现十分复杂, 这里列出了精简后的代码:</p><pre><code class="c">PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals,                                 PyObject *locals, PyObject *fromlist,                                 int level){    _Py_IDENTIFIER(_find_and_load);    _Py_IDENTIFIER(_handle_fromlist);    PyObject *abs_name = NULL;    PyObject *final_mod = NULL;    PyObject *mod = NULL;    PyObject *package = NULL;    PyInterpreterState *interp = PyThreadState_GET()-&gt;interp; /* 获取进程状态对象 */    int has_from;    if (level &gt; 0) {        abs_name = resolve_name(name, globals, level); /* 解析模块的绝对路径 */    }    else {  /* level == 0 */        abs_name = name;    }    mod = PyDict_GetItem(interp-&gt;modules, abs_name); /* 尝试从全局的interp-&gt;modules中获取模块 */    if (mod != NULL &amp;&amp; mod != Py_None) {        _Py_IDENTIFIER(__spec__);        _Py_IDENTIFIER(_initializing);        _Py_IDENTIFIER(_lock_unlock_module);        PyObject *value = NULL;        PyObject *spec;        int initializing = 0;        spec = _PyObject_GetAttrId(mod, &amp;PyId___spec__);        if (spec != NULL) {            value = _PyObject_GetAttrId(spec, &amp;PyId__initializing);        }        if (value == NULL)            PyErr_Clear();        else {            initializing = PyObject_IsTrue(value);            if (initializing == -1)                PyErr_Clear();            if (initializing &gt; 0) {                value = _PyObject_CallMethodIdObjArgs(interp-&gt;importlib,                                                &amp;PyId__lock_unlock_module, abs_name,                                                NULL);            }        }    }    else { /* 模块第一次加载 */        mod = _PyObject_CallMethodIdObjArgs(interp-&gt;importlib,                                            &amp;PyId__find_and_load, abs_name,                                            interp-&gt;import_func, NULL);    }    /* 处理from ... import ... 形式的导入 */    has_from = 0;    if (fromlist != NULL &amp;&amp; fromlist != Py_None) {        has_from = PyObject_IsTrue(fromlist);        if (has_from &lt; 0)            goto error;    }    if (!has_from) { /* 不是from ... 格式 */        Py_ssize_t len = PyUnicode_GET_LENGTH(name);        if (level == 0 || len &gt; 0) {            Py_ssize_t dot;            /* 查找是否包含&quot;.&quot;, 有则返回索引,否则返回-1 */            dot = PyUnicode_FindChar(name, &#39;.&#39;, 0, len, 1);            if (dot == -1) { /* */                final_mod = mod;                goto error;            }            if (level == 0) {                PyObject *front = PyUnicode_Substring(name, 0, dot);                if (front == NULL) {                    goto error;                }                final_mod = PyImport_ImportModuleLevelObject(front, NULL, NULL, NULL, 0);            }            else {                Py_ssize_t cut_off = len - dot;                Py_ssize_t abs_name_len = PyUnicode_GET_LENGTH(abs_name);                PyObject *to_return = PyUnicode_Substring(abs_name, 0,                                                        abs_name_len - cut_off);                if (to_return == NULL) {                    goto error;                }                final_mod = PyDict_GetItem(interp-&gt;modules, to_return);                Py_DECREF(to_return);                if (final_mod == NULL) {                    PyErr_Format(PyExc_KeyError,                                 &quot;%R not in sys.modules as expected&quot;,                                 to_return);                    goto error;                }                Py_INCREF(final_mod);            }        }        else {            final_mod = mod;            Py_INCREF(mod);        }    }    else {        final_mod = _PyObject_CallMethodIdObjArgs(interp-&gt;importlib,                                                  &amp;PyId__handle_fromlist, mod,                                                  fromlist, interp-&gt;import_func,                                                  NULL);    }  error:    if (final_mod == NULL)        remove_importlib_frames();    return final_mod;}</code></pre><p>在导入模块时, Python会先尝试从全局的<code>interp-&gt;modules</code>集合(即<code>sys.modules</code>)中获取模块. 如果模块缓存中存在, Python还会检查模块是否处于初始化状态中, 如果模块正在初始化(其它线程), 那么会调用<code>_lock_unlock_module</code>等待锁的释放(<code>import</code>动作需要加锁). </p><p>我们可以看到Python3中, <code>import</code>的实现是<code>importlib</code>. 比较特殊的是在Python内部, 通过文件<code>_freeze_importlib.c</code>将以Python实现的<code>importlib/_bootstrap.py</code>转换成了字节码序列的形式在内部执行.</p><pre><code class="c">const unsigned char _Py_M__importlib[] = {    99,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,    ...}</code></pre><p>和在<code>sys.modules</code>缓存中找到模块对应, 如果模块是第一次加载, 则会调用<code>_find_and_load</code>导入模块.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;import指令&quot;&gt;&lt;a href=&quot;#import指令&quot; class=&quot;headerlink&quot; title=&quot;import指令&quot;&gt;&lt;/a&gt;import指令&lt;/h2&gt;&lt;p&gt;&lt;code&gt;import&lt;/code&gt;有两种形式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;import ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;from ... import ...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们从简单的&lt;code&gt;import sys&lt;/code&gt;开始，看看背后都发生了什么：&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python源码阅读-类机制</title>
    <link href="http://shawnz.me/posts/75b3e8d4/"/>
    <id>http://shawnz.me/posts/75b3e8d4/</id>
    <published>2018-01-11T12:40:06.000Z</published>
    <updated>2018-03-10T06:20:54.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型模型"><a href="#类型模型" class="headerlink" title="类型模型"></a>类型模型</h2><p>在Python3中所有的类都是新式类，继承自<code>&lt;type &#39;object&#39;&gt;</code>，且默认的所有类对象都是<code>&lt;type &#39;type&#39;&gt;</code>的实例。(到这里你可能会疑惑“先有鸡还是先有蛋”)</p><p>在Python中它们的关系如下：</p><a id="more"></a><p><img src="/images/pyclassobject-1.png" alt=""></p><h2 id="类对象初始化"><a href="#类对象初始化" class="headerlink" title="类对象初始化"></a>类对象初始化</h2><p>在<code>pylifecycle.c</code>的<code>Py_Initialize()</code>中，Python内部先是会使用<code>_Py_ReadyTypes</code>完成类型系统的准备。类型体系的准备是以一个固定的顺序调用<code>PyType_Ready</code>初始化各种内置类型对象。</p><p>我们来看看<code>PyType_Ready</code>都做了哪些工作：</p><pre><code class="c">intPyType_Ready(PyTypeObject *type){    PyObject *dict, *bases;    PyTypeObject *base;    Py_ssize_t i, n;    /* [1].尝试获得type的tp_base指定基类，否则指定基类为`PyBaseObject_Type` */    base = type-&gt;tp_base;    if (base == NULL &amp;&amp; type != &amp;PyBaseObject_Type) {        base = type-&gt;tp_base = &amp;PyBaseObject_Type;        Py_INCREF(base);    }    /* 到现在为止，基类仍然为空的只能是PyBaseObject_Type */    /* [2].如果基类没有初始化，先初始化基类 */    if (base != NULL &amp;&amp; base-&gt;tp_dict == NULL) {        if (PyType_Ready(base) &lt; 0)            goto error;    }    /* [3].设置ob_type信息 */    if (Py_TYPE(type) == NULL &amp;&amp; base != NULL)        Py_TYPE(type) = Py_TYPE(base);    ...    /* [4].初始化tp_bases */    bases = type-&gt;tp_bases;    if (bases == NULL) {        if (base == NULL)            bases = PyTuple_New(0);        else            bases = PyTuple_Pack(1, base);        if (bases == NULL)            goto error;        type-&gt;tp_bases = bases;    }</code></pre><p>在初始化阶段，对于指定了<code>tp_base</code>的内置类型对象，它的基类就是指定的<code>tp_base</code>，否则Python会为所有类型对象设置基类为<code>PyBaseObject_Type</code>，也就我们说的<code>&lt;type &#39;object&#39;&gt;</code>，在这一步<code>PyBaseObject_Type</code>的基类可为空的：</p><pre><code class="python">&gt;&gt;&gt; object.__base__&gt;&gt;&gt; </code></pre><p>接下来是检查基类是否初始化完毕，如果没有就会先初始化基类(这里的检查条件是<code>tp_dict</code>是否为空，因为初始化的过程主要就是<code>tp_dict</code>的填充)。</p><p>有了基类对象，虚拟机会将所有没有指定<code>ob_type</code>的类，设置<code>ob_type</code>为基类的<code>ob_type</code>，这个<code>ob_type</code>就是我们说的<code>元类</code>。</p><p>到现在为止，也就有了所有类型对象的基类是<code>PyBaseObject_Type</code>(除了<code>PyBaseObject_Type</code>本身)，所有类型对象的<code>metaclass</code>就是<code>PyBaseObject_Type</code>的<code>metaclass</code>，而在<code>PyBaseObject_Type</code>的定义中，其<code>ob_type</code>域被设定为<code>PyType_Type</code>即<code>&lt;type &#39;type&#39;&gt;</code><br>。</p><p>进行到第[4]步，是对基类列表的初始化，对于<code>PyBaseObject_Type</code>来说，其基类为空，基类列表也为空。而其他类型对象，如果<code>tp_bases</code>为空，那么它的基类列表都包含它的基类。</p><p>接下就进了了初始化最关键的阶段：填充<code>tp_dict</code>：</p><pre><code class="c">.../* [5]. 初始化tp_dict */dict = type-&gt;tp_dict;if (dict == NULL) {    dict = PyDict_New();    if (dict == NULL)        goto error;    type-&gt;tp_dict = dict;}/* Add type-specific descriptors to tp_dict */if (add_operators(type) &lt; 0)    goto error;if (type-&gt;tp_methods != NULL) {    if (add_methods(type, type-&gt;tp_methods) &lt; 0)        goto error;}if (type-&gt;tp_members != NULL) {    if (add_members(type, type-&gt;tp_members) &lt; 0)        goto error;}...</code></pre><p>填充<code>tp_dict</code>这个过程十分的繁琐，它是通过<code>add_operators</code>、<code>add_methods</code>、<code>add_members</code>和<code>tp_getset</code>几个函数将方法名和函数指针添加到<code>tp_dict</code>中。具体是怎么关联的就设计到了<code>slot机制</code>。</p><h2 id="Slot机制"><a href="#Slot机制" class="headerlink" title="Slot机制"></a>Slot机制</h2><p><code>slot</code>可以视为表示<code>PyTypeObject</code>中定义的操作, 在一个操作对应一个slot。但一个<code>slot</code>不止包括一个函数指针，还有一些其他的信息，在Python内部是通过<code>slotdef</code>这个结构体实现的：</p><pre><code class="c">typedef struct wrapperbase slotdef;struct wrapperbase {    char *name; /* name 表示操作应该的名称，如“__add__” */    int offset; /* 表示操作的函数在PyTypeObject或PyHeapTypeObject中的偏移量 */    void *function; /* 指向一个称谓为slot function的函数指针 */    wrapperfunc wrapper;    char *doc;    int flags;    PyObject *name_strobj;};</code></pre><p>为了定义一个slot, Python提供了多个宏来定义, 其中最基本的有两个:</p><pre><code class="c">#define TPSLOT(NAME, SLOT, FUNCTION, WRAPPER, DOC) \    {NAME, offsetof(PyTypeObject, SLOT), (void *)(FUNCTION), WRAPPER, \     PyDoc_STR(DOC)}#define `ETSLOT`(NAME, SLOT, FUNCTION, WRAPPER, DOC) \    {NAME, offsetof(PyHeapTypeObject, SLOT), (void *)(FUNCTION), WRAPPER, \     PyDoc_STR(DOC)}</code></pre><p>可以看到这两个宏定义，有一个明显的区别：<code>TPSLOT</code>里面的偏移是在<code>PyTypeObject</code>上的偏移，而<code>ETSLOT</code>的偏移是在<code>PyHeapTypeObject</code>上。</p><p>这一点是因为在<code>PyTypeObject</code>上，有的操作，例如<code>nb_add</code>，其函数指针是存放在<code>PyNumberMethods</code>结构体中，在<code>PyTypeObject</code>中只有一个<code>tp_as_number</code>指针指向那个结构体。所以根本无法计算函数指针在<code>PyTypeObject</code>上的偏移量。所以Python引入了<code>PyHeapTypeObject</code>：</p><pre><code class="c">typedef struct _heaptypeobject {    PyTypeObject ht_type; /* 结构体的首部是一个PyTypeObject */    PyAsyncMethods as_async;    PyNumberMethods as_number;    PyMappingMethods as_mapping;    PySequenceMethods as_sequence;     PyBufferProcs as_buffer;    PyObject *ht_name, *ht_slots, *ht_qualname;    struct _dictkeysobject *ht_cached_keys;    /* here are optional user slots, followed by the members. */} PyHeapTypeObject;</code></pre><h2 id="Descriptor"><a href="#Descriptor" class="headerlink" title="Descriptor"></a>Descriptor</h2><p>然而<code>slot</code>并不是对象，它并不能放在<code>tp_dict</code>中，也不会调用(因为没有类型)，所以在<code>tp_dict</code>中与<code>__getitem__</code>对应只能是另外一个包装了<code>slot</code>的东西，在Pythono中称之为<code>descriptor</code>。</p><p>与<code>PyTypeObject</code>中操作对应的就是<code>PyWrapperDescrObject</code>，它里面包含一个<code>slot</code>：</p><pre><code class="c">typedef struct {    PyObject_HEAD    PyTypeObject *d_type;    PyObject *d_name;    PyObject *d_qualname;} PyDescrObject;#define PyDescr_COMMON PyDescrObject d_commontypedef struct {    PyDescr_COMMON; /* 所有descriptor都有PyDescr_COMMON部分 */    struct wrapperbase *d_base; /* 对应一个slot */    void *d_wrapped; /* 对应函数指针 */} PyWrapperDescrObject;</code></pre><p>这些<code>descriptor</code>通过<code>PyDescr_NewWrapper</code>创建:</p><pre><code class="c">PyObject *PyDescr_NewWrapper(PyTypeObject *type, struct wrapperbase *base, void *wrapped){    PyWrapperDescrObject *descr;    descr = (PyWrapperDescrObject *)descr_new(&amp;PyWrapperDescr_Type,                                             type, base-&gt;name);    if (descr != NULL) {        descr-&gt;d_base = base;        descr-&gt;d_wrapped = wrapped;    }    return (PyObject *)descr;}static PyDescrObject *descr_new(PyTypeObject *descrtype, PyTypeObject *type, const char *name){    PyDescrObject *descr;    descr = (PyDescrObject *)PyType_GenericAlloc(descrtype, 0);    if (descr != NULL) {        descr-&gt;d_type = type;        descr-&gt;d_name = PyUnicode_InternFromString(name);    }    return descr;}</code></pre><p>创建的<code>PyDescrObject</code>对象的<code>d_type</code>域被设置为参数<code>type</code>，而<code>d_wrapped</code>存放着最重要的信息：操作对应的函数指针。 比如对<code>PyList_Type</code>来说, 它的<code>tp_dict[&quot;__getitem__&quot;].d_wrapped</code>就是<code>&amp;mp_subscript</code>，而<code>slot</code>则被存放在<code>d_base</code>中。</p><p><code>PyWrapperDescrObject</code>对象的类型对象是<code>PyWrapperDescr_Type</code>，这个类型对象的<code>tp_call</code>域的函数指针指向<code>wrapperdescr_call</code>，Python在”调用“一个<code>descriptor</code>时，也就会调用<code>wrapperdescr_call</code>。</p><h2 id="建立联系"><a href="#建立联系" class="headerlink" title="建立联系"></a>建立联系</h2><p>在Python2中，<code>slotdefs</code>在初始化的过程<code>init_slotdefs</code>中，需要经历一次”快排“排好序，而在Python3中，<code>slotdefs</code>会以一种有序的顺序预先定义好，在<code>init_slotdefs</code>只会检查<code>slotdefs</code>里操作偏移量是递增的。</p><p>现在<code>slotdefs</code>已经准备好了，在<code>add_operators</code>中会基于每个<code>slot</code>建立一个<code>descriptor</code>，然后在<code>tp_dict</code>保存操作名到<code>descriptor</code>的关联：</p><pre><code class="c">static intadd_operators(PyTypeObject *type){    PyObject *dict = type-&gt;tp_dict;    slotdef *p;    PyObject *descr;    void **ptr;    init_slotdefs(); /* [1].初始化slotdefs，这个函数只会在第一次调用的时候生效 */    for (p = slotdefs; p-&gt;name; p++) {        if (p-&gt;wrapper == NULL) /* [2].如果slot没有指定wrapper，则不做处理 */            continue;        ptr = slotptr(type, p-&gt;offset); /* [3].获得slotdef对应的操作在PyTypeObject中的偏移量 */        if (!ptr || !*ptr)            continue;        if (PyDict_GetItem(dict, p-&gt;name_strobj))/* [4].如果tp_dict已存在同名操作名，则不作处理 */            continue;        if (*ptr == (void *)PyObject_HashNotImplemented) {            /* Classes may prevent the inheritance of the tp_hash               slot by storing PyObject_HashNotImplemented in it. Make it               visible as a None value for the __hash__ attribute. */            if (PyDict_SetItem(dict, p-&gt;name_strobj, Py_None) &lt; 0)                return -1;        }        else {            descr = PyDescr_NewWrapper(type, p, *ptr); /* [5].创建descriptor */            if (descr == NULL)                return -1;            /* [6].将(操作名，descriptor)放入tp_dict中 */             if (PyDict_SetItem(dict, p-&gt;name_strobj, descr) &lt; 0) {                 return -1;            }        }    }    if (type-&gt;tp_new != NULL) {        if (add_tp_new_wrapper(type) &lt; 0)            return -1;    }    return 0;}</code></pre><p>在<code>add_operators</code>中一切都很简单，直观，需要注意的一点是在[4]处，如果<code>tp_dict</code>已存在同名操作名，则不作处理，意味着如果相同的操作名对应多个<code>slot</code>，那么只有定义在前面的才会填充进<code>tp_dict</code>中。例如：</p><pre><code class="c">MPSLOT(&quot;__getitem__&quot;, mp_subscript, slot_mp_subscript, wrap_binaryfunc, &quot;__getitem__(...&quot;),SQSLOT(&quot;__getitem__&quot;, sq_item, slot_sq_item, wrap_sq_item, &quot;__getitem__($...&quot;),</code></pre><p>例如操作名<code>__getitem__</code>同时对应着两个操作，但是偏移量<code>mp_subscript</code>小于<code>sq_item</code>，前者会先被处理，虚拟机会将<code>slot_mp_subscript</code>和操作名<code>__getitem__</code>绑定。</p><p>在[3]处函数<code>slotptr</code>背后，通过这个函数可以找到<code>slot</code>到<code>slot</code>对应的操作的真实函数指针转换：</p><pre><code class="c">static void **slotptr(PyTypeObject *type, int ioffset){    char *ptr;    long offset = ioffset;    /* 在PyHeapTypeObject上从后往前计算指针偏移量 */    assert(offset &gt;= 0); /* 操作对应的函数指针偏移量必然在0~as_buffer之间 */    assert((size_t)offset &lt; offsetof(PyHeapTypeObject, as_buffer));    if ((size_t)offset &gt;= offsetof(PyHeapTypeObject, as_sequence)) {        ptr = (char *)type-&gt;tp_as_sequence;        offset -= offsetof(PyHeapTypeObject, as_sequence);    }    else if ((size_t)offset &gt;= offsetof(PyHeapTypeObject, as_mapping)) {        ptr = (char *)type-&gt;tp_as_mapping;        offset -= offsetof(PyHeapTypeObject, as_mapping);    }    else if ((size_t)offset &gt;= offsetof(PyHeapTypeObject, as_number)) {        ptr = (char *)type-&gt;tp_as_number;        offset -= offsetof(PyHeapTypeObject, as_number);    }    else if ((size_t)offset &gt;= offsetof(PyHeapTypeObject, as_async)) {        ptr = (char *)type-&gt;tp_as_async;        offset -= offsetof(PyHeapTypeObject, as_async);    }    else {        ptr = (char *)type; /* 偏移量是基于PyTypeObject的 */    }    if (ptr != NULL)        ptr += offset;    return (void **)ptr;}</code></pre><p>上面这种在<code>PyHeapTypeObject</code>结构体的<code>as_sequence</code>、<code>as_mapping</code>…到<code>type</code>几个域从后往前计算函数指针偏移量的方式，能够一次就保证找到真实的函数指针地址。</p><p>通过<code>add_operators</code>为<code>PyType_Type</code>添加一些操作后, 还会通过<code>add_methods</code>、<code>add_members</code>和<code>add_getsets</code>添加<code>tp_methods</code>, <code>tp_members</code>和<code>tp_getset</code>函数集。虽然和<code>add_operators</code>类似, 但添加的<code>descriptor</code>不是<code>PyWrapperDescrObject</code>, 而分别是<code>PyMethodDescrObject</code>, <code>PyMemberDescrObject</code>和<code>PyGetSetDescrObject</code>。</p><p><img src="/images/pyclassobject-2.png" alt=""></p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>我们应该知道，<code>__repr__</code>是一个特殊的<code>magic method</code>， 当执行<code>s = &quot;%r&quot; % A()</code>的时候， 最终会调用<code>A.tp_repr</code>。 如果假设 A 是 list 类型， 那么就应该调用<code>list_repr</code>这个函数， 然而实际并不是这样的， Python知道需要对这个方法进行特殊处理，最终执行我们重写的<code>__repr__</code>函数。</p><p>而Python之所以知道， 是因为<code>slot</code>， 有一条特殊的<code>TPSLOT(&quot;__repr__&quot;,tp_repr,slot_tp_repr...)</code>。虚拟机在初始化A的时候，会检查到A的<code>tp_dict</code>中是否有<code>__repr__</code>函数， 一旦找到，就会根据对应的<code>slot</code>顺藤摸瓜找到<code>tp_repr</code>， 并替换成<code>slot_tp_repr</code>， 所以后面实际执行的是<code>slot_tp_repr</code>。</p><p>这个函数内部会在对象上查找<code>__repr__</code>函数， 调用。</p><p>函数指针的修复，发生在<code>fixup_slot_dispatchers(PyTypeObject* type)</code>中，对于内置的class对象， 并不会进行这个操作，实际这个操作发生在自定义class对象的初始化期间。</p><h2 id="MRO"><a href="#MRO" class="headerlink" title="MRO"></a>MRO</h2><p><code>MRO</code>(<code>Method Resolution Order</code>，即方法解析顺序)。对于Python这种多继承语言来说，<code>MRO</code>显得比较复杂。</p><p>在这里不会讲到Python的<code>MRO</code>过去的算法，重点关注的是Python3中的<code>C3 MRO</code>。</p><p>在<code>PyType_Ready</code>填充完<code>tp_dict</code>后会通过<code>mro_internal</code>函数计算类型的<code>MRO</code>循序，由于这个过程十分繁琐，这里只针对关键代码进行了分析：</p><pre><code class="c">static PyObject *mro_implementation(PyTypeObject *type){    bases = type-&gt;tp_bases; /* type的基类列表 */    n = PyTuple_GET_SIZE(bases);     /* to_merge是一个列表的列表，前面n个元素是每个基类的mro列表，最后一个元素是基类列表 */    to_merge = PyList_New(n+1);     /* 将基类列表中每个基类的mro顺序放在to_merge中 */    for (i = 0; i &lt; n; i++) {        base = (PyTypeObject *)PyTuple_GET_ITEM(bases, i); /* 基类 */        base_mro_aslist = PySequence_List(base-&gt;tp_mro);  /* 基类的mro列表 */        PyList_SET_ITEM(to_merge, i, base_mro_aslist);    }    bases_aslist = PySequence_List(bases);    /* 重复基类检查 */    if (check_duplicates(bases_aslist) &lt; 0) {        goto out;    }    PyList_SET_ITEM(to_merge, n, bases_aslist); /* to_merge最后一个元素设为基类列表 */    result = Py_BuildValue(&quot;[O]&quot;, (PyObject *)type); /* merge结果保存在result里 */    res = pmerge(result, to_merge); /* 合并操作 */  out:    Py_DECREF(to_merge);    return result;}</code></pre><p>其核心的<code>pmerge</code>操作：</p><pre><code class="c">static intpmerge(PyObject *acc, PyObject* to_merge){    int res = 0;    Py_ssize_t i, j, to_merge_size, empty_cnt;    int *remain;    to_merge_size = PyList_GET_SIZE(to_merge);    /* remain数组存放了第i个基类mro列表下一次取得元素的索引 */    remain = (int *)PyMem_MALLOC(SIZEOF_INT*to_merge_size);    for (i = 0; i &lt; to_merge_size; i++)        remain[i] = 0; /* 初始化为0 */  again:    empty_cnt = 0;    for (i = 0; i &lt; to_merge_size; i++) {        PyObject *candidate; /* 候选类 */        PyObject *cur_list = PyList_GET_ITEM(to_merge, i); /* 基类的mro列表 */        if (remain[i] &gt;= PyList_GET_SIZE(cur_list)) { /* 该基类的mro列表已取完 */            empty_cnt++;            continue;        }        candidate = PyList_GET_ITEM(cur_list, remain[i]); /* 从基类mro列表中确定了候选类 */        for (j = 0; j &lt; to_merge_size; j++) { /* 如果在其他基类列表中的”尾部“包括了候选类，则跳过*/            PyObject *j_lst = PyList_GET_ITEM(to_merge, j);            if (tail_contains(j_lst, remain[j], candidate))                goto skip; /* continue outer loop */        }        res = PyList_Append(acc, candidate); /* 将候选类追加到acc中 */        for (j = 0; j &lt; to_merge_size; j++) {            PyObject *j_lst = PyList_GET_ITEM(to_merge, j);            if (remain[j] &lt; PyList_GET_SIZE(j_lst) &amp;&amp;                PyList_GET_ITEM(j_lst, remain[j]) == candidate) {                remain[j]++; /* 索引加一 */            }        }        goto again;      skip: ;    }    if (empty_cnt != to_merge_size) { /* 处理结束后，如果还有基类的mro列表没有处理完成，则失败 */        set_mro_error(to_merge, remain);        res = -1;    }  out:    PyMem_FREE(remain);    return res;}</code></pre><p>看完上述代码，总结其过程就是：</p><p>我们把类<code>C</code>的线性化MRO记为<code>L[C] = [C1, C2,…,CN]</code>。其中<code>C1</code>称为<code>L[C]</code>的“头”，其余元素<code>[C2,…,CN]</code>称为”尾“。如果一个类<code>C</code>继承自基类<code>B1、B2、……、BN</code>，那么我们可以根据以下两步计算出<code>L[C]</code>：</p><ul><li><code>L[object] = [object]</code></li><li><code>L[C(B1…BN)] = [C] + merge(L[B1]…L[BN], [B1]…[BN])</code></li></ul><p>这里的关键在于<code>merge</code>，其输入是一组列表，按照如下方式输出一个列表：</p><ol><li>检查第一个列表的头元素（如<code>L[B1]</code>的头），记作<code>H</code>。</li><li>若<code>H</code>未出现在其它列表的“尾部”，则将其输出，并将其从所有列表中删除(其实并不删除，只是记录索引位置，不过这里方便起见，可以理解为删除)，然后回到步骤1；否则，取出下一个列表的头部记作<code>H</code>，继续该步骤。</li><li>重复上述步骤，直至列表为空(对应上面所有mro列表处理完毕)，则算法结束；<br><br> 或者不能再找出可以输出的元素(结束了但是还有mro列表没有处理完)，说明无法构建继承关系，Python会抛出异常。</li></ol><h2 id="基类与子类加工"><a href="#基类与子类加工" class="headerlink" title="基类与子类加工"></a>基类与子类加工</h2><p>在确定好<code>mro</code>列表后，就已经知道了基类和子类的关系，在<code>PyType_Ready</code>的下一步只要就是从基类那里继承各种属性和操作：</p><pre><code class="c">inherit_special(type, type-&gt;tp_base);  /* Inherit special flags from dominant base */inherit_slots(type, (PyTypeObject *)b);  /* Initialize tp_dict properly */... /* All bases of statically allocated type should be statically allocated */... /* Sanity check for tp_free. */... /* Hack for tp_hash and __hash__ */...  /* Some more special stuff */add_subclass((PyTypeObject *)b, type) &lt; 0) /* Link into each base class&#39;s list of subclasses */... /* All done -- set the ready flag */</code></pre><p>到现在为止，<code>PyType_Ready</code>的工作总结起来就是：</p><ul><li>设置type信息和基类信息</li><li>填充tp_dict</li><li>确定mro列表</li><li>子类继承父类的操作</li><li>设置基类的子类列表tp_subclasses</li></ul><h2 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h2><p>我们以一个简单例子开始：</p><pre><code class="python">[class_a.py]class A:    name = &#39;Python&#39;    def __init__(self):        print(&quot;A.__init__&quot;)    def f(self):        print(&quot;A.f&quot;)    def g(self, value):        self.value = value        print(self.value)a = A()a.f()a.g(10)</code></pre><p>显然对于<code>class_a.py</code>源文件，经过编译后会得到四个<code>PyCodeObject</code>，它们的关系如下：</p><p><img src="/images/pyclassobject-3.png" alt=""></p><p>来看<code>class A</code>的创建过程：</p><pre><code class="python">[PyCodeObject for class_a.py]class A:0 LOAD_BUILD_CLASS2 LOAD_CONST               1 (&lt;code object A at 0x7f1445f840c0, file &quot;class_a.py&quot;, line 3&gt;)4 LOAD_CONST               2 (&#39;A&#39;)6 MAKE_FUNCTION            08 LOAD_CONST               2 (&#39;A&#39;)10 CALL_FUNCTION            212 STORE_NAME               1 (A)</code></pre><p>首先，我们可以看到的是一条指令<code>LOAD_BUILD_CLASS</code>，由这条指令的注释我们可以知道：这条指令将函数<code>builtins.__build_class__</code>压入了栈中，然后被之后的<code>CALL_FUNCTION</code>指令调用，构建一个类对象。</p><pre><code class="c">.. opcode:: LOAD_BUILD_CLASS   Pushes :func:`builtins.__build_class__` onto the stack.  It is later called   by :opcode:`CALL_FUNCTION` to construct a class.</code></pre><p>正如注释里所说的，在<code>LOAD_BUILD_CLASS</code>指令后面，虚拟机加载了类对应的<code>PyCodeObject</code>和函数名称<code>A</code>构建了一个函数并压入栈中，所以直到<code>CALL_FUNCTION</code>调用的时候，此时运行时栈的内存布局应该是下面这个样子的：</p><p><img src="/images/pyclassobject-4.png" alt=""></p><p>接下来就是<code>CALL_FUNCTION</code>指令的执行了，由于它的指令参数为<code>2</code>(代表两个函数参数)，所以调用的<code>func</code>应该是<code>__build_class__</code>，也就是<code>__build_class__(&lt;func A&gt;, &quot;A&quot;&gt;)</code>。</p><h2 id="build-class"><a href="#build-class" class="headerlink" title="build_class"></a><strong>build_class</strong></h2><p><code>__bulid_class__</code>的作用是通过一个函数对象创建类对象。它的的调用过程比较复杂，这里删除掉了一些源码(不影响阅读)：</p><pre><code class="c">static PyObject *builtin___build_class__(PyObject *self, PyObject *args, PyObject *kwds){    PyObject *func, *name, *bases, *mkw, *meta, *winner, *prep, *ns;    PyObject *cls = NULL, *cell = NULL;    Py_ssize_t nargs;    int isclass = 0;   /* initialize to prevent gcc warning */    nargs = PyTuple_GET_SIZE(args);    func = PyTuple_GET_ITEM(args, 0); /* 类的函数对象 */    name = PyTuple_GET_ITEM(args, 1); /* 类名 */    bases = PyTuple_GetSlice(args, 2, nargs); /* 如果有剩余参数的话，就作为基类 */    if (bases == NULL)        return NULL;    if (kwds == NULL) {        meta = NULL;        mkw = NULL;    }    else {        mkw = PyDict_Copy(kwds); /* 不修改传递进来的关键字参数 */        meta = _PyDict_GetItemId(mkw, &amp;PyId_metaclass); /* 尝试获取metaclass关键字参数 */        if (meta != NULL) {            isclass = PyType_Check(meta); /* 检查meta是不是类 */        }    }    if (meta == NULL) {        if (PyTuple_GET_SIZE(bases) == 0) { /* 如果没有基类，那么metaclass就是type */            meta = (PyObject *) (&amp;PyType_Type);        }        else { /* 否则元类就是第一个基类的元类 */            PyObject *base0 = PyTuple_GET_ITEM(bases, 0);            meta = (PyObject *) (base0-&gt;ob_type);        }        isclass = 1; /* 基类是一个类 */    }    if (isclass) {        /* 元类计算，会从所有元类中选出一个在继承关系上最底层的元类 */        winner = (PyObject *)_PyType_CalculateMetaclass((PyTypeObject *)meta, bases);        if (winner != meta) {            meta = winner;        }    }    /* 尝试调用元类的__prepare__方法，这个方法会返回一个字典作为类的dict */    prep = _PyObject_GetAttrId(meta, &amp;PyId___prepare__);    if (prep == NULL) {        if (PyErr_ExceptionMatches(PyExc_AttributeError)) {            PyErr_Clear();            ns = PyDict_New();        }        else {            return NULL;        }    }    else {        PyObject *pargs[2] = {name, bases};        ns = _PyObject_FastCallDict(prep, pargs, 2, mkw);    }    if (!PyMapping_Check(ns)) {        /* ns 必须是一个mapping类型 */        goto error;    }/* 将类的函数对象作为闭包调用 */    cell = PyEval_EvalCodeEx(PyFunction_GET_CODE(func), PyFunction_GET_GLOBALS(func), ns,                             NULL, 0, NULL, 0, NULL, 0, NULL,                             PyFunction_GET_CLOSURE(func));     if (cell != NULL) {        PyObject *margs[3] = {name, bases, ns}; /* 参宿包括类名，基类列表和类的locals命名空间 */        cls = _PyObject_FastCallDict(meta, margs, 3, mkw); /* 接下来就是调用元类的tp_call了 */        if (cls != NULL &amp;&amp; PyType_Check(cls) &amp;&amp; PyCell_Check(cell)) {            PyObject *cell_cls = PyCell_GET(cell);            if (cell_cls != cls) {                ...            }        }    }error:    return cls;}</code></pre><p>大致描述一下<code>__build_class__</code>创建类的过程为：</p><ol><li>获取<code>metaclass</code>：虚拟机会先检查是在在类定义的是否使用关键字参数<code>metaclass</code>自定义了元类，若没有那么元类就是<code>type</code>；</li><li>尝试获取并调用元类的<code>__prepare__</code>方法：通过这个可以得到一个<code>ns</code>字典，这里会存放类的动态元信息；</li><li>将类对应的<code>PyCodeObject</code>作为函数执行：所以在类的第一层定义的语句都会执行一次，这样<code>ns</code>作为<code>f_locals</code>函数定义，类变量都会存在这个命名空间中；</li><li>调用元类的<code>tp_call</code>创建类；</li></ol><h2 id="调用metaclass"><a href="#调用metaclass" class="headerlink" title="调用metaclass"></a>调用metaclass</h2><p>默认的元类是<code>PyTypeObject</code>，所以我们来到它的<code>tp_call</code>定义处：</p><pre><code class="c">static PyObject *type_call(PyTypeObject *type, PyObject *args, PyObject *kwds){    PyObject *obj;    obj = type-&gt;tp_new(type, args, kwds);    type = Py_TYPE(obj);    if (type-&gt;tp_init != NULL) {  /* 尝试调用类型的__init__方法，初始化类对象 */        int res = type-&gt;tp_init(obj, args, kwds);    }    return obj;}</code></pre><p><code>tp_call</code>函数中，传递的参数<code>type</code>是基类，而<code>args</code>中包括了类名，基类列表和命名空间。在内部，真正创建类对象的函数是<code>type</code>对象<code>type_new</code>，这个函数十分复杂，依照惯例只罗列部分关键源码：</p><pre><code class="c"></code></pre><h2 id="创建instance"><a href="#创建instance" class="headerlink" title="创建instance"></a>创建instance</h2><p>现在就可以调用<code>class</code>对象创建<code>instance</code>实例了：</p><pre><code class="python">a = A()# 14 LOAD_NAME                0 (A)# 16 CALL_FUNCTION            0# 18 STORE_NAME               1 (a)</code></pre><p>创建实例时，执行的是<code>CALL_FUNCTION</code>指令，我们知道这条指令会执行它对应的<code>PyType_Object</code>上定义的<code>tp_call</code>操作。这里class对象的<code>type</code>就是<code>PyType_Type</code>，而对应的<code>tp_call</code>操作中会调用<code>A.tp_new</code>创建示例。</p><p>在上一步<code>__build_class__</code>的过程中，class对象从<code>PyBaseObject_Type</code>那里继承了一些操作，其中就有<code>tp_new</code>。<code>PyBaseObject_Type</code>的<code>object_new</code>会调用<code>PyType_GenericAlloc</code>来为对象分配内存，其大小为：<br></p><pre><code class="c">#define PyObject_NEW_VAR(type, typeobj, n) \( (type *) PyObject_InitVar( \      (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),\      (typeobj), (n)) )const size_t size = _PyObject_VAR_SIZE(type, nitems+1);</code></pre><p>申请完内存后，回到<code>tp_call</code>中，创建完<code>instance</code>对像后，会尝试调用<code>tp_init</code>初始化对象：</p><pre><code class="c">type = Py_TYPE(obj);if (type-&gt;tp_init != NULL) {  /* 尝试调用类型的__init__方法，初始化类对象 */    int res = type-&gt;tp_init(obj, args, kwds);}</code></pre><p>还记得，在<code>slot</code>机制一节，讲过方法的重写，如果子类重写了<code>__init__</code>方法，那么在<code>fixup_slot_dispatchers</code>中，<code>tp_init</code>会指向<code>slotdefs</code>定义的<code>slot_tp_init</code>，而这个操作会在我们自定义的类及<code>mro</code>上搜索属性<code>__init__</code>对应的操作。</p><p>这里总结一下从创建类对象到创建实例对象这么一个过程：</p><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p><code>&gt;&gt;&gt;</code> <a href="http://lucumr.pocoo.org/2014/8/16/the-python-i-would-like-to-see/" target="_blank" rel="noopener">The Python I Would Like To See</a><br><br><code>&gt;&gt;&gt;</code> <a href="http://live.julik.nl/2012/08/messages-versus-slots" target="_blank" rel="noopener">The Python I Would Like To See</a><br><br><code>&gt;&gt;&gt;</code> <a href="http://hanjianwei.com/2013/07/25/python-mro/" target="_blank" rel="noopener">Python的方法解析顺序(MRO)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类型模型&quot;&gt;&lt;a href=&quot;#类型模型&quot; class=&quot;headerlink&quot; title=&quot;类型模型&quot;&gt;&lt;/a&gt;类型模型&lt;/h2&gt;&lt;p&gt;在Python3中所有的类都是新式类，继承自&lt;code&gt;&amp;lt;type &amp;#39;object&amp;#39;&amp;gt;&lt;/code&gt;，且默认的所有类对象都是&lt;code&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/code&gt;的实例。(到这里你可能会疑惑“先有鸡还是先有蛋”)&lt;/p&gt;
&lt;p&gt;在Python中它们的关系如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python源码阅读-函数机制</title>
    <link href="http://shawnz.me/posts/c981e5e/"/>
    <id>http://shawnz.me/posts/c981e5e/</id>
    <published>2018-01-11T12:39:59.000Z</published>
    <updated>2018-03-10T06:20:54.162Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Python中，函数是一等对象</p></blockquote><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><a id="more"></a><p>在Python中函数的声明和实现的字节码是在不同<code>PyCodeObject</code>中的，它以一种嵌套的形式存储在外层<code>PyCodeObject</code>的<code>co_const</code>常量表中：</p><pre><code class="python">def f():0 LOAD_CONST               0 (&lt;code object f at 0x7ff60e613ed0&gt;)2 LOAD_CONST               1 (&#39;f&#39;)4 MAKE_FUNCTION            06 STORE_NAME               0 (f)    print(&quot;func&quot;)f()8 LOAD_NAME                0 (f)10 CALL_FUNCTION            012 POP_TOP14 LOAD_CONST               2 (None)16 RETURN_VALUE</code></pre><p>我们说<code>PyCodeObject</code>是对源码编译的结果，存储的静态信息，例如：常量表(<code>co_const</code>)，符号表(<code>co_names</code>)以及字节码(<code>co_code</code>)。</p><p>而<code>PyFunctionObject</code>则是动态产生的，确切的说是在<code>def f()</code>语句的时候创建的，体现在字节码上就是：</p><pre><code class="python">0 LOAD_CONST               0 (&lt;code object f at 0x7ff60e613ed0&gt;)2 LOAD_CONST               1 (&#39;f&#39;)4 MAKE_FUNCTION            06 STORE_NAME               0 (f)</code></pre><p>这四条指令先后会：将函数<code>f</code>对应的<code>PyCodeObject</code>对象压入栈；把常量表中的<code>f</code>压入栈；构建函数对象<code>PyFunctionObject</code>；以及将键<code>f</code>和值<code>PyFunctionObject</code>存入命名空间(这里<code>f_locals</code>和<code>f_globals</code>是指向同一处命名空间)。</p><p>对于一段静态的代码块来说，它只会对应一个<code>PyCodeObject</code>，而可能会创建多个<code>PyFunctionObject</code>。</p><p>下面是<code>PyFunctionObject</code>的定义，可以看到函数对应的<code>PyCodeObject</code>会被设置为域<code>func_code</code>：</p><pre><code class="c">typedef struct {    PyObject_HEAD    PyObject *func_code;    /* A code object, the __code__ attribute */    PyObject *func_globals;    /* A dictionary (other mappings won&#39;t do) */    PyObject *func_defaults;    /* NULL or a tuple */    PyObject *func_kwdefaults;    /* NULL or a dict */    PyObject *func_closure;    /* NULL or a tuple of cell objects */    PyObject *func_doc;        /* The __doc__ attribute, can be anything */    PyObject *func_name;    /* The __name__ attribute, a string object */    PyObject *func_dict;    /* The __dict__ attribute, a dict or NULL */    PyObject *func_weakreflist;    /* List of weak references */    PyObject *func_module;    /* The __module__ attribute, can be anything */    PyObject *func_annotations;    /* Annotations, a dict or NULL */    PyObject *func_qualname;    /* The qualified name */} PyFunctionObject;</code></pre><p>创建函数对象的指令<code>MAKE_FUNCTION</code>，可以在<code>ceval.c</code>中找到对应的实现：</p><pre><code class="c">TARGET(MAKE_FUNCTION) {    PyObject *qualname = POP();    PyObject *codeobj = POP();    PyFunctionObject *func = (PyFunctionObject *)        PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname);    ...    PUSH((PyObject *)func);}</code></pre><p><code>MAKE_FUNCTION</code>指令首先会从运行时栈中弹出函数的限定名称<code>qualname</code>和函数对应的字节码对象<code>codeobj</code>，并将当前命名空间<code>f_globals</code>作为函数的全局命名空间来创建函数对象(具体的初始化过程这里先不深入)，最后压入运行时栈。</p><h2 id="无参函数调用"><a href="#无参函数调用" class="headerlink" title="无参函数调用"></a>无参函数调用</h2><p>创建完函数对象并存入命名空间中后，接下来就可以调用函数了。</p><p>我们从最简单的无参函数调用开始，<code>CALL_FUNCTION 0</code>：</p><pre><code class="c">TARGET(CALL_FUNCTION) {    PyObject **sp, *res;    PCALL(PCALL_ALL);    sp = stack_pointer;    res = call_function(&amp;sp, oparg, NULL);    stack_pointer = sp;    PUSH(res);    ...}</code></pre><p><code>CALL_FUNCTION</code>指令代码中，虚拟机只是保存了栈指针，以在函数调用过后恢复，并将函数调用的结果压入运行时栈。具体的实现在<code>call_function</code>中：</p><pre><code class="c">static PyObject *call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames){    PyObject **pfunc = (*pp_stack) - oparg - 1;  /* 获取函数对象 */    PyObject *func = *pfunc;    PyObject *x, *w;    Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames);    Py_ssize_t nargs = oparg - nkwargs; /* 参数处理 */    PyObject **stack;    if (PyCFunction_Check(func)) {          ...  /* CFucntion */    }    else {        if (PyMethod_Check(func) &amp;&amp; PyMethod_GET_SELF(func) != NULL) {            ... /* Method */        }        stack = (*pp_stack) - nargs - nkwargs;        if (PyFunction_Check(func)) {  /* Function */            x = fast_function(func, stack, nargs, kwnames);        }        ...    }}</code></pre><p><code>call_function</code>不光在函数调用的时候会使用，<code>CFunction</code>和<code>Method</code>也会调用这个方法。<code>call_function</code>首先要做的就是获取栈上的函数对象，也就是通过指令<code>CALL_FUNCTION</code>前一个指令<code>LOAD_NAME 0</code>压入运行时栈的。在这里指针<code>func</code>指向的是栈顶位置-1的地方(<code>(*pp_stack) - oparg - 1</code>)。</p><p>具体的参数处理我们先跳过，来看看<code>fast_function</code>是怎么调用函数的：</p><pre><code class="c">static PyObject *fast_function(PyObject *func, PyObject **stack,              Py_ssize_t nargs, PyObject *kwnames){    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);  /* code对象 */    PyObject *globals = PyFunction_GET_GLOBALS(func); /* globals命名空间 */    PyObject *argdefs = PyFunction_GET_DEFAULTS(func); /* 默认参数 */    PyObject *kwdefs, *closure, *name, *qualname;    PyObject **d;    Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames);    Py_ssize_t nd;    PCALL(PCALL_FUNCTION);    PCALL(PCALL_FAST_FUNCTION);    /* 一般函数的快速通道 */    if (co-&gt;co_kwonlyargcount == 0 &amp;&amp; nkwargs == 0 &amp;&amp;        co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))    {        if (argdefs == NULL &amp;&amp; co-&gt;co_argcount == nargs) {            /* 这是我们调用f()进入的地方 */            return _PyFunction_FastCall(co, stack, nargs, globals);        }        else if (nargs == 0 &amp;&amp; argdefs != NULL                 &amp;&amp; co-&gt;co_argcount == Py_SIZE(argdefs)) {            stack = &amp;PyTuple_GET_ITEM(argdefs, 0);            return _PyFunction_FastCall(co, stack, Py_SIZE(argdefs), globals);        }    }    kwdefs = PyFunction_GET_KW_DEFAULTS(func);    closure = PyFunction_GET_CLOSURE(func);    name = ((PyFunctionObject *)func) -&gt; func_name;    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;    if (argdefs != NULL) {        d = &amp;PyTuple_GET_ITEM(argdefs, 0);        nd = Py_SIZE(argdefs);    }    else {        d = NULL;        nd = 0;    }    return _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)NULL,                                    ...);}</code></pre><p>在<code>fast_function</code>做的大部分工作在参数处理上，而这里我们重点关注函数是怎么调用。当使用无参形式调用函数的时候，最终会进入<code>_PyFunction_FastCall</code>快速通道；其他的情况下，会使用<code>_PyEval_EvalCodeWithName</code>处理<code>code</code>对象。</p><p>在<code>_PyFunction_FastCall</code>中，虚拟机会创建一个新的<code>frame</code>，并递归调用<code>PyEval_EvalFrameEx</code>来处理栈桢。而在另一条路径<code>_PyEval_EvalCodeWithName</code>，我们知道虚拟机也会创建新的栈桢，最终也是调用<code>PyEval_EvalFrameEx</code>来处理。</p><p>所以函数的调用过程就是：创建新的栈桢，在新的栈桢中执行代码。在这个过程中<code>PyFunctionObject</code>只是起到打包和传递<code>code</code>对象以及<code>globals</code>的作用。</p><p>下面是<code>_PyFunction_FastCall</code>的实现：</p><pre><code class="c">static PyObject*_PyFunction_FastCall(PyCodeObject *co, PyObject **args, Py_ssize_t nargs,                     PyObject *globals){    PyFrameObject *f;    PyThreadState *tstate = PyThreadState_GET();    PyObject **fastlocals;    Py_ssize_t i;    PyObject *result;    PCALL(PCALL_FASTER_FUNCTION);    f = PyFrame_New(tstate, co, globals, NULL); /* 创建新的frame */    if (f == NULL) {        return NULL;    }    /* 处理 */    fastlocals = f-&gt;f_localsplus;    for (i = 0; i &lt; nargs; i++) {        Py_INCREF(*args);        fastlocals[i] = *args++;    }    result = PyEval_EvalFrameEx(f,0); /* 递归处理frame */    ++tstate-&gt;recursion_depth; /* 递归深度为什么在这里加？ */    Py_DECREF(f);    --tstate-&gt;recursion_depth;    return result;}</code></pre><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>上面已经分析过了函数调用的整体框架，现在让我们来加上参数传递机制。</p><p>在Python中函数的参数可以分为几类：</p><ul><li>位置参数：<code>f(a, b)</code>，其中<code>a</code>和<code>b</code>被称为位置参数；</li><li>关键字参数：<code>f(a, b, name=&quot;Python&quot;)</code>，其中<code>name</code>被称为关键字参数；</li><li>扩展位置参数：<code>f(a, b, *args)</code>，可以使用<code>*</code>收集剩余的位置参数；</li><li>扩展关键字参数：<code>f(a, b, **kwargs)</code>，可以使用<code>**</code>收集剩余的关键词参数；</li><li>仅限关键字参数：这是Python3中新引入的，<code>f(a, b, *list, c=None, **kwargs)</code>，仅限关键参数必须位于某个<code>*</code>参数或单个<code>*</code>后面，强制使用关键字参数传递。</li></ul><h2 id="位置参数函数调用"><a href="#位置参数函数调用" class="headerlink" title="位置参数函数调用"></a>位置参数函数调用</h2><p>我们使用一个简单的例子来分析，Python的位置参数的传递和函数调用：</p><pre><code class="python">def f(name, age):# 0 LOAD_CONST               0 (&lt;code object f at 0x7fbd0fe3bed0&gt;)# 2 LOAD_CONST               1 (&#39;f&#39;)# 4 MAKE_FUNCTION            0# 6 STORE_NAME               0 (f)    print(name, age)    # 0 LOAD_GLOBAL              0 (print)    # 2 LOAD_FAST                0 (name)    # 4 LOAD_FAST                1 (age)    # 6 CALL_FUNCTION            2    # 8 POP_TOP    # 10 LOAD_FAST                1 (age)    # 12 LOAD_CONST               1 (3)    # 14 INPLACE_ADD    # 16 STORE_FAST               1 (age)    # 18 LOAD_CONST               0 (None)    # 20 RETURN_VALUEf(&quot;Python&quot;, 5)# 8 LOAD_NAME                0 (f)# 10 LOAD_CONST               2 (&#39;Python&#39;)# 12 LOAD_CONST               5 (5)# 14 CALL_FUNCTION            2# 16 POP_TOP# 18 LOAD_CONST               4 (None)# 20 RETURN_VALUE</code></pre><p>和无参函数一样，首先是创建函数对象，在<code>CALL_FUNCTION</code>前会有三条<code>LOAD</code>指令，虚拟机会加载函数需要的参数压入运行时栈，入栈完成后运行时栈如下：</p><p><img src="/images/pyfunctionobject-1.png" alt=""></p><p>在<code>CALL_FUNCTION 2</code>指令中</p><pre><code class="c">TARGET(CALL_FUNCTION) {    res = call_function(&amp;sp, oparg, NULL);}static PyObject *call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames){    PyObject **pfunc = (*pp_stack) - oparg - 1;  /* 获取函数对象 */    Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames);    Py_ssize_t nargs = oparg - nkwargs; /* 参数处理 */    PyObject **stack;    ...    /* stack指针将指向第一个参数 */    stack = (*pp_stack) - nargs - nkwargs;    x = fast_function(func, stack, nargs, kwnames);</code></pre><p>可以发现<code>CALL_FUNCTION</code>指令在调用<code>call_function</code>方法时传递的参数<code>kwnames</code>是空的，这点和Python2不同，Python3中<code>CALL_FUNCTION</code>指令只会在以位置参数的方式调用函数时使用。</p><p>在这里的指令参数<code>oparg</code>为<code>2</code>，代表参数的个数。将栈顶指针减2减1就可以得到我们的<code>PyFunctionObject</code>对象的指针。在处理完参数后，<code>fast_function</code>最终会调用<code>_PyFunction_FastCall</code>进行处理。</p><pre><code class="c">static PyObject*_PyFunction_FastCall(PyCodeObject *co, PyObject **args, Py_ssize_t nargs,                     PyObject *globals){   ...   f = PyFrame_New(tstate, co, globals, NULL);    if (f == NULL) {        return NULL;    }    /* 新栈桢的localsplus域 */    fastlocals = f-&gt;f_localsplus;    /* 拷贝位置参数 */    for (i = 0; i &lt; nargs; i++) {        Py_INCREF(*args);        fastlocals[i] = *args++;    }    result = PyEval_EvalFrameEx(f,0);</code></pre><p>在创建好新的栈桢对象<code>f</code>后，虚拟机会将加载在当前运行时栈中的位置参数<code>Python</code>和<code>5</code>拷贝到新的栈桢的<code>f_localspuls</code>域，这个域里面也包括了栈桢的运行时栈。这时<code>f</code>的运行时栈还是空的，<code>f_localsplus</code>的内存布局如下：</p><p><img src="/images/pyfunctionobject-2.png" alt=""></p><p>现在，函数参数已经放在了<code>PyFrameObject</code>的<code>f_localsplus</code>域中，那么在函数执行的时候就可以访问和操作这两个参数了。实际上，虚拟机正是通过两条指令<code>LOAD_FAST</code>和<code>STORE_FAST</code>操作<code>f_localspuls</code>这片内存区域的，在<code>_PyEval_EvalFrameDefault</code>中我们可以看到这些操作定义</p><pre><code class="c">fastlocals = f-&gt;f_localsplus;  /* 将fastlocals设为f_localsplus域 */...#define GETLOCAL(i)     (fastlocals[i])#define SETLOCAL(i, value)      do { PyObject *tmp = GETLOCAL(i); \                                     GETLOCAL(i) = value; \                                     Py_XDECREF(tmp); } while (0)TARGET(LOAD_FAST) {  /* 将fastlocals中的对象压入运行时栈 */    PyObject *value = GETLOCAL(oparg);    Py_INCREF(value);    PUSH(value);    FAST_DISPATCH();}TARGET(STORE_FAST) { /* 从运行时栈弹出，并存回fastlocals */    PyObject *value = POP();    SETLOCAL(oparg, value);    FAST_DISPATCH();}</code></pre><p>这样通过位置参数的调用函数过程现在已经比较清晰了：Python会将位置参数值从左到右压入当前栈桢运行时栈，并使用指令<code>CALL_FUNCTION</code>调用函数，最终它会跳转到<code>_PyFunction_FastCall</code>方法中创建新的栈桢，并将运行时栈中的参数值依次存储在新的栈桢的<code>f_localsplus</code>域中，等待函数的执行。</p><p>而在函数执行的过程中，Python并没有使用通常的按名称查找的做法，而是通过一个索引(偏移位置)来访问<code>f_localspul</code>域中存储的参数值。这也就是<code>位置参数</code>的由来。</p><h2 id="默认参数函数调用"><a href="#默认参数函数调用" class="headerlink" title="默认参数函数调用"></a>默认参数函数调用</h2><p>在继续学习关键字参数之前，我们先看看Python是怎么处理默认参数的。我们猜默认参数应该是在<code>MAKE_FUNCTION</code>里处理的。果然，我们在这条指令的实现处发现了如下代码：</p><pre><code class="c">if (oparg &amp; 0x08) {func -&gt;func_closure = POP(); }if (oparg &amp; 0x04) {func-&gt;func_annotations = POP();}if (oparg &amp; 0x02) {func-&gt;func_kwdefaults = POP();}if (oparg &amp; 0x01) {func-&gt;func_defaults = POP();}</code></pre><p>这条指令的参数<code>oparg</code>采用“掩码”的形式实现，如果值为<code>1</code>那么，它会从运行时栈中弹出默认参数，并设为函数对象的<code>func_defaults</code>域。</p><p>这一点字节码可以证明，在压入<code>code</code>对象和名称<code>f</code>之前，有一条<code>LOAD_CONST</code>指令将<code>(&#39;Python&#39;, 3)</code>也一并压入了栈中：</p><pre><code class="python">def f(name=&quot;Python&quot;, age=3):# 0 LOAD_CONST               5 ((&#39;Python&#39;, 3)) # 2 LOAD_CONST               2 (&lt;code object f at 0x7f2e7f099ed0&gt;# 4 LOAD_CONST               3 (&#39;f&#39;)   # 6 MAKE_FUNCTION            1      passf()</code></pre><p>接下来的调用，依旧是<code>fast_function</code>函数。之前我们看见除了上面的正常无参函数调用外，还有一种情况就是函数调用的时候没有传递参数，但是所有参数都有默认值，这个时候虚拟机也会走<code>_PyFunction_FastCall</code>通道。</p><pre><code class="c">static PyObject *fast_function(PyObject *func, PyObject **stack,              Py_ssize_t nargs, PyObject *kwnames){    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);    ...    if (co-&gt;co_kwonlyargcount == 0 &amp;&amp; nkwargs == 0 &amp;&amp;            co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))        {   /* 正常无参函数调用 */            if (argdefs == NULL &amp;&amp; co-&gt;co_argcount == nargs) {                return _PyFunction_FastCall(co, stack, nargs, globals);            } /* 函数调用没有给参数，但是所有参数都有默认参数值 */            else if (nargs == 0 &amp;&amp; argdefs != NULL                    &amp;&amp; co-&gt;co_argcount == Py_SIZE(argdefs)) {                stack = &amp;PyTuple_GET_ITEM(argdefs, 0);  /* 栈指针指向func_defaults第一个元素 */                return _PyFunction_FastCall(co, stack, Py_SIZE(argdefs), globals);            }        }}</code></pre><p>到现在应该很明显了，默认参数会在执行函数声明语句的时候，存储在函数对象的<code>func_defaults</code>域，在函数调用的时候使用宏定义<code>PyFunction_GET_DEFAULTS</code>获取这些参数值，并让栈指针指向它。接下来在<code>_PyFunction_FastCall</code>依然会通过<code>*arg++</code>设置好<code>f_localsplus</code>域。</p><pre><code class="c">#define PyFunction_GET_DEFAULTS(func) \    (((PyFunctionObject *)func) -&gt; func_defaults)</code></pre><h2 id="关键词参数函数调用"><a href="#关键词参数函数调用" class="headerlink" title="关键词参数函数调用"></a>关键词参数函数调用</h2><p>Python3中带关键词参数的函数调用指令不再是<code>CALL_FUNCTION</code>了，而是<code>CALL_FUNCTION_KW</code>，还是上一个例子，不过这里在调用函数的时候稍作修改，我们可以看到：</p><pre><code class="python">f(&quot;Python&quot;, age=3)# 8 LOAD_NAME                0 (f) # 10 LOAD_CONST               2 (&#39;Python&#39;)       # 12 LOAD_CONST               3 (3)       # 14 LOAD_CONST               4 ((&#39;age&#39;,)) # 16 CALL_FUNCTION_KW         2    # ...`</code></pre><p>其他地方和使用位置参数调用函数一样，这里的<code>CALL_FUNTION_KW 2</code>之前多做的一项工作就是把常量表中的符号<code>age</code>，压入运行时栈，来到<code>CALL_FUNTION_KW</code>指令的实现处：</p><pre><code class="c">TARGET(CALL_FUNCTION_KW) {    PyObject **sp, *res, *names;    names = POP();  /* 弹出关键字参数名称元组 */    PCALL(PCALL_ALL);    sp = stack_pointer;    res = call_function(&amp;sp, oparg, names);    ...}</code></pre><p>和<code>CALL_FUNCTION</code>没什么两样，不过是从运行时栈中弹出了最后压入的关键字参数名称。从它只会调用一次<code>POP()</code>，可以知道这些名称是以一个元组形式一起压入栈中，事实上也恰恰如此：<code>((&#39;age&#39;,))</code>。</p><p>依旧还是<code>call_function</code>函数，不过现在我们有了<code>knames</code>：</p><pre><code class="c">static PyObject *call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames){    PyObject **pfunc = (*pp_stack) - oparg - 1;    PyObject *func = *pfunc;    Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames);    Py_ssize_t nargs = oparg - nkwargs;</code></pre><p>现在我们对这些参数处理有了更进一步的认识：python在传递参数的时候，无论是位置参数还是关键字参数，都会将参数值先压入运行时栈中，对于关键次参数还用<code>kwnames</code>传递关键字参数名称，这样一来虚拟机就可以把这些名称和关键字参数值一一对应起来(隐性要求就是位置参数在前)。</p><p>不过这样一来在<code>fast_function</code>中，就不会走<code>_PyFunction_FastCall</code>这条通道了：</p><pre><code class="c">static PyObject *fast_function(PyObject *func, PyObject **stack,              Py_ssize_t nargs, PyObject *kwnames){    if (co-&gt;co_kwonlyargcount == 0 &amp;&amp; nkwargs == 0 &amp;&amp;        co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE))    {        /* 关键字参数就不会走这条通道了 */        return _PyFunction_FastCall(co, stack, Py_SIZE(argdefs), globals);    }    kwdefs = PyFunction_GET_KW_DEFAULTS(func); /* 仅限关键字参数默认值 */    closure = PyFunction_GET_CL OSURE(func);  /* 闭包 */    name = ((PyFunctionObject*)func) -&gt; func_name;    qualname = ((PyFunctionObject *)func) -&gt; func_qualname;    if (argdefs != NULL) {        d = &amp;PyTuple_GET_ITEM(argdefs, 0); /* 熟悉的默认参数值 */        nd = Py_SIZE(argdefs); /* 默认值个数 */    }    else {        d = NULL;        nd = 0;    }    return _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)NULL,            stack, nargs, /* 位置参数 */            nkwargs ? &amp;PyTuple_GET_ITEM(kwnames, 0) : NULL, /* 关键字参数名称*/            stack + nargs, /* 关键字参数值 */            nkwargs, 1, /* 关键字参数个数以及step */            d, (int)nd, kwdefs, /* 位置参数默认值， 仅限关键字参数默认值 */            closure, name, qualname); /* 函数信息 */</code></pre><p>经过这一步，我们可以得到大部分的和关键字参数相关的信息，至于<code>_PyEval_EvalCodeWithName</code>具体是怎么处理这些参数的先放在一旁，继续看看扩展参数机制。</p><h2 id="可变参数调用"><a href="#可变参数调用" class="headerlink" title="可变参数调用"></a>可变参数调用</h2><p>有几种不同的形式通过可变位置参数来调用函数：</p><pre><code class="python">f(*b)# 22 LOAD_NAME                2 (b)   # 24 CALL_FUNCTION_EX         0      f(a, *b)# 22 LOAD_NAME                1 (a)# 24 BUILD_TUPLE              1  # 26 LOAD_NAME                2 (b)    # 28 BUILD_TUPLE_UNPACK_WITH_CALL     2       # 30 CALL_FUNCTION_EX         0   f(*b, a)# 22 LOAD_NAME                2 (b) # 24 LOAD_NAME                1 (a)# 26 BUILD_TUPLE              1       # 28 BUILD_TUPLE_UNPACK_WITH_CALL     2         # 30 CALL_FUNCTION_EX         0   f(a, *b, c)# 22 LOAD_NAME                1 (a)      # 24 BUILD_TUPLE              1   # 26 LOAD_NAME                2 (b)   # 28 LOAD_NAME                3 (c)   # 30 BUILD_TUPLE              1 # 32 BUILD_TUPLE_UNPACK_WITH_CALL     3   # 34 CALL_FUNCTION_EX         0      </code></pre><p>这几种方式的字节码大同小异，主要设计两个指令<code>BUILD_TUPLE</code>和<code>BUILD_TUPLE_UNPACK_WITH_CALL</code>，我们来看看这两条指令都是做什么用的(省略了部分实现)：</p><pre><code class="c">/* 从栈顶中弹出oparg个元素，来构建一个元组并压入栈中 */TARGET(BUILD_TUPLE) {    PyObject *tup = PyTuple_New(oparg);    while (--oparg &gt;= 0) {        PyObject *item = POP();        PyTuple_SET_ITEM(tup, oparg, item);    }    PUSH(tup);}TARGET(BUILD_TUPLE_UNPACK_WITH_CALL)TARGET(BUILD_TUPLE_UNPACK)TARGET(BUILD_LIST_UNPACK) {    int convert_to_tuple = opcode != BUILD_LIST_UNPACK;    Py_ssize_t i;    PyObject *sum = PyList_New(0);    PyObject *return_value;    for (i = oparg; i &gt; 0; i--) {        PyObject *none_val;        none_val = _PyList_Extend((PyListObject *)sum, PEEK(i)); /* 将多个列表合并成一个 */        /* PEEK()的定义        define PEEK(n)           (stack_pointer[-(n)])        */    }    if (convert_to_tuple) {        return_value = PyList_AsTuple(sum);    }    else {        return_value = sum;    }    while (oparg--)        Py_DECREF(POP()); /* 弹出栈上的元素 */    PUSH(return_value); /* 将构建的元组或列表压栈 */}</code></pre><p>结合<code>BUILD_TUPLE</code>和<code>BUILD_TUPLE_UNPACK_WITH_CALL</code>的定义，我们知道无论以什么样的顺序使用可变参数，最终Python需要做的就是将它们打包成一个元组压入运行时栈中</p><p>和可变位置参数相似，可变关键字参数也有<code>BUILD_MAP</code>和<code>BUILD_MAP_UNPACK_WITH_CALL</code>，它们达到的效果和前者一样，会将多个关键字参数和<code>**</code>参数打包成一个字典压入栈中。</p><p>最后可变参数的处理函数指令都是<code>CALL_FUNCTION_EX</code>(只不过带可变关键字参数的会指令参数为<code>1</code>)。</p><p>在下面的<code>CALL_FUNCTION_EX</code>中，我省略掉了大部分的异常处理和引用处理代码:</p><pre><code class="c">TARGET(CALL_FUNCTION_EX) {    PyObject *func, *callargs, *kwargs = NULL, *result;    if (oparg &amp; 0x01) {        kwargs = POP();    }    callargs = POP();    func = TOP();    result = do_call_core(func, callargs, kwargs);    SET_TOP(result);    DISPATCH();}</code></pre><p>可以看到逻辑还是很清晰的：如果指令参数为1，那么会先从栈顶弹出关键字参数字典，然后弹出位置参数元组和取得函数对象，最后调用<code>do_call_core</code>执行函数。</p><p>在<code>do_call_core</code>中，如果<code>func</code>是函数的话，那么最终执行的<code>PyObject_Call(func, callargs, kwdict);</code>，也就是我们的<code>PyFunction_Type</code>上定义的<code>function_call</code>函数。</p><p>在<code>function_call</code>中：</p><pre><code class="c">static PyObject *function_call(PyObject *func, PyObject *arg, PyObject *kw){    PyObject *result;    PyObject *argdefs;    PyObject *kwtuple = NULL;    PyObject **d, **k;    Py_ssize_t nk, nd;    argdefs = PyFunction_GET_DEFAULTS(func); /* 获取默认参数 */    if (argdefs != NULL &amp;&amp; PyTuple_Check(argdefs)) {        d = &amp;PyTuple_GET_ITEM((PyTupleObject *)argdefs, 0); /* 指向默认参数起始地址 */        nd = PyTuple_GET_SIZE(argdefs); /* 默认参数个数 */    }    else {        d = NULL;        nd = 0;    }    if (kw != NULL &amp;&amp; PyDict_Check(kw)) {        Py_ssize_t pos, i;        nk = PyDict_Size(kw);        kwtuple = PyTuple_New(2*nk);        if (kwtuple == NULL)            return NULL;        k = &amp;PyTuple_GET_ITEM(kwtuple, 0); /* 将关键字参数字典转换成元组 */        pos = i = 0;        while (PyDict_Next(kw, &amp;pos, &amp;k[i], &amp;k[i+1])) { /* 对k里面的元素初始化 */            Py_INCREF(k[i]);            Py_INCREF(k[i+1]);            i += 2;        } /* 最终k是参数名称和参数值交叉形式的元组 */        nk = i/2;  /* 关键字参数个数 */    }    else {        k = NULL;        nk = 0;    }    result = PyEval_EvalCodeEx(        PyFunction_GET_CODE(func),        PyFunction_GET_GLOBALS(func), (PyObject *)NULL,        &amp;PyTuple_GET_ITEM(arg, 0), PyTuple_GET_SIZE(arg),        k, nk, d, nd,        PyFunction_GET_KW_DEFAULTS(func),        PyFunction_GET_CLOSURE(func));    Py_XDECREF(kwtuple);    return result;}</code></pre><p>在这个函数里面，Python获取了各种函数相关的信息，并调用<code>PyEval_EvalCodeEx</code>。</p><p>比较有趣的是，这里关键字参数和指令<code>CALL_FUNCTION_KW</code>中的不一样，之前的关键字参数的名称和值是分开的，而这里以一种名称和值交叉形式的元组打包在一起。所以在<code>PyEval_EvalCodeEx</code>中，需要进一步加工：</p><pre><code class="c">return _PyEval_EvalCodeWithName(_co, globals, locals,                                args, argcount,                                kws, kws != NULL ? kws + 1 : NULL, /* 名称和值是相邻的 */                                kwcount, 2, /* step的作用指导虚拟机怎么查找下一个名称和值 */                                defs, defcount,                                kwdefs, closure,                                NULL, NULL);</code></pre><p>殊途同归，最终还是到了<code>_PyEval_EvalCodeWithName</code>，所以在Python中不管函数是以什么样的方式调用(其实不包括单纯的位置参数调用方式:))，最终都会走到<code>_PyEval_EvalCodeWithName</code>这里。这也是函数处理的一个核心函数，它里面包含了<code>闭包</code>、<code>生成器</code>和<code>协程</code>等的处理。</p><h2 id="PyEval-EvalCodeWithName"><a href="#PyEval-EvalCodeWithName" class="headerlink" title="_PyEval_EvalCodeWithName"></a>_PyEval_EvalCodeWithName</h2><p>在看这个函数的时候，我是有点慌的。。。</p><pre><code class="c">/* This is gonna seem *real weird*, but if you put some other code between   PyEval_EvalFrame() and PyEval_EvalCodeEx() you will need to adjust   the test in the if statements in Misc/gdbinit (pystack and pystackv). */static PyObject *_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals,           PyObject **args, Py_ssize_t argcount, /* 位置参数信息 */           PyObject **kwnames, PyObject **kwargs, /* 关键字参数信息 */           Py_ssize_t kwcount, int kwstep,  /* 关键字参数信息 */           PyObject **defs, Py_ssize_t defcount, /* 默认参数信息 */           PyObject *kwdefs, PyObject *closure, /* 仅限关键字信息和闭包 */           PyObject *name, PyObject *qualname) /* 名称 */{    PyCodeObject* co = (PyCodeObject*)_co;    PyFrameObject *f;    PyObject *retval = NULL;    PyObject **fastlocals, **freevars;    PyThreadState *tstate;    PyObject *x, *u;    /* 从code中获取签名的参数总数=位置参数个数+仅限关键字参数个数 */    const Py_ssize_t total_args = co-&gt;co_argcount + co-&gt;co_kwonlyargcount;     Py_ssize_t i, n;    PyObject *kwdict;    /* 创建新的栈桢 */    tstate = PyThreadState_GET();    f = PyFrame_New(tstate, co, globals, locals);    /* localspuls域 */    fastlocals = f-&gt;f_localsplus;    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;    /* 有可变关键字参数，则为关键字参数创建一个字典 (**kwags) */    if (co-&gt;co_flags &amp; CO_VARKEYWORDS) {        kwdict = PyDict_New();        i = total_args; /* i为签名中已知的位置参数和仅限关键字参数个数 */        if (co-&gt;co_flags &amp; CO_VARARGS) { /* 有可变位置参数，则为可变参数预留一个空槽 */            i++;        }        SETLOCAL(i, kwdict); /* 将可变关键字参数字典设置在localsplus域 */    }    else {        kwdict = NULL;    }    /* 调用时的位置参数个数大于签名里的位置参数个数 */    /* Copy positional arguments into local variables */    if (argcount &gt; co-&gt;co_argcount) {        n = co-&gt;co_argcount; /* n为签名中的位置参数个数 */    }    else {        n = argcount;    }    for (i = 0; i &lt; n; i++) { /* 将前n个位置参数设置在localsplus域 */        x = args[i];        Py_INCREF(x);        SETLOCAL(i, x); /* 显然位置参数在localsplus域最前面 */    }    /* 把调用时多余的位置参数打包成 *args元组 */    if (co-&gt;co_flags &amp; CO_VARARGS) {        u = PyTuple_New(argcount - n);        SETLOCAL(total_args, u); /* 把u设置在位置参数+仅限关键字参数之后 */        for (i = n; i &lt; argcount; i++) {            x = args[i];            Py_INCREF(x);            PyTuple_SET_ITEM(u, i-n, x); /* 可变参数元组初始化值 */        }    }    /* 将关键字参数作为两个平行数组处理 */    kwcount *= kwstep; /* 乘以step，正确处理kwargs元组中的实际个数 */    for (i = 0; i &lt; kwcount; i += kwstep) {        PyObject **co_varnames;        PyObject *keyword = kwnames[i]; /* 以正确的step取得关键字参数名称 */        PyObject *value = kwargs[i]; /* 以正确的step取得关键字参数名称 */        Py_ssize_t j;        /* Speed hack: do raw pointer compares. As names are           normally interned this should almost always hit. */        /* 快速通道：在函数变量名表中查找是否出现关键字参数名称keyword */        co_varnames = ((PyTupleObject *)(co-&gt;co_varnames))-&gt;ob_item;        for (j = 0; j &lt; total_args; j++) {            PyObject *name = co_varnames[j];            if (name == keyword) {                goto kw_found;            }        }        /* 慢速通道：在函数变量名表中查找是否出现关键字参数名称keyword */        for (j = 0; j &lt; total_args; j++) {            PyObject *name = co_varnames[j];            int cmp = PyObject_RichCompareBool( keyword, name, Py_EQ);            if (cmp &gt; 0) {                goto kw_found;            }            else if (cmp &lt; 0) {                goto fail;            }        }        /* 如果没有找到keyword名称，且函数不允许可变关键字参数，那么报错 */        if (j &gt;= total_args &amp;&amp; kwdict == NULL) {            PyErr_Format(PyExc_TypeError,                         &quot;%U() got an unexpected keyword argument &#39;%S&#39;&quot;,                         co-&gt;co_name, keyword);            goto fail;        }        /* 如果允许可变关键字参数，且在函数变量名称表没有找到keyword，        则将关键字参数设置在可变关键字参数字典中 */        if (PyDict_SetItem(kwdict, keyword, value) == -1) {            goto fail;        }        continue;      kw_found:        /* 在名称表中位置j找到了变量名称，但是已经通过位置参数设置好了，那么会产生冲突报错 */        if (GETLOCAL(j) != NULL) {            PyErr_Format(PyExc_TypeError,                         &quot;%U() got multiple values for argument &#39;%S&#39;&quot;,                         co-&gt;co_name, keyword);            goto fail;        }        Py_INCREF(value);        /* 在localsplus相应位置设置好关键字参数 */        SETLOCAL(j, value);    }    /* 位置参数个数大于形参个数 */    if (argcount &gt; co-&gt;co_argcount &amp;&amp; !(co-&gt;co_flags &amp; CO_VARARGS)) {        too_many_positional(co, argcount, defcount, fastlocals);        goto fail;    }    /* 位置参数给少了，需要使用默认参数 */    if (argcount &lt; co-&gt;co_argcount) {        Py_ssize_t m = co-&gt;co_argcount - defcount;        Py_ssize_t missing = 0;        for (i = argcount; i &lt; m; i++) {            if (GETLOCAL(i) == NULL) {                missing++;            }        }        if (missing) {            missing_arguments(co, missing, defcount, fastlocals);            goto fail;        }        if (n &gt; m)            i = n - m;        else            i = 0;        /* 对于剩余没有给参数值的参数，使用默认位置参数值 */        for (; i &lt; defcount; i++) {            if (GETLOCAL(m+i) == NULL) {                PyObject *def = defs[i];                Py_INCREF(def);                SETLOCAL(m+i, def);            }        }    }    /* 对缺失的关键字参数，使用默认关键字参数值 */    if (co-&gt;co_kwonlyargcount &gt; 0) {        Py_ssize_t missing = 0;        for (i = co-&gt;co_argcount; i &lt; total_args; i++) {            PyObject *name;            if (GETLOCAL(i) != NULL)                continue;            name = PyTuple_GET_ITEM(co-&gt;co_varnames, i);            if (kwdefs != NULL) {                PyObject *def = PyDict_GetItem(kwdefs, name);                if (def) {                    Py_INCREF(def);                    SETLOCAL(i, def);                    continue;                }            }            missing++;        }        if (missing) {            missing_arguments(co, missing, -1, fastlocals);            goto fail;        }    }    /* Allocate and initialize storage for cell vars, and copy free       vars into frame. */    for (i = 0; i &lt; PyTuple_GET_SIZE(co-&gt;co_cellvars); ++i) {        PyObject *c;        int arg;        /* Possibly account for the cell variable being an argument. */        if (co-&gt;co_cell2arg != NULL &amp;&amp;            (arg = co-&gt;co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) {            c = PyCell_New(GETLOCAL(arg));            /* Clear the local copy. */            SETLOCAL(arg, NULL);        }        else {            c = PyCell_New(NULL);        }        if (c == NULL)            goto fail;        SETLOCAL(co-&gt;co_nlocals + i, c);    }    /* Copy closure variables to free variables */    for (i = 0; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) {        PyObject *o = PyTuple_GET_ITEM(closure, i);        Py_INCREF(o);        freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o;    }    /* Handle generator/coroutine/asynchronous generator */    if (co-&gt;co_flags &amp; (CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR)) {        PyObject *gen;        PyObject *coro_wrapper = tstate-&gt;coroutine_wrapper;        int is_coro = co-&gt;co_flags &amp; CO_COROUTINE;        if (is_coro &amp;&amp; tstate-&gt;in_coroutine_wrapper) {            assert(coro_wrapper != NULL);            PyErr_Format(PyExc_RuntimeError,                         &quot;coroutine wrapper %.200R attempted &quot;                         &quot;to recursively wrap %.200R&quot;,                         coro_wrapper,                         co);            goto fail;        }        /* Don&#39;t need to keep the reference to f_back, it will be set         * when the generator is resumed. */        Py_CLEAR(f-&gt;f_back);        PCALL(PCALL_GENERATOR);        /* Create a new generator that owns the ready to run frame         * and return that as the value. */        if (is_coro) {            gen = PyCoro_New(f, name, qualname);        } else if (co-&gt;co_flags &amp; CO_ASYNC_GENERATOR) {            gen = PyAsyncGen_New(f, name, qualname);        } else {            gen = PyGen_NewWithQualName(f, name, qualname);        }        if (gen == NULL)            return NULL;        if (is_coro &amp;&amp; coro_wrapper != NULL) {            PyObject *wrapped;            tstate-&gt;in_coroutine_wrapper = 1;            wrapped = PyObject_CallFunction(coro_wrapper, &quot;N&quot;, gen);            tstate-&gt;in_coroutine_wrapper = 0;            return wrapped;        }        return gen;    }    retval = PyEval_EvalFrameEx(f,0);fail: /* Jump here from prelude on failure */    /* decref&#39;ing the frame can cause __del__ methods to get invoked,       which can call back into Python.  While we&#39;re done with the       current Python frame (f), the associated C stack is still in use,       so recursion_depth must be boosted for the duration.    */    assert(tstate != NULL);    ++tstate-&gt;recursion_depth;    Py_DECREF(f);    --tstate-&gt;recursion_depth;    return retval;}</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>名字空间与函数捆绑后的结果被称为一个闭包(closure)。</p><p>Python闭包的实现和<code>PyCodeObject</code>的两个属性有关：</p><ul><li><code>co_cellvars</code>：通常是一个元组，保存嵌套作用域中使用的变量名集合；</li><li><code>co_freevars</code>：通常是一个元组，保存使用了的外层作用域中的变量名集合。</li></ul><p>另外在创建栈桢对象<code>PyFrameObject</code>时也有一个属性和闭包相关，<code>f_localsplus</code>维护的那块内存大小：<br><br><code>extras=code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees</code><br><br>对应着：运行时栈，局部变量，cell对象和free对象。</p><p>我们来看一个简单的例子：</p><pre><code class="python">def get_func():# 0 LOAD_CONST               0 (&lt;code object get_func&gt;)# 2 LOAD_CONST               1 (&#39;get_func&#39;)# 4 MAKE_FUNCTION            0# 6 STORE_NAME               0 (get_func)    value = &quot;value&quot;    # 0 LOAD_CONST               1 (&#39;value&#39;)    # 2 STORE_DEREF              0 (value)    def inner_func():    # 4 LOAD_CLOSURE             0 (value)    # 6 BUILD_TUPLE              1    # 8 LOAD_CONST               2 (&lt;code object inner_func&gt;)    # 10 LOAD_CONST               3 (&#39;get_func.&lt;locals&gt;.inner_func&#39;)    # 12 MAKE_FUNCTION            8    # 14 STORE_FAST               0 (inner_func)        print(value)        # 0 LOAD_GLOBAL              0 (print)        # 2 LOAD_DEREF               0 (value)        # 4 CALL_FUNCTION            1        # 6 POP_TOP        # 8 LOAD_CONST               0 (None)        # 10 RETURN_VALUE    return inner_func    # 16 LOAD_FAST                0 (inner_func)    # 18 RETURN_VALUEshow_value = get_func()show_value()# 14 LOAD_NAME                1 (show_value)# 16 CALL_FUNCTION            0# 18 POP_TOP# 20 LOAD_CONST               2 (None)# 22 RETURN_VALUE</code></pre><p>我们从<code>CALL_FUNCTION</code>指令开始，闭包就是从这里还是处理的：</p><pre><code class="c">for (i = 0; i &lt; PyTuple_GET_SIZE(co-&gt;co_cellvars); ++i) {    PyObject *c;    int arg;    /* Possibly account for the cell variable being an argument. */    if (co-&gt;co_cell2arg != NULL &amp;&amp;        (arg = co-&gt;co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) {        c = PyCell_New(GETLOCAL(arg));        SETLOCAL(arg, NULL);    }    else {        c = PyCell_New(NULL);    }    if (c == NULL)        goto fail;    SETLOCAL(co-&gt;co_nlocals + i, c); /* 存放cell对象在locals后 */}</code></pre><p>对于闭包的静态信息，经过编译后存放在<code>PyCodeObject</code>的<code>co_cellvars</code>和<code>co_freevars</code>中，而在创建新的栈桢的时候需要通过这些静态信息，创建<code>cell</code>保存到<code>f_localsplus</code>域中。要注意的是<code>cell</code>的在<code>localsplus</code>域中的位置位于局部变量后。</p><p>这些<code>PyCellObject</code>对象十分简单，只有一个<code>ob_ref</code>指向一个<code>object</code>：</p><pre><code class="c">typedef struct {    PyObject_HEAD    PyObject *ob_ref;} PyCellObject;</code></pre><p>这里我们创建的<code>PyCellObject</code>对象的<code>ob_ref</code>指针指向<code>NULL</code>：</p><pre><code class="c">PyObject *PyCell_New(PyObject *obj){    PyCellObject *op;    op = (PyCellObject *)PyObject_GC_New(PyCellObject, &amp;PyCell_Type);    op-&gt;ob_ref = obj;    return (PyObject *)op;}</code></pre><p>上面我们可以看到，在创建完新的栈桢对象后，<code>f_localsplus</code>区域内的这些<code>cell</code>对象的<code>ob_ref</code>依然指向一个空地址，那么是在什么时候初始化的呢？</p><p>答案是在调用<code>PyEval_EvalFrameEx(f, 0)</code>执行栈桢的时候，我们可以看到在<code>get_func</code>函数执行过程中，有个字节码就是<code>2 STORE_DEREF 0</code>，这是这个字节码，将：</p><pre><code class="c">freevars = f-&gt;f_localsplus + co-&gt;co_nlocals; /* 指向f_localsplus中ncells第一个位置 */TARGET(STORE_DEREF) {    PyObject *v = POP(); /* 这里pop弹出的就是在STORE_DEREF前入栈的value */    PyObject *cell = freevars[oparg]; /* 从f_localsplus中获取cell对象设置ob_ref */    PyObject *oldobj = PyCell_GET(cell);    PyCell_SET(cell, v);}</code></pre><p><code>STORE_DEREF</code>从运行时栈中弹出<code>value</code>符号对应的对象值，并将这个变量值和<code>cell</code>对象绑定，通过<code>cell</code>对象我们可以使用这些约束了。</p><p><img src="/images/pyfunctionobject-3.png" alt=""></p><p>我们再来看看，<code>inner_func</code>函数中是怎么使用这些“冻结”的<code>cell</code>的：在创建<code>inner_func</code>函数对象之前，有个字节码<code>4 LOAD_CLOSURE  0 (value)</code>，这个字节码的定义如下</p><pre><code class="c">TARGET(LOAD_CLOSURE) {    PyObject *cell = freevars[oparg];    PUSH(cell);}</code></pre><p>作用很明显，从<code>f_localsplus</code>中获取指令参数指定位置的<code>cell</code>对象，并将它压入运行时栈中。</p><p>而在<code>MAKE_FUNCTION</code>创建<code>inner_function</code>函数对象是指令参数为<code>8</code>，那么：</p><pre><code class="c">if (oparg &amp; 0x08) {    func -&gt;func_closure = POP(); /* 可以是一个包含多个cell对象的元组，这个例子中元组里只有一个cell */}</code></pre><p>这到了”搬运工“发挥作用的时刻了，虚拟机将压入栈中的<code>cell</code>对象绑定在了新创建的函数对象<code>func_closure</code>域，现在内部函数就可以使用外部函数”冻结“的变量值了。最后这个新创建的<code>functionobject</code>被放置在栈桢对象的<code>f_localsplus</code>域。</p><p><img src="/images/pyfunctionobject-4.png" alt=""></p><p>既然内部函数的<code>func_clousre</code>域有了<code>cell</code>对象元组，那么我就可以在执行<code>inner_func</code>的时候，使用外部函数的局部变量了。还是熟悉的配方，在<code>_PyEval_EvalCodeWithName</code>创建栈桢对象过程中，由于内部函数的<code>PyCodeObject</code>有<code>co_freevars</code>，所以我们需要进行处理：</p><pre><code class="c">for (i = 0; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) {    PyObject *o = PyTuple_GET_ITEM(closure, i); /* 这个closure就是从func对象中获取的func_closure */    freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o; /* 设置co_cellvars区域后面 */}</code></pre><p>所以，在将<code>PyFunctionObject</code>携带的<code>func_closure</code>中的<code>PyCellObject</code>，绑定在新的栈桢的<code>f_localsplus</code>域中的<code>free</code>变量区后，就可以引用外部函数的符号了。</p><p><img src="/images/pyfunctionobject-5.png" alt=""></p><p>和<code>STORE_DEREF</code>指令将运行时栈中的值存放在<code>cell</code>变量区相似，Python也有一个指令<code>LOAD_DEREF</code>从<code>free</code>变量区加载到运行时栈中：</p><pre><code class="c">TARGET(LOAD_DEREF) {    PyObject *cell = freevars[oparg];    PyObject *value = PyCell_GET(cell);    PUSH(value);}</code></pre><p>总结一下“闭包”的处理，几个关键的变量和属性：</p><ul><li>在<code>PyCodeObject</code>中的<code>co_cellvars</code>和<code>co_freevars</code>；</li><li><code>FunctionObject</code>中的<code>func_closure</code>，传递<code>PyCellObject</code>给内部函数；</li><li><code>PyFrameObject</code>中的<code>f_localsplus</code>的<code>cell</code>变量区和<code>free</code>变量区；</li></ul><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器就是”闭包“的一种运用，然后Python在加上装饰器<code>语法糖</code>。</p><pre><code class="python">@decoratordef func():    pass# 等价于decorator(func)</code></pre><h2 id="未完，待续。。。"><a href="#未完，待续。。。" class="headerlink" title="未完，待续。。。"></a>未完，待续。。。</h2><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在Python中，函数是一等对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;函数对象&quot;&gt;&lt;a href=&quot;#函数对象&quot; class=&quot;headerlink&quot; title=&quot;函数对象&quot;&gt;&lt;/a&gt;函数对象&lt;/h2&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python源码阅读-虚拟机和字节码</title>
    <link href="http://shawnz.me/posts/eab2cd72/"/>
    <id>http://shawnz.me/posts/eab2cd72/</id>
    <published>2018-01-11T12:39:50.000Z</published>
    <updated>2018-03-10T06:20:54.118Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客主要记录Python源代码是怎么转换成一系列的机器指令并执行的。这里说的Python指的是CPython实现。</p><p>在我们通过<code>python *.py</code>运行一个Python程序时，CPython解释器首先会对源代码进行<code>编译</code>，产生一组<code>字节码</code>(Byte Code)，然后将编译的结果交给Python的<code>虚拟机</code>(PVM)，由虚拟机一条一条的执行字节码来运行程序。所以说Python解释器包含两个部分：编译器和虚拟机。</p><a id="more"></a><p><img src="/images/python-interpreter.png" alt=""></p><h2 id="PyCodeObject"><a href="#PyCodeObject" class="headerlink" title="PyCodeObject"></a>PyCodeObject</h2><p>”编译“的结果就是<code>PyCodeObject</code>对象，而<code>.pyc</code>文件是这个对象在硬盘上的表现形式。</p><pre><code class="c">/* Bytecode object */typedef struct {    PyObject_HEAD    int co_argcount;        /* #arguments, except *args */    int co_kwonlyargcount;    /* #keyword only arguments */    int co_nlocals;        /* #local variables */    int co_stacksize;        /* #entries needed for evaluation stack */    int co_flags;        /* CO_..., see below */    int co_firstlineno;   /* first source line number */    PyObject *co_code;        /* instruction opcodes */    PyObject *co_consts;    /* list (constants used) */    PyObject *co_names;        /* list of strings (names used) */    PyObject *co_varnames;    /* tuple of strings (local variable names) */    PyObject *co_freevars;    /* tuple of strings (free variable names) */    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */    /* The rest aren&#39;t used in either hash or comparisons, except for co_name,       used in both. This is done to preserve the name and line number       for tracebacks and debuggers; otherwise, constant de-duplication       would collapse identical functions/lambdas defined on different lines.    */    unsigned char *co_cell2arg; /* Maps cell vars which are arguments. */    PyObject *co_filename;    /* unicode (where it was loaded from) */    PyObject *co_name;        /* unicode (name, for reference) */    PyObject *co_lnotab;    /* string (encoding addr&lt;-&gt;lineno mapping) See                   Objects/lnotab_notes.txt for details. */    void *co_zombieframe;     /* for optimization only (see frameobject.c) */    PyObject *co_weakreflist;   /* to support weakrefs to code objects */    /* Scratch space for extra data relating to the code object.       Type is a void* to keep the format private in codeobject.c to force       people to go through the proper APIs. */    void *co_extra;} PyCodeObject;</code></pre><p>Python编译时，对于代码中的每一个<code>Code Block</code>(进入一个新的名字空间)都会对应一个<code>PyCodeObject</code>对象，和名字空间一样，<code>PyCodeObject</code>也可以嵌套，嵌套在<code>co_consts</code>域。</p><p>可以看到字节码对象<code>PyCodeObject</code>有许多的域，其中包含了Python源代码的一切有用<code>静态</code>信息，例如字符串，常量值以及字节码指令(操作)等。</p><h2 id="pyc"><a href="#pyc" class="headerlink" title=".pyc"></a>.pyc</h2><p><code>.pyc</code>文件是<code>PyCodeObject</code>对象在硬盘上的表现形式，在Python3中，这些文件位于<code>__pycache__</code>文件夹下。我们可以发现通过<code>python *.py</code>的方式运行Python程序时，并不会生成<code>.pyc</code>文件，那么这个文件是什么时候创建的呢？</p><p>在通过<code>import</code>机制对<code>module</code>动态加载的时候，Python会先尝试去查找<code>.pyc</code>文件。如果没有这些文件，Python会将<code>*.py</code>文件编译成相应的<code>PyCodeObject</code>对象，然后再创建<code>*.pyc</code>文件，并将<code>PyCodeObject</code>和一些信息写入到文件中。接下来才是<code>import</code>动作，将<code>*.pyc</code>文件中的<code>PyCodeObject</code>对象在内存中复制出来。</p><p>在Python中提供了许多类库，允许完成<code>.pyc</code>文件的生成：</p><pre><code class="python">[generate_pyc.py]import impimport sysdef generate_pyc(name):    fp, pathname, description = imp.find_module(name)    try:        imp.load_module(name, fp, pathname, description)        finally:        if fp:            fp.close()if __name__ == &#39;__main__&#39;:    generate_pyc(sys.argv[1])</code></pre><p>一个<code>.pyc</code>文件包含三个部分：<code>magic number</code>、<code>pyc文件的创建时间</code>和<code>PyCodeObject对象</code>。</p><p>一般不同版本的Python会定义不同<code>magic number</code>，主要是用来保证兼容性，下面是Python3.5所定义的<code>magic number</code>：</p><pre><code class="c">MAGIC_NUMBER = (3379).to_bytes(2, &#39;little&#39;) + b&#39;\r\n&#39;_RAW_MAGIC_NUMBER = int.from_bytes(MAGIC_NUMBER, &#39;little&#39;)  # For import.c</code></pre><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>在<code>PyCodeObject</code>对象的<code>co_code</code>就保存着字节码指令序列，以<code>PyStringObject</code>类型存在，在C底层真正存储字节码的就是一个<code>char []</code>数组。</p><p>Python3定义了117条字节码指令，大于或等于90的指令需要参数：</p><pre><code class="c">[opcode.c]#define POP_TOP                   1#define ROT_TWO                   2...#define HAVE_ARGUMENT            90...#define BUILD_CONST_KEY_MAP     156#define BUILD_STRING            157#define BUILD_TUPLE_UNPACK_WITH_CALL 158/* 判断一条指令是否需要参数 */#define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)</code></pre><p>Python标准库提供了用来生成字节码的工具<code>dis</code>，使用<code>dis</code>可以对代码进行性能分析。</p><h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p><code>.py</code>文件被编译后，Python虚拟机会从<code>PyCodeObject</code>中一条一条读取字节码指令，并在当前上下文环境中执行。</p><p>在讲上下文环境之前，我们先弄懂什么是”执行环境“？<code>PyCodeObject</code>中包含了程序运行的静态信息和字节码，而一些动态捕捉和维护的信息就保存在<code>PyFrameObject</code>对象中，这就是执行环境。</p><pre><code class="c">typedef struct _frame {    PyObject_VAR_HEAD    struct _frame *f_back;      /* previous frame, or NULL */    PyCodeObject *f_code;       /* PyCodeObject对象 */    PyObject *f_builtins;       /* builtin名字空间(PyDictObject) */    PyObject *f_globals;        /* global名字空间(PyDictObject) */    PyObject *f_locals;         /* local名字空间(PyDictObject) */    PyObject **f_valuestack;    /* 运行时栈的栈底位置 */    PyObject **f_stacktop;      /* 运行时栈的栈顶位置*/    PyObject *f_trace;          /* 记录异常处理 */    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;    /* Borrowed reference to a generator, or NULL */    PyObject *f_gen;    int f_lasti;                /* 当前字节码位置 */    int f_lineno;               /* 当前行号 */    int f_iblock;               /* 一些局部代码块f_blockstack */    char f_executing;           /* 当前栈桢是否还在执行 */    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */    PyObject *f_localsplus[1];  /* 动态内存维护：locals+stack */} PyFrameObject;</code></pre><p>在Python程序运行的时候，会创建一个又一个的<code>PyFrameObject</code>对象，它们之间通过<code>f_back</code>链接起来。所以对于Python虚拟机引擎来说它面对的就是<code>PyFrameObject</code>对象，相当于对C语言中“栈帧”的模拟，但又不仅仅是C语言中的“栈桢”，它还包括一些其他的信息，例如：</p><ul><li><code>f_code</code>：待执行的<code>PyCodeObject</code>对象，虚拟机从这里面读取并执行字节码；</li><li><code>f_builtins</code>、<code>f_globals</code>和<code>f_locals</code>：维护着三个动态的名字空间，是以<code>PyDictObject</code>的形式维护<code>name</code>和<code>value</code>的映射；</li><li><code>f_localsplus</code>：维护一段变长内存，里面就包括了<code>PyFrameObject</code>对象所维护的”运行时栈“(这个”栈“才是和C语言中的那个栈空间相对应的概念)以及一部分额外的内存(供<code>PyCodeObject</code>对象存储的那些<code>co_names</code>, <code>co_freevars</code>和<code>co_cellvals</code>使用，涉及“闭包”的实现)。</li></ul><p>下面是一个新创建的<code>PyFrameObject</code>对象，它的”栈顶“和“栈底”位置重叠在一起：</p><p><img src="/images/python_frame_structure.png" alt=""></p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在<code>PyFrameObject</code>中，我们可以看到三个独立的命名空间：<code>local</code>、<code>global</code>和<code>builtin</code>命名空间。</p><p><strong>作用域和命名空间</strong></p><ul><li>作用域：是指一段程序文本的某一段区域，它决定这约束是否起作用，Python是具有静态作用域的；</li><li>命名空间：名字和对象的映射，一段文本定义作用域在Python程序运行时会转换成对应的命名空间，例如，在执行函数<code>f</code>的时候会创建一个命名空间。</li></ul><p>*Note：在Python中<code>if</code>语句和<code>for</code>语句不会引入新的作用域，另外在Python3中，针对推导式和生成器会引入新的局部作用域，不用担心变量泄露的问题：</p><pre><code class="python">&gt;&gt;&gt; i = 1&gt;&gt;&gt; for i in range(10):...    pass...&gt;&gt;&gt; i9   # i产生了变化9&gt;&gt;&gt; [i for i in range(3)][0, 1, 2]&gt;&gt;&gt; i9   # 没有改变i</code></pre><p><strong>赋值语句</strong></p><p>在Python中赋值语句(更切确的说是具有赋值行为的语句)，做的就是绑定或重绑定工作，不会产生拷贝。</p><p>除了常见的<code>=</code>显示赋值，在Python中<code>import a</code>、<code>class A:</code>和<code>def f():</code>这样的语句都是赋值语句，它们会创建约束并放在命名空间(<code>dict</code>)中。</p><p>函数的参数传递？</p><p>鉴于这样的行为，能够很好的解释Python的动态类型(名字只是一个符号，用来查找对象，类型的信息都在对象上存储着)以及为什么Python没有函数重载(因为重载需要根据参数签名来决定，而Python只保存了一个名称)。</p><p><strong>引用语句</strong></p><p>既然赋值语句是建立约束，那么引用语句可以看做是访问(查找)约束。Python的引用分为两种：</p><ul><li>属性引用：一个对象的名字空间中的所有名字称为对象的属性，那么我们可以通过属性引用的方式访问对象的属性；</li><li>名字引用：位于一个作用域中的代码能够直接访问出现在作用域中的代码。</li></ul><p><strong>LEGB规则</strong></p><p>要是名字引用访问没有出现在作用域中的名字，Python会怎么处理呢？</p><p>这里有一个<code>最内层嵌套作用域规则</code>：由一个赋值语句引入的名字在赋值语句所在的作用域是<code>可见的</code>，而且在其内部嵌套的作用域也是可见的，除非被嵌套作用域引入了的同一名字的另一个赋值语句所<code>遮蔽</code>。</p><p>Python使用一个<code>LEGB</code>的顺序来查找符号对应的对象：</p><blockquote><p><code>locals</code> –&gt; <code>enclosing</code> –&gt; <code>globals</code> –&gt; <code>builtins</code></p></blockquote><p>一个例子就是<code>闭包</code>的实现：</p><pre><code class="python">a = 1def f():    a = 2    def g():        print(a) # a 位于外部嵌套函数的命名空间    return gfunc = f()func()  # 输出 2</code></pre><p><strong>global和nonlocal</strong></p><ul><li><code>global</code>：用来声明一系列变量，这些变量会引用到当前模块的全局命名空间的变量（module－level namespace），如果该变量没有定义，也会在全局空间中添加这个变量。</li><li><code>nonlocal</code>：从声明处从里到外的namespace去搜寻这个变量（the nearest enclosing scope），直到模块的全局域（不包括全局域），不会在当前scope的namespace字典中加入一个key-value对。</li></ul><h2 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h2><p>在Python启动后，真正有意义的初始化动作是从<code>pylifecyle</code>中的<code>Py_Initialize</code>开始的，<code>Py_Initialzie</code>最终调用的是<code>_Py_InitializeEx_Private</code>，在这里面主要完成加载多个基础模块(<code>bulitins, __main__和sys</code>)，类型系统和异常系统的初始化以及一些其他工作。</p><p>Python有自己的一套线程模型，虚拟机在运行的时候，一般是一个或多个线程轮流使用一个字节码执行引擎(具体的多线程机制这里并不涉及)。针对线程和进程，Python分别抽象出了两个状态对象：<code>PyThreadState</code>和<code>PyInterpreterState</code>。</p><pre><code class="c">typedef struct _is {    struct _is *next;    struct _ts *tstate_head;    PyObject *modules;    ...    PyObject *builtins;    PyObject *importlib;    int codecs_initialized;    int fscodec_initialized;    PyObject *builtins_copy;    PyObject *import_func;    /* Initialized to PyEval_EvalFrameDefault(). */    _PyFrameEvalFunction eval_frame;} PyInterpreterState;typedef struct _ts {    struct _ts *prev;    struct _ts *next;    PyInterpreterState *interp;    struct _frame *frame;    int recursion_depth;    ...    PyObject *dict;  /* Stores per-thread state */    int gilstate_counter;    PyObject *async_exc; /* Asynchronous exception to raise */    long thread_id; /* Thread id where this tstate was created */    ...    PyObject *async_gen_finalizer;} PyThreadState;</code></pre><p>可以看到这么一个结构，在进程<code>_is</code>中维护着一个<code>tstate_head</code>线程列表，而在线程<code>_ts</code>中维护着当前线程的栈桢列表<code>frame</code>。</p><p>在Python虚拟机开始执行时，它会将当前线程状态对象的<code>frame</code>设置为当前的执行环境，并执行字节码。在当前栈桢执行完毕后，会创建一个新的<code>PyFrameObject</code>，并从<code>tstate</code>中取得<code>frame</code>构建成一条链表，开始新的征途。</p><p>在某一时刻，虚拟机的运行时的内存布局会是下面这种形式：</p><p><img src="/images/python_runtime_env.png" alt=""></p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>当虚拟机的字节码执行引擎在<code>_PyEval_EvalFrameDefault</code>函数里，首先会初始化一批和<code>PyCodeObject</code>有关的变量以及让栈的指针指向<code>f-&gt;f_stacktop</code>：</p><p>在设置好各个变量后，执行引擎会从头遍历整个<code>PyCodeObject</code>的<code>co_code</code>域，依次处理字节码。其中有三个变量和字节码遍历有关：</p><ul><li><code>first_instr</code>：永远指向字节码序列的开始位置；</li><li><code>next_instr</code>：指向下一条待执行的字节码指令；</li><li><code>f_lasti</code>：上一条已执行的字节码在co_code中的索引。</li></ul><p>字节码的处理是在一个<code>for loop</code>中，以<code>switch</code>的方式分发到相应的宏定义上处理各种字节码。一条字节码处理完成过后会跳转到<code>for</code>循环或者是<code>fast_next_opcode</code>执行下一条。其中有个变量<code>why</code>，它保存着结束字节码执行时的状态码信息，是正常还是异常退出。</p><pre><code class="c">PyObject *_PyEval_EvalFrameDefault(PyFrameObject *f, int throwflag){    ...    co = f-&gt;f_code;    names = co-&gt;co_names;    consts = co-&gt;co_consts;    fastlocals = f-&gt;f_localsplus;    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;    first_instr = (_Py_CODEUNIT *) PyBytes_AS_STRING(co-&gt;co_code);    next_instr = first_instr;    if (f-&gt;f_lasti &gt;= 0) {        next_instr += f-&gt;f_lasti / sizeof(_Py_CODEUNIT) + 1;    }    stack_pointer = f-&gt;f_stacktop;    why = WHY_NOT;    for (;;) {        ...        fast_next_opcode:            f-&gt;f_lasti = INSTR_OFFSET();            ...        dispatch_opcode:            switch (opcode) {                TARGET(NOP)                    FAST_DISPATCH();                TARGET(LOAD_FAST) {                    ...                }                ...            }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客主要记录Python源代码是怎么转换成一系列的机器指令并执行的。这里说的Python指的是CPython实现。&lt;/p&gt;
&lt;p&gt;在我们通过&lt;code&gt;python *.py&lt;/code&gt;运行一个Python程序时，CPython解释器首先会对源代码进行&lt;code&gt;编译&lt;/code&gt;，产生一组&lt;code&gt;字节码&lt;/code&gt;(Byte Code)，然后将编译的结果交给Python的&lt;code&gt;虚拟机&lt;/code&gt;(PVM)，由虚拟机一条一条的执行字节码来运行程序。所以说Python解释器包含两个部分：编译器和虚拟机。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>[LeetCode]32. Longest Valid Parentheses</title>
    <link href="http://shawnz.me/posts/fbe1b588/"/>
    <id>http://shawnz.me/posts/fbe1b588/</id>
    <published>2018-01-09T17:04:52.000Z</published>
    <updated>2018-03-10T06:20:54.118Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({    tex2jax: {        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],        processEscapes: true,        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']    }});console.log("======================")MathJax.Hub.Queue(function() {    var all = MathJax.Hub.getAllJax(), i;    for(i=0; i < all.length; i += 1) {        all[i].SourceElement().parentNode.className += ' has-jax';                     }       });</script><p><link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet"></p><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于一个给定的只包含“(”和“)”的字符串，找出它的最长合法括号。例如：</p><blockquote><p>“(()” =&gt; 2  # 最长合法括号为“()”，长度为2<br><br>“)()())” =&gt; 4  # 最长合法括号为“()()“，长度为4</p></blockquote><a id="more"></a><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>很容易想到的解法是，穷举出所有的子串，然后一一验证每个子串是否是合法的(<code>Valid Parentheses</code>)。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n^3)$。穷举所有子串为$O(n^2)$，使用栈验证一个长度为n的子串需要$O(n)$</li><li>空间复杂度：$O(n)$。使用栈验证字符串需要一定的空间。</li></ul><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>这是一道括号题，和<code>Valid Parenthese</code>一样，可以尝试使用栈。</p><p>从左到右遍历字符串，如果是<code>(</code>，那么进行“压栈”操作；如果是<code>)</code>，若它是一个合法的括号匹配，那么必然可以和栈顶的<code>(</code>抵消。</p><p>不过在这里，我们要求的是“长度”，所以在遍历过程中，应该记录长度或者是索引的信息。</p><ol><li>使用<code>stack</code>来记录上一个<code>valid</code>串的停止位置，刚开始为<code>-1</code>；</li><li>在从左到右的遍历过程中，碰到左括号<code>(</code>，把它的索引<code>i</code>压栈；</li><li>碰到右括号<code>)</code>，则需要弹出栈顶元素尝试抵消：<ul><li>如果栈顶不是<code>(</code>(也就是弹出元素后<code>stack</code>为空)，那么当前这个<code>valid</code>串到这为止，开始查找新的<code>valid</code>串，重置哨兵为当前位置<code>i</code>；</li><li>如果能够抵消，那么<code>valid</code>串就会变长</li></ul></li></ol><pre><code class="python">class Solution:    def longestValidParentheses(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: int        &quot;&quot;&quot;        n = len(s)        stack = [-1]        maxLen = 0        for i in range(n):            if s[i] == &#39;(&#39;:                stack.append(i)            else:                stack.pop()                if not stack:                    stack.append(i)                else:                    maxLen = max(maxLen, i-stack[-1])        return maxLen</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，遍历一次长度为<code>n</code>的字符串。</li><li>空间复杂度：$O(n)$。使用栈保存索引，如果一直是左括号<code>(</code>，那么栈的大小为<code>n+1</code>。</li></ul><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>我们发现一个最长<code>valid</code>串能够由一个子<code>valid</code>串构成，可以尝试着从动态规划的角度去理解这个问题。</p><p>从右到左，对于以<code>i</code>结尾的字符串分几种情形：</p><ul><li>如果<code>s[i]==(</code>，那么显然它不是一个<code>valid</code>串，则<code>dp[i] = 0</code>。例如<code>()(</code>；</li><li>如果<code>s[i]==)</code>，那么：<ul><li>如果<code>s[i-1]==&quot;(&quot;</code>，，那么<code>dp[i] = dp[i-2] + 2</code>。例如<code>()()</code>；</li><li>如果<code>s[i-1]==&quot;)&quot;</code>：<ul><li>像<code>()(())</code>这种，<code>dp[i]=dp[i-1] + 2 + dp[i-dp[i-1]-2]</code></li><li>像<code>)())</code>或<code>())</code>这种，<code>dp[i]=0</code></li></ul></li></ul></li></ul><p>设<code>dp[i-1]</code>的最长<code>valid</code>串的前一位为<code>j=i-dp[i-1]-1</code>，整理一下可以得到它的状态方程：</p><p>$$dp[i] = \begin{cases}<br>0, &amp;if\ s[i]==’(‘\ or\ j&lt;0\ or\ s[j]==’)’\<br>dp[i-1] + 2, &amp;if\ s[j]==’(‘\ and\ j=0\<br>dp[i-1] + 2 + dp[j-1], &amp;if\ s[j]==’(‘\ and\ j&gt;0\<br>\end{cases}$$</p><pre><code class="python">class Solution:    def longestValidParentheses(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: int        &quot;&quot;&quot;        n = len(s)        dp = [0] * n        maxLen = 0        for i in range(1, n):            j = i - dp[i-1] - 1            if j &gt;= 0 and s[j] == &#39;(&#39;:                dp[i] = dp[i-1] + 2 + (dp[j-1] if j &gt; 0 else 0)                maxLen = max(maxLen, dp[i])        return maxLen</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，遍历一次长度为<code>n</code>的字符串。</li><li>空间复杂度：$O(n)$。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;]  ],
        processEscapes: true,
        skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;, &#39;code&#39;]
    }
});
console.log(&quot;======================&quot;)
MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i &lt; all.length; i += 1) {
        all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;                 
    }       
});
&lt;/script&gt;

&lt;p&gt;&lt;link href=&quot;https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/p&gt;
&lt;script src=&quot;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;

&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;对于一个给定的只包含“(”和“)”的字符串，找出它的最长合法括号。例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“(()” =&amp;gt; 2  # 最长合法括号为“()”，长度为2&lt;br&gt;&lt;br&gt;“)()())” =&amp;gt; 4  # 最长合法括号为“()()“，长度为4&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://shawnz.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://shawnz.me/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法(Backtracking)</title>
    <link href="http://shawnz.me/posts/1b888408/"/>
    <id>http://shawnz.me/posts/1b888408/</id>
    <published>2018-01-09T06:33:12.000Z</published>
    <updated>2018-03-10T06:20:54.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在许多情况下，回溯算法相当于“穷举搜索”的巧妙实现。主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯算法一个重要特性就是问题的解空间一般在搜索的过程中动态的构建。</p><p>在思考回溯算法，一般需要明确几点：</p><ul><li><code>裁剪(pruning)</code>：在当前局面所有的可能的尝试，删除掉一批不可能尝试；</li><li><code>分支限定(bounding)</code>：使用限定条件避免掉一些不必要的尝试；</li><li><code>回溯(backtrack)</code>：使用深度优先的递归方式尝试每种选择，在不满足条件的情况下能够很好的回溯；</li><li><code>结束(termination)</code>：若是求解所有解，则需要回溯到<code>根</code>，且<code>根</code>的所有<code>子树</code>都已经搜索完毕；若是求解任一解，那么只要找到一个解就可以结束。</li></ul><p>下面将从几个具体的例子来理解回溯算法。<br><a id="more"></a></p><h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><blockquote><p>Given a collection of <code>distinct</code> numbers, return all possible permutations.<br><br>For example, [1,2,3] have the following permutations:<br><br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]  </p></blockquote><p><strong>解法一：回溯+递归</strong></p><p>以<code>{1, 2, 3}</code>为例，找出它的全排列。一个直接的想法是依序穷举每一个位置，针对每个位置填充不同的元素，需要注意的是同一个元素不能使用两次。</p><p>可以使用<code>DFS</code>从左到右填充元素，每次填充的时候可能的尝试是<code>1, 2, 3</code>，但是当一个位置填充的是<code>1</code>的时候，那么在这次构建序列中<code>1</code>就不能再使用了，所以下面我们引入一个限定条件检查元素不包含在当前排列中。</p><pre><code class="python">class Solution:    def permute(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        if not nums:            return []        res = []        tmp = []        self.backtrack(nums, tmp, res)        return res    def backtrack(self, nums, tmp, res):        if len(tmp) == len(nums):            res.append(tmp[:])            return         for i in range(len(nums)):            if nums[i] in tmp:                continue            tmp.append(nums[i])            self.backtrack(nums, tmp, res)            tmp.pop()</code></pre><p>复杂度：</p><ul><li>时间复杂度：$O(n!)$，第一个位置有<code>n</code>种选择，第二个位置有<code>n-2</code>个选择，则<code>n*(n-1)*...*2*1=n!</code></li><li>空间复杂度：$O(n!)$，输出需要<code>n!</code>的存储空间。</li></ul><p><strong>解法二：*插入法</strong></p><p>这道题的另外一种思路是使用“插入法”：<br><br><code>P(1) = [1]</code><br><br><code>P(1,2) = [[2, 1], [1, 2]]</code><br><br><code>P(1,2,3) = [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]]</code><br><br>我们可以把<code>P(1, 2)</code>看作是把<code>2</code>插入到<code>P(1)</code>中所有可能的位置，<code>P(1, 2, 3)</code>看作是把<code>3</code>插入到<code>P(1, 2)</code>中能够插入的位置。</p><pre><code class="python">class Solution:    def permute(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        if not nums: return []        perms = [[]]        for idx, num in enumerate(nums):            new_perms = []            for perm in perms:                for i in range(idx+1):                    tmp = perm[:]                    tmp.insert(i, num)  # 插入元素                    new_perms.append(tmp)            perms = new_perms        return perms</code></pre><p>复杂度分析：</p><ul><li>时间复杂度：$O(n<em>n!)$，第一层和第三层的<code>for</code>循环为`n</em>n<code>，第二层循环为</code>(n-1)!`。</li><li>空间复杂度：$O(n!)$，输出需要<code>n!</code>的存储空间。</li></ul><p><strong>* Follow up</strong></p><p>一个升级版就是对于有<code>重复</code>元素的数组，例如<code>{1, 1, 2}</code>怎么计算它的所有<code>不同</code>排列。</p><p>这种重复元素问题的常见解决思路就是，先排序一次，在判断前后两个元素是否相等，再做相应的处理(跳过)。</p><p>在使用回溯算法的实现中，我们先是对数组进行一次排序，并引进了一个<code>used[]</code>数组记录元素是否访问过，在这里有两种方式都能够消除重复元素：<code>used[i-1]</code>和<code>!used[i-1]</code>。</p><p>下面使用递归树的方式描述了这个过程，可以看到在有重复元素的时候<code>used[i-1]</code>和<code>!used[i-1]</code>是怎么处理的。假设我们对三个重复元素<code>2</code>排序完后进行编号：<code>2(1),2(2),2(3)</code>：</p><p><img src="/images/backtrack.jpg" alt=""></p><ul><li><code>used[i-1]</code>：只有在前一个元素使用的情况下才会加入排列，那么最终只会形成<code>2(1),2(2),2(3)</code>这种顺序的排列；</li><li><code>!used[i-1]</code>：只有在前一个元素没有使用的情况下才会加入排列，那么只会形成<code>2(3),2(2),2(1)</code>降序排列。</li></ul><p>当然，还有一个前提就是<code>if used[i]: continue</code>，跳过已经处理过的元素。我们可以发现<code>used[i-1]</code>和<code>!used[i-1]</code>都能消除重复元素，那它们的区别在哪呢？</p><p>答案就是使用<code>!used[i-1]</code>的话，中间不会进行一些不必要的处理，例如<code>used[i-1]</code>会进行<code>2(2),2(1)</code>再到<code>2(2),2(1),2(3)</code>的尝试，而<code>!used[i-1]</code>就不会，所以它更高效一点，在LeetCode上可以很明显的看到时间性能的提升。</p><pre><code class="python">class Solution:    def permuteUnique(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        if not nums: return []        res = []        nums.sort()        n = len(nums)        used = [False] * n        curr = []        self.backtrack(nums, used, curr, res)        return res    def backtrack(self, nums, used, curr, res):        if len(curr) == len(nums):            res.append(curr[:])            return         for i in range(len(nums)):            if used[i]:                    continue            # 这两种方式都可以消除重复元素               if i &gt; 0 and nums[i] == nums[i-1] and not used[i-1]:                continue            # if i &gt; 0 and nums[i] == nums[i-1] and used[i-1]:            #     continue            used[i] = True            curr.append(nums[i])            self.backtrack(nums, used, curr, res)            used[i] = False            curr.pop()</code></pre><p>下面是使用“插入法”在有重复元素时的实现：</p><pre><code class="python">class Solution:    def permuteUnique(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        if not nums:            return []        n = len(nums)        nums.sort()        perms = [[nums[0]]]        for i in range(1, n):            new_perms = []            for perm in perms:                for j in range(i+1):                    tmp = perm[:]                    tmp.insert(j, nums[i])                    new_perms.append(tmp)                    if j &lt; len(perm) and perm[j] == nums[i]:  # 这里的跳过逻辑可以好好想想                        break            perms = new_perms        return perms</code></pre><h3 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h3><p><strong>问题描述</strong></p><p>列举子集合。这里示范：列举出{0,1,2,3,4}的所有子集合。</p><pre><code class="python">class Solution:    def subsets(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        if not nums: return []        n = len(nums)        res = []        self.backtrack(nums, res, [], 0)        return res    def backtrack(self, nums, res, tmp, start):        res.append(tmp[:])        for i in range(start, len(nums)):            tmp.append(nums[i])            self.backtrack(nums, res, tmp, i+1)            tmp.pop()</code></pre><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p><strong>问题描述</strong></p><p>在一个N×N的（国际）棋盘上，放置N个棋子（皇后），使得N个”皇后“中任意2个都不在同一行、同一列以及同一斜线。 问：放置这N个”皇后“的方法共有多少种？(或者列举解)</p><p><img src="/images/八皇后问题.png" alt=""></p><p><strong>解决思路</strong></p><p>通过回溯算法，逐行暴力搜索每行能够放置“皇后”的位置，找到第i行的解的前提是前i-1行已经放置好了皇后，直到第N行时结束。</p><p>在搜索的过程中使用<code>pos[n]</code>记录棋盘第i行、第j列的“皇后”位置。</p><p><strong>实现</strong></p><p>我们来看看递归的实现：</p><pre><code class="python">class Solution:    def solveNQueens(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: List[List[str]]        &quot;&quot;&quot;        res = []        pos = [-1] * n        self.backtrack(pos, 0, [], res)        return res    def backtrack(self, pos, row, path, res):        if row == len(pos):            res.append(path)            return  # backtracking        for col in range(len(pos)):            if self.is_valid(pos, row, col):  # pruning                tmp = &#39;.&#39; * len(pos)                pos[row] = col                self.backtrack(pos, row+1, path + [tmp[:col] + &#39;Q&#39; + tmp[col+1:]], res)    def is_valid(self, pos, row, col):        for i in range(row):            if pos[i] == col or pos[i] - col == i - row or pos[i] - col == row - i:                return False        return True</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><code>&gt;&gt;&gt;</code> <a href="https://github.com/zhsj/nqueen/blob/master/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.md" target="_blank" rel="noopener">N皇后问题</a><br><br><code>&gt;&gt;&gt;</code> <a href="">51. N-Queens</a><br><br><code>&gt;&gt;&gt;</code> <a href="">52. N-Queens II</a><br><br><code>&gt;&gt;&gt;</code> <a href="">39. Combination Sum</a><br><br><code>&gt;&gt;&gt;</code> <a href="">40. Combination Sum II</a><br><br><code>&gt;&gt;&gt;</code> <a href="">216. Combination Sum III</a><br><br><code>&gt;&gt;&gt;</code> <a href="">46. Permutations</a><br><br><code>&gt;&gt;&gt;</code> <a href="">47. Permutations II</a><br><br><code>&gt;&gt;&gt;</code> <a href="">78. Subsets</a><br><br><code>&gt;&gt;&gt;</code> <a href="">90. Subsets II</a><br><br><code>&gt;&gt;&gt;</code> <a href="">131. Palindrome Partitioning</a><br></p><script type="text/x-mathjax-config">MathJax.Hub.Config({    tex2jax: {        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],        processEscapes: true,        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']    }});console.log("======================")MathJax.Hub.Queue(function() {    var all = MathJax.Hub.getAllJax(), i;    for(i=0; i < all.length; i += 1) {        all[i].SourceElement().parentNode.className += ' has-jax';                     }       });</script><p><link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet"></p><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在许多情况下，回溯算法相当于“穷举搜索”的巧妙实现。主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯算法一个重要特性就是问题的解空间一般在搜索的过程中动态的构建。&lt;/p&gt;
&lt;p&gt;在思考回溯算法，一般需要明确几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;裁剪(pruning)&lt;/code&gt;：在当前局面所有的可能的尝试，删除掉一批不可能尝试；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;分支限定(bounding)&lt;/code&gt;：使用限定条件避免掉一些不必要的尝试；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;回溯(backtrack)&lt;/code&gt;：使用深度优先的递归方式尝试每种选择，在不满足条件的情况下能够很好的回溯；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;结束(termination)&lt;/code&gt;：若是求解所有解，则需要回溯到&lt;code&gt;根&lt;/code&gt;，且&lt;code&gt;根&lt;/code&gt;的所有&lt;code&gt;子树&lt;/code&gt;都已经搜索完毕；若是求解任一解，那么只要找到一个解就可以结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面将从几个具体的例子来理解回溯算法。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://shawnz.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://shawnz.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python源码阅读-Dict</title>
    <link href="http://shawnz.me/posts/92346aeb/"/>
    <id>http://shawnz.me/posts/92346aeb/</id>
    <published>2018-01-04T05:01:20.000Z</published>
    <updated>2018-03-10T06:20:54.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h2><p>Python中字典的实现策略:</p><ol><li>底层使用散列表进行存储</li></ol><a id="more"></a><ol><li>开放定址发检测冲突<ul><li>插入：发生冲突，通过二次探测算法，寻找下一个位置，直到找到可用位置，插入元素(构成一条”探测链“)。</li><li>查找：需要遍历“探测链”；</li><li>删除：如果对象在“探测链”上，不能直接删除元素，会导致探测链上的下个元素找不到，采用标记删除技术。</li></ul></li></ol><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="PyDictEntry"><a href="#PyDictEntry" class="headerlink" title="PyDictEntry"></a>PyDictEntry</h3><p>Python2中使用<code>PyDictEntry</code>定义一对<code>key-value</code>键值对：</p><pre><code class="c">typedef struct {    /* Cached hash code of me_key.  Note that hash codes are C longs.     * We have to use Py_ssize_t instead because dict_popitem() abuses     * me_hash to hold a search finger.     */    Py_ssize_t me_hash;    PyObject *me_key;    PyObject *me_value;} PyDictEntry;</code></pre><p>在一个<code>PyDictEntry</code>的生存变化过程中，<code>entey</code>会在几个状态之间切换：</p><ul><li><p><code>Unused</code>：当一个<code>entry</code>的<code>me_key</code>和<code>me_value</code>都是<code>NULL</code>时，<code>entry</code>处于<code>Unused</code>态。每个<code>entry</code>初始化时会处于这个状态，而且只有<code>Unused</code>态下，<code>me_key</code>才会为<code>NULL</code>。</p></li><li><p><code>Active</code>：当<code>entry</code>中存储着一对<code>me_key</code>和<code>me_value</code>时，<code>entry</code>处于<code>Active</code>态，在这个状态下，<code>me_key</code>和<code>me_value</code>都不能为<code>NULL</code>。</p></li><li><p><code>Dummy</code>：当删除一个键值对时，<code>entry</code>不能直接删除，这个时候<code>me_key</code>指向<code>dummy</code>对象，<code>entry</code>进入<code>Dummy</code>态。</p></li></ul><h3 id="PyDictObject"><a href="#PyDictObject" class="headerlink" title="PyDictObject"></a>PyDictObject</h3><p>Python2中字典的实现是<code>PyDictObject</code>，它是一堆<code>PyDictEntry</code>集合：</p><pre><code class="c">typedef struct _dictobject PyDictObject;struct _dictobject {    PyObject_HEAD    Py_ssize_t ma_fill;  /* 元素个数 Active + # Dummy */    Py_ssize_t ma_used;  /* 元素个数 Active */    /* The table contains ma_mask + 1 slots, and that&#39;s a power of 2.    * We store the mask instead of the size because the mask is more    * frequently needed.    */    Py_ssize_t ma_mask;    /* ma_table points to ma_smalltable for small tables, else to    * additional malloc&#39;ed memory.  ma_table is never NULL!  This rule    * saves repeated runtime null-tests in the workhorse getitem and    * setitem calls.    */    PyDictEntry *ma_table;    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);    PyDictEntry ma_smalltable[PyDict_MINSIZE];};</code></pre><p>其中：</p><ul><li><code>ma_fill</code>：维护着从<code>PyDictObject</code>创建开始直到现在，曾经及正处于<code>Active</code>态的<code>entry</code>；</li><li><code>ma_used</code>：维护着当期处于<code>Active</code>态的<code>entry</code>；</li><li><code>ma_smalltable</code>：当一个<code>PyDictObject</code>对象创建时，至少有<code>PyDict_MINSIZE</code>(8)个<code>entry</code>同时创建；</li><li><code>ma_table</code>：指向一片作为<code>PyDictEntry</code>集合的内存开始地址。Python对于一个小<code>dict</code>(即<code>entry</code>少于8个)，<code>ma_table</code>指向<code>ma_smalltable</code>，否则会申请一片额外的内存，并将<code>ma_table</code>指向它。(这个策略可以避免对<code>ma_table</code>的有效性检查);</li><li><code>ma_mask</code>：字典拥有的<code>entry</code>数量减一， 在将hash值映射到散列表上需要用到这个值；</li><li><code>ma_lookup</code>：字典的搜索策略。</li></ul><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code class="c">[Objects/dictobject.c]#define INIT_NONZERO_DICT_SLOTS(mp) do {                \    (mp)-&gt;ma_table = (mp)-&gt;ma_smalltable;                \    (mp)-&gt;ma_mask = PyDict_MINSIZE - 1;                \    } while(0)#define EMPTY_TO_MINSIZE(mp) do {                    \    memset((mp)-&gt;ma_smalltable, 0, sizeof((mp)-&gt;ma_smalltable));    \    (mp)-&gt;ma_used = (mp)-&gt;ma_fill = 0;                \    INIT_NONZERO_DICT_SLOTS(mp);                    \    } while(0)PyObject *PyDict_New(void){    register dictobject *mp;    /* dummy key */    if (dummy == NULL) { /* Auto-initialize dummy */        dummy = PyString_FromString(&quot;&lt;dummy key&gt;&quot;);        if (dummy == NULL)            return NULL;    }    /* 缓冲池机制 */    if (num_free_dicts) { /* 从缓冲池中去最后一个空闲对象 */        mp = free_dicts[--num_free_dicts];        _Py_NewReference((PyObject *)mp);        if (mp-&gt;ma_fill) {            EMPTY_TO_MINSIZE(mp);        } else {            /* 3. ma_table -&gt; ma_smalltable */            /* 4. ma_mask = PyDict_MINSIZE - 1 = 7 */            INIT_NONZERO_DICT_SLOTS(mp);        }    } else { /* 创建PyDictObject对象 */        mp = PyObject_GC_New(dictobject, &amp;PyDict_Type);        if (mp == NULL)            return NULL;        EMPTY_TO_MINSIZE(mp);    }    mp-&gt;ma_lookup = lookdict_string;    _PyObject_GC_TRACK(mp);    return (PyObject *)mp;}</code></pre><p>可以看到Python在创建<code>PyDictObject</code>会确保<code>dummy</code>的存在(这是一个特殊字符串)</p><p>和列表相同，字典也使用了缓冲池机制，如果缓冲池有空闲对象，就会从里面获取一个并进行清空操作：</p><ul><li><code>EMPTY_TO_MINSIZE</code>：将<code>small_table</code>清零，<code>ma_size=ma_fill=0</code>。</li><li><code>INIT_NONZERO_DICT_SLOTS</code>：将<code>ma_table</code>指向<code>small_table</code>，并设置<code>ma_mask=7</code>；</li></ul><p>在创建的最后，<code>lookdict_string</code>赋予给了<code>ma_lookup</code>，它指定了字典的搜索策略。</p><h2 id="搜索策略"><a href="#搜索策略" class="headerlink" title="搜索策略"></a>搜索策略</h2><p>Python 为字典提供了两种搜索策略：<code>lookdict</code>和<code>lookdict_string</code>(针对<code>PyStringObject</code>对象的特殊形式)。由于把字符串作为字典的键十分普遍，Python将<code>lookdict_string</code>作为字典的默认搜索策略。</p><p>在这里，我们还是看更一般的<code>lookdict</code>的实现：</p><pre><code class="c">static dictentry *lookdict(dictobject *mp, PyObject *key, register long hash){    register size_t i;    register size_t perturb;    register dictentry *freeslot;    register size_t mask = (size_t)mp-&gt;ma_mask;    dictentry *ep0 = mp-&gt;ma_table;    register dictentry *ep;    register int cmp;    PyObject *startkey;    /* [1].将散列值与mask做位与运算，保证了i落在范围内 */    i = (size_t)hash &amp; mask;    ep = &amp;ep0[i]; /* 找到散列表上该位置的元素 */    /* [2].entry处于Unused态或者key相等(同一个内存地址)，直接返回 */    if (ep-&gt;me_key == NULL || ep-&gt;me_key == key)        return ep; /* 包含两种情况：没找到和第一次散列就找到了 */    /* [3].Dummy态，设置freeslot */    if (ep-&gt;me_key == dummy)        freeslot = ep;    else {        if (ep-&gt;me_hash == hash) {            startkey = ep-&gt;me_key;            Py_INCREF(startkey);            cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);            Py_DECREF(startkey);            if (cmp &lt; 0)                return NULL;            if (ep0 == mp-&gt;ma_table &amp;&amp; ep-&gt;me_key == startkey) {                if (cmp &gt; 0)                    return ep;            }            else {                /* The compare did major nasty stuff to the                    * dict:  start over.                    * XXX A clever adversary could prevent this                    * XXX from terminating.                    */                return lookdict(mp, key, hash);            }        }        freeslot = NULL;    }    /* In the loop, me_key == dummy is by far (factor of 100s) the        least likely outcome, so test for that last. */    for (perturb = hash; ; perturb &gt;&gt;= PERTURB_SHIFT) {        i = (i &lt;&lt; 2) + i + perturb + 1;        ep = &amp;ep0[i &amp; mask];        if (ep-&gt;me_key == NULL)            return freeslot == NULL ? ep : freeslot;        if (ep-&gt;me_key == key)            return ep;        if (ep-&gt;me_hash == hash &amp;&amp; ep-&gt;me_key != dummy) {            startkey = ep-&gt;me_key;            Py_INCREF(startkey);            cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);            Py_DECREF(startkey);            if (cmp &lt; 0)                return NULL;            if (ep0 == mp-&gt;ma_table &amp;&amp; ep-&gt;me_key == startkey) {                if (cmp &gt; 0)                    return ep;            }            else {                /* The compare did major nasty stuff to the                    * dict:  start over.                    * XXX A clever adversary could prevent this                    * XXX from terminating.                    */                return lookdict(mp, key, hash);            }        }        else if (ep-&gt;me_key == dummy &amp;&amp; freeslot == NULL)            freeslot = ep;    }    assert(0);    /* NOT REACHED */    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;存储策略&quot;&gt;&lt;a href=&quot;#存储策略&quot; class=&quot;headerlink&quot; title=&quot;存储策略&quot;&gt;&lt;/a&gt;存储策略&lt;/h2&gt;&lt;p&gt;Python中字典的实现策略:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;底层使用散列表进行存储&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shawnz.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shawnz.me/tags/Python/"/>
    
      <category term="源码" scheme="http://shawnz.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
